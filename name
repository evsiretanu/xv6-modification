addflag.sh:ls *.c | xargs -I {} sed -i '1s/^/\#include \"RMME.h\"\n/' {}
asm.h:// The 0xC0 means the limit is in 4096-byte units
asm.h:// and (for executable segments) 32-bit mode.
asm.h:#define STA_E     0x4       // Expand down (non-executable segments)
asm.h:#define STA_W     0x2       // Writeable (non-executable segments)
bio.c:    b->next = bcache.head.next;
bio.c:    b->prev = &bcache.head;
bio.c:    b->dev = -1;
bio.c:    bcache.head.next->prev = b;
bio.c:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
bio.c:    if(b->dev == dev && b->blockno == blockno){
bio.c:      if(!(b->flags & B_BUSY)){
bio.c:        b->flags |= B_BUSY;
bio.c:  // Not cached; recycle some non-busy and clean buffer.
bio.c:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
bio.c:    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
bio.c:      b->dev = dev;
bio.c:      b->blockno = blockno;
bio.c:      b->flags = B_BUSY;
bio.c:  if(!(b->flags & B_VALID)) {
bio.c:  if((b->flags & B_BUSY) == 0)
bio.c:  b->flags |= B_DIRTY;
bio.c:  if((b->flags & B_BUSY) == 0)
bio.c:  b->next->prev = b->prev;
bio.c:  b->prev->next = b->next;
bio.c:  b->next = bcache.head.next;
bio.c:  b->prev = &bcache.head;
bio.c:  bcache.head.next->prev = b;
bio.c:  b->flags &= ~B_BUSY;
bio.d:bio.o: bio.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file bio.o matches
Binary file bootasm.o matches
bootasm.S:# Start the first CPU: switch to 32-bit protected mode, jump into C.
bootasm.S:.code16                       # Assemble for 16-bit mode
bootasm.S:  movw    %ax,%ds             # -> Data Segment
bootasm.S:  movw    %ax,%es             # -> Extra Segment
bootasm.S:  movw    %ax,%ss             # -> Stack Segment
bootasm.S:  movb    $0xd1,%al               # 0xd1 -> port 0x64
bootasm.S:  movb    $0xdf,%al               # 0xdf -> port 0x60
bootasm.S:  # Complete transition to 32-bit protected mode by using long jmp
bootasm.S:.code32  # Tell assembler to generate 32-bit code now.
bootasm.S:  # Set up the protected-mode data segment registers
bootasm.S:  movw    %ax, %ds                # -> DS: Data Segment
bootasm.S:  movw    %ax, %es                # -> ES: Extra Segment
bootasm.S:  movw    %ax, %ss                # -> SS: Stack Segment
bootasm.S:  movw    %ax, %fs                # -> FS
bootasm.S:  movw    %ax, %gs                # -> GS
bootasm.S:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
bootasm.S:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
bootasm.S:  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
bootblock.asm:bootblock.o:     file format elf32-i386
bootblock.asm:.code16                       # Assemble for 16-bit mode
bootblock.asm:  movw    %ax,%ds             # -> Data Segment
bootblock.asm:  movw    %ax,%es             # -> Extra Segment
bootblock.asm:  movw    %ax,%ss             # -> Stack Segment
bootblock.asm:  movb    $0xd1,%al               # 0xd1 -> port 0x64
bootblock.asm:  movb    $0xdf,%al               # 0xdf -> port 0x60
bootblock.asm:  # Complete transition to 32-bit protected mode by using long jmp
bootblock.asm:.code32  # Tell assembler to generate 32-bit code now.
bootblock.asm:  # Set up the protected-mode data segment registers
bootblock.asm:  movw    %ax, %ds                # -> DS: Data Segment
bootblock.asm:  movw    %ax, %es                # -> ES: Extra Segment
bootblock.asm:  movw    %ax, %ss                # -> SS: Stack Segment
bootblock.asm:  movw    %ax, %fs                # -> FS
bootblock.asm:  movw    %ax, %gs                # -> GS
bootblock.asm:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
bootblock.asm:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
bootblock.asm:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
bootblock.asm:  pa -= offset % SECTSIZE;
bootblock.asm:  // We'd write more to memory than asked, but it doesn't matter --
bootblock.asm:  // We'd write more to memory than asked, but it doesn't matter --
bootblock.asm:    7d33:	8d 65 f4             	lea    -0xc(%ebp),%esp
bootblock.asm:  if(elf->magic != ELF_MAGIC)
bootblock.asm:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
bootblock.asm:  eph = ph + elf->phnum;
bootblock.asm:    pa = (uchar*)ph->paddr;
bootblock.asm:    readseg(pa, ph->filesz, ph->off);
bootblock.asm:    if(ph->memsz > ph->filesz)
bootblock.asm:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
bootblock.asm:  eph = ph + elf->phnum;
bootblock.asm:  entry = (void(*)(void))(elf->entry);
bootblock.asm:    7db4:	8d 65 f4             	lea    -0xc(%ebp),%esp
Binary file bootblock.o matches
Binary file bootblockother.o matches
bootmain.c:// bootasm.S has put the processor into protected 32-bit mode.
bootmain.c:  if(elf->magic != ELF_MAGIC)
bootmain.c:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
bootmain.c:  eph = ph + elf->phnum;
bootmain.c:    pa = (uchar*)ph->paddr;
bootmain.c:    readseg(pa, ph->filesz, ph->off);
bootmain.c:    if(ph->memsz > ph->filesz)
bootmain.c:      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
bootmain.c:  entry = (void(*)(void))(elf->entry);
bootmain.c:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
bootmain.c:  pa -= offset % SECTSIZE;
bootmain.c:  // We'd write more to memory than asked, but it doesn't matter --
Binary file bootmain.o matches
BUGS:	can't always runcmd in child -- breaks cd.
BUGS:	maybe should hard-code PATH=/ ?
Binary file _cat matches
cat.asm:_cat:     file format elf32-i386
cat.asm:   b:	ff 75 f4             	pushl  -0xc(%ebp)
cat.asm:  35:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm:  38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm:  3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm:  65:	ff 71 fc             	pushl  -0x4(%ecx)
cat.asm:  89:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
cat.asm:  92:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm:  b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm:  b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
cat.asm:  ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm:  e6:	ff 75 f0             	pushl  -0x10(%ebp)
cat.asm:  f4:	ff 75 f0             	pushl  -0x10(%ebp)
cat.asm:  ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
cat.asm: 103:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 13e:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm: 160:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm:  return (uchar)*p - (uchar)*q;
cat.asm: 1aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
cat.asm: 1b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
cat.asm: 1b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
cat.asm: 1c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 1ee:	88 45 fc             	mov    %al,-0x4(%ebp)
cat.asm: 1f9:	3a 45 fc             	cmp    -0x4(%ebp),%al
cat.asm: 21e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
cat.asm: 22c:	8d 45 ef             	lea    -0x11(%ebp),%eax
cat.asm: 23a:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm: 23d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
cat.asm: 243:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 249:	89 55 f4             	mov    %edx,-0xc(%ebp)
cat.asm: 253:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
cat.asm: 259:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
cat.asm: 261:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
cat.asm: 269:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 277:	8b 55 f4             	mov    -0xc(%ebp),%edx
cat.asm: 29d:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm: 2a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm:    return -1;
cat.asm: 2b3:	ff 75 f4             	pushl  -0xc(%ebp)
cat.asm: 2be:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm: 2c4:	ff 75 f4             	pushl  -0xc(%ebp)
cat.asm: 2cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm: 2da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
cat.asm:  sign = (*s == '-') ? -1 : 1;
cat.asm: 307:	89 45 f8             	mov    %eax,-0x8(%ebp)
cat.asm:  if (*s == '+'  || *s == '-')
cat.asm:    n = n*10 + *s++ - '0';
cat.asm: 324:	8b 55 fc             	mov    -0x4(%ebp),%edx
cat.asm: 346:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm:  sign = (*s == '-') ? -1 : 1;
cat.asm:  if (*s == '+'  || *s == '-')
cat.asm:    n = n*10 + *s++ - '0';
cat.asm: 35d:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 360:	0f af 45 fc          	imul   -0x4(%ebp),%eax
cat.asm: 36c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
cat.asm:  sign = (*s == '-') ? -1 : 1;
cat.asm: 399:	89 45 f8             	mov    %eax,-0x8(%ebp)
cat.asm:  if (*s == '+'  || *s == '-')
cat.asm:    n = n*8 + *s++ - '0';
cat.asm: 3b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 3d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm:  sign = (*s == '-') ? -1 : 1;
cat.asm:  if (*s == '+'  || *s == '-')
cat.asm:    n = n*8 + *s++ - '0';
cat.asm: 3eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 3ee:	0f af 45 fc          	imul   -0x4(%ebp),%eax
cat.asm: 3fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm: 403:	89 45 f8             	mov    %eax,-0x8(%ebp)
cat.asm:  while(n-- > 0)
cat.asm: 408:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 40e:	89 55 fc             	mov    %edx,-0x4(%ebp)
cat.asm: 411:	8b 55 f8             	mov    -0x8(%ebp),%edx
cat.asm: 417:	89 4d f8             	mov    %ecx,-0x8(%ebp)
cat.asm:  while(n-- > 0)
cat.asm: 422:	8d 50 ff             	lea    -0x1(%eax),%edx
cat.asm:# Added calls - Evghenii
cat.asm: 522:	88 45 f4             	mov    %al,-0xc(%ebp)
cat.asm: 52a:	8d 45 f4             	lea    -0xc(%ebp),%eax
cat.asm: 543:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
cat.asm: 556:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
cat.asm:    x = -xx;
cat.asm: 562:	89 45 ec             	mov    %eax,-0x14(%ebp)
cat.asm: 56a:	89 45 ec             	mov    %eax,-0x14(%ebp)
cat.asm: 56d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
cat.asm: 574:	8b 4d f4             	mov    -0xc(%ebp),%ecx
cat.asm: 57a:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm: 580:	8b 45 ec             	mov    -0x14(%ebp),%eax
cat.asm: 593:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
cat.asm: 59a:	8b 45 ec             	mov    -0x14(%ebp),%eax
cat.asm: 5a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
cat.asm: 5a7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
cat.asm: 5ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
cat.asm:    buf[i++] = '-';
cat.asm: 5b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 5b9:	89 55 f4             	mov    %edx,-0xc(%ebp)
cat.asm: 5bc:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
cat.asm:  while(--i >= 0)
cat.asm: 5c3:	8d 55 dc             	lea    -0x24(%ebp),%edx
cat.asm: 5c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm:    buf[i++] = '-';
cat.asm:  while(--i >= 0)
cat.asm: 5e0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
cat.asm: 5e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm: 5eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
cat.asm: 5f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
cat.asm: 603:	89 45 e8             	mov    %eax,-0x18(%ebp)
cat.asm: 606:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
cat.asm: 615:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm: 625:	89 45 e4             	mov    %eax,-0x1c(%ebp)
cat.asm: 628:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
cat.asm: 62e:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
cat.asm: 634:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
cat.asm: 640:	8b 45 e4             	mov    -0x1c(%ebp),%eax
cat.asm: 65a:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
cat.asm: 664:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
cat.asm: 66a:	8b 45 e8             	mov    -0x18(%ebp),%eax
cat.asm: 67f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
cat.asm: 688:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
cat.asm: 68e:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
cat.asm: 694:	8b 45 e8             	mov    -0x18(%ebp),%eax
cat.asm: 6a9:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
cat.asm: 6b2:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
cat.asm: 6b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
cat.asm: 6bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm: 6c0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
cat.asm: 6c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm: 6ca:	c7 45 f4 cc 09 00 00 	movl   $0x9cc,-0xc(%ebp)
cat.asm: 6d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 6eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
cat.asm: 6ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 6fb:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
cat.asm: 701:	8b 45 e8             	mov    -0x18(%ebp),%eax
cat.asm: 718:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
cat.asm: 71e:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
cat.asm: 724:	8b 45 e4             	mov    -0x1c(%ebp),%eax
cat.asm: 74b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
cat.asm: 760:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
cat.asm: 767:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
cat.asm: 76e:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm:  bp = (Header*)ap - 1;
cat.asm: 78d:	89 45 f8             	mov    %eax,-0x8(%ebp)
cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
cat.asm: 795:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
cat.asm: 79a:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 79f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
cat.asm: 7a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 7a7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
cat.asm: 7ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 7b1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
cat.asm:  bp = (Header*)ap - 1;
cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
cat.asm: 7b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 7bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
cat.asm: 7be:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 7c1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
cat.asm: 7c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 7cb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
cat.asm:  if(bp + bp->s.size == p->s.ptr){
cat.asm: 7d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 7dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 7e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm:    bp->s.size += p->s.ptr->s.size;
cat.asm: 7eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 7f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 7fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
cat.asm: 801:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 808:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm:    bp->s.ptr = p->s.ptr;
cat.asm: 80f:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 814:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm:  if(p + p->s.size == bp){
cat.asm: 819:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 826:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 82b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
cat.asm:    p->s.size += bp->s.size;
cat.asm: 830:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 836:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 83e:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm:    p->s.ptr = bp->s.ptr;
cat.asm: 844:	8b 45 f8             	mov    -0x8(%ebp),%eax
cat.asm: 849:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm:    p->s.ptr = bp;
cat.asm: 850:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 853:	8b 55 f8             	mov    -0x8(%ebp),%edx
cat.asm: 858:	8b 45 fc             	mov    -0x4(%ebp),%eax
cat.asm: 88b:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm:  if(p == (char*)-1)
cat.asm: 88e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
cat.asm: 89b:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 89e:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm:  hp->s.size = nu;
cat.asm: 8a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm: 8aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
cat.asm: 8d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
cat.asm: 8dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm: 8e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
cat.asm: 8e6:	c7 45 f0 80 0c 00 00 	movl   $0xc80,-0x10(%ebp)
cat.asm: 8ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
cat.asm: 909:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm: 90e:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm:    if(p->s.size >= nunits){
cat.asm: 911:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 917:	3b 45 ec             	cmp    -0x14(%ebp),%eax
cat.asm:      if(p->s.size == nunits)
cat.asm: 91c:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 922:	3b 45 ec             	cmp    -0x14(%ebp),%eax
cat.asm:        prevp->s.ptr = p->s.ptr;
cat.asm: 927:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 92c:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm:        p->s.size -= nunits;
cat.asm: 933:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 939:	2b 45 ec             	sub    -0x14(%ebp),%eax
cat.asm: 93e:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm:        p += p->s.size;
cat.asm: 944:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 94d:	01 45 f4             	add    %eax,-0xc(%ebp)
cat.asm:        p->s.size = nunits;
cat.asm: 950:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 953:	8b 55 ec             	mov    -0x14(%ebp),%edx
cat.asm: 959:	8b 45 f0             	mov    -0x10(%ebp),%eax
cat.asm: 961:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 96e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
cat.asm: 976:	ff 75 ec             	pushl  -0x14(%ebp)
cat.asm: 981:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.asm: 984:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
cat.asm: 991:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 994:	89 45 f0             	mov    %eax,-0x10(%ebp)
cat.asm: 997:	8b 45 f4             	mov    -0xc(%ebp),%eax
cat.asm: 99c:	89 45 f4             	mov    %eax,-0xc(%ebp)
cat.d:cat.o: cat.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file cat.o matches
CMakeLists.txt:add_definitions(-CS333_P2, -CS333_P4)
CMakeLists.txt:        dot-bochsrc
CMakeLists.txt:        p5-test.c
CMakeLists.txt:        p5-test.h
CMakeLists.txt:        README-PSU
console.c:    x = -xx;
console.c:    buf[i++] = '-';
console.c:  while(--i >= 0)
console.c:  cprintf("cpu%d: panic: ", cpu->id);
console.c:    pos += 80 - pos%80;
console.c:    if(pos > 0) --pos;
console.c:    pos -= 80;
console.c:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
console.c:#define C(x)  ((x)-'@')  // Control-x
console.c:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
console.c:        input.e--;
console.c:        input.e--;
console.c:      if(c != 0 && input.e-input.r < INPUT_BUF){
console.c:      if(proc->killed){
console.c:        return -1;
console.c:        // caller gets a 0-byte result.
console.c:        input.r--;
console.c:    --n;
console.c:  return target - n;
console.d:console.o: console.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file console.o matches
cuth:	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
cuth:	for($j=@lines-1; $j>=0; $j--){
cuth:			$lines[$j] = "/* CUT-H */\n";
cuth:			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
cuth:	writefile($file, grep {!/CUT-H/} @lines);
Binary file _date matches
date.asm:_date:     file format elf32-i386
date.asm:  return (d+=m<3?y--:y-2,23*m/9+d+4+y/4-y/100+y/400)%7;
date.asm:   d:	8d 50 ff             	lea    -0x1(%eax),%edx
date.asm:  b3:	ff 71 fc             	pushl  -0x4(%ecx)
date.asm:  c0:	8d 45 dc             	lea    -0x24(%ebp),%eax
date.asm:  eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
date.asm:  f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
date.asm:  f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: 106:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm: 109:	8b 4d e8             	mov    -0x18(%ebp),%ecx
date.asm: 10c:	8b 45 ec             	mov    -0x14(%ebp),%eax
date.asm: 116:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 147:	8b 45 e4             	mov    -0x1c(%ebp),%eax
date.asm: 161:	8b 45 e4             	mov    -0x1c(%ebp),%eax
date.asm: 177:	8b 45 e0             	mov    -0x20(%ebp),%eax
date.asm: 191:	8b 45 e0             	mov    -0x20(%ebp),%eax
date.asm: 1a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
date.asm: 1c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
date.asm: 1c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
date.asm: 20c:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm: 22e:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm:  return (uchar)*p - (uchar)*q;
date.asm: 278:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
date.asm: 281:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
date.asm: 285:	8b 55 fc             	mov    -0x4(%ebp),%edx
date.asm: 294:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 2bc:	88 45 fc             	mov    %al,-0x4(%ebp)
date.asm: 2c7:	3a 45 fc             	cmp    -0x4(%ebp),%al
date.asm: 2ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
date.asm: 2fa:	8d 45 ef             	lea    -0x11(%ebp),%eax
date.asm: 308:	89 45 f0             	mov    %eax,-0x10(%ebp)
date.asm: 30b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
date.asm: 311:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 317:	89 55 f4             	mov    %edx,-0xc(%ebp)
date.asm: 321:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
date.asm: 327:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
date.asm: 32f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
date.asm: 337:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 345:	8b 55 f4             	mov    -0xc(%ebp),%edx
date.asm: 36b:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm: 36e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
date.asm:    return -1;
date.asm: 381:	ff 75 f4             	pushl  -0xc(%ebp)
date.asm: 38c:	89 45 f0             	mov    %eax,-0x10(%ebp)
date.asm: 392:	ff 75 f4             	pushl  -0xc(%ebp)
date.asm: 39d:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: 3a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
date.asm:  sign = (*s == '-') ? -1 : 1;
date.asm: 3d5:	89 45 f8             	mov    %eax,-0x8(%ebp)
date.asm:  if (*s == '+'  || *s == '-')
date.asm:    n = n*10 + *s++ - '0';
date.asm: 3f2:	8b 55 fc             	mov    -0x4(%ebp),%edx
date.asm: 414:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm:  sign = (*s == '-') ? -1 : 1;
date.asm:  if (*s == '+'  || *s == '-')
date.asm:    n = n*10 + *s++ - '0';
date.asm: 42b:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 42e:	0f af 45 fc          	imul   -0x4(%ebp),%eax
date.asm: 43a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
date.asm:  sign = (*s == '-') ? -1 : 1;
date.asm: 467:	89 45 f8             	mov    %eax,-0x8(%ebp)
date.asm:  if (*s == '+'  || *s == '-')
date.asm:    n = n*8 + *s++ - '0';
date.asm: 484:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 4a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm:  sign = (*s == '-') ? -1 : 1;
date.asm:  if (*s == '+'  || *s == '-')
date.asm:    n = n*8 + *s++ - '0';
date.asm: 4b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 4bc:	0f af 45 fc          	imul   -0x4(%ebp),%eax
date.asm: 4cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm: 4d1:	89 45 f8             	mov    %eax,-0x8(%ebp)
date.asm:  while(n-- > 0)
date.asm: 4d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 4dc:	89 55 fc             	mov    %edx,-0x4(%ebp)
date.asm: 4df:	8b 55 f8             	mov    -0x8(%ebp),%edx
date.asm: 4e5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
date.asm:  while(n-- > 0)
date.asm: 4f0:	8d 50 ff             	lea    -0x1(%eax),%edx
date.asm:# Added calls - Evghenii
date.asm: 5f0:	88 45 f4             	mov    %al,-0xc(%ebp)
date.asm: 5f8:	8d 45 f4             	lea    -0xc(%ebp),%eax
date.asm: 611:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
date.asm: 624:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
date.asm:    x = -xx;
date.asm: 630:	89 45 ec             	mov    %eax,-0x14(%ebp)
date.asm: 638:	89 45 ec             	mov    %eax,-0x14(%ebp)
date.asm: 63b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
date.asm: 642:	8b 4d f4             	mov    -0xc(%ebp),%ecx
date.asm: 648:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm: 64e:	8b 45 ec             	mov    -0x14(%ebp),%eax
date.asm: 661:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
date.asm: 668:	8b 45 ec             	mov    -0x14(%ebp),%eax
date.asm: 672:	89 45 ec             	mov    %eax,-0x14(%ebp)
date.asm: 675:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
date.asm: 67b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
date.asm:    buf[i++] = '-';
date.asm: 681:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 687:	89 55 f4             	mov    %edx,-0xc(%ebp)
date.asm: 68a:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
date.asm:  while(--i >= 0)
date.asm: 691:	8d 55 dc             	lea    -0x24(%ebp),%edx
date.asm: 694:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm:    buf[i++] = '-';
date.asm:  while(--i >= 0)
date.asm: 6ae:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
date.asm: 6b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
date.asm: 6b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
date.asm: 6c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
date.asm: 6d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
date.asm: 6d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
date.asm: 6e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: 6f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
date.asm: 6f6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
date.asm: 6fc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
date.asm: 702:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
date.asm: 70e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
date.asm: 728:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
date.asm: 732:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
date.asm: 738:	8b 45 e8             	mov    -0x18(%ebp),%eax
date.asm: 74d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
date.asm: 756:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
date.asm: 75c:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
date.asm: 762:	8b 45 e8             	mov    -0x18(%ebp),%eax
date.asm: 777:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
date.asm: 780:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
date.asm: 786:	8b 45 e8             	mov    -0x18(%ebp),%eax
date.asm: 78b:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm: 78e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
date.asm: 792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
date.asm: 798:	c7 45 f4 10 0b 00 00 	movl   $0xb10,-0xc(%ebp)
date.asm: 7a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 7b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
date.asm: 7bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 7c9:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
date.asm: 7cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
date.asm: 7e6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
date.asm: 7ec:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
date.asm: 7f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
date.asm: 819:	8b 45 e4             	mov    -0x1c(%ebp),%eax
date.asm: 82e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
date.asm: 835:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
date.asm: 83c:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm:  bp = (Header*)ap - 1;
date.asm: 85b:	89 45 f8             	mov    %eax,-0x8(%ebp)
date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
date.asm: 863:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
date.asm: 868:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 86d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
date.asm: 872:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 875:	3b 45 fc             	cmp    -0x4(%ebp),%eax
date.asm: 87a:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 87f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
date.asm:  bp = (Header*)ap - 1;
date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
date.asm: 884:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 889:	89 45 fc             	mov    %eax,-0x4(%ebp)
date.asm: 88c:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 88f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
date.asm: 894:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 899:	3b 45 f8             	cmp    -0x8(%ebp),%eax
date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
date.asm:  if(bp + bp->s.size == p->s.ptr){
date.asm: 89e:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 8ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 8b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm:    bp->s.size += p->s.ptr->s.size;
date.asm: 8b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 8bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 8c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm:    bp->s.ptr = p->s.ptr->s.ptr;
date.asm: 8cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 8d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm:    bp->s.ptr = p->s.ptr;
date.asm: 8dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 8e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm:  if(p + p->s.size == bp){
date.asm: 8e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 8f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 8f9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
date.asm:    p->s.size += bp->s.size;
date.asm: 8fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 904:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 90c:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm:    p->s.ptr = bp->s.ptr;
date.asm: 912:	8b 45 f8             	mov    -0x8(%ebp),%eax
date.asm: 917:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm:    p->s.ptr = bp;
date.asm: 91e:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 921:	8b 55 f8             	mov    -0x8(%ebp),%edx
date.asm: 926:	8b 45 fc             	mov    -0x4(%ebp),%eax
date.asm: 959:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm:  if(p == (char*)-1)
date.asm: 95c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
date.asm: 969:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 96c:	89 45 f0             	mov    %eax,-0x10(%ebp)
date.asm:  hp->s.size = nu;
date.asm: 96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: 978:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
date.asm: 9a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
date.asm: 9ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
date.asm: 9ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
date.asm: 9b4:	c7 45 f0 24 0e 00 00 	movl   $0xe24,-0x10(%ebp)
date.asm: 9bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
date.asm: 9d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: 9dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm:    if(p->s.size >= nunits){
date.asm: 9df:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 9e5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
date.asm:      if(p->s.size == nunits)
date.asm: 9ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 9f0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
date.asm:        prevp->s.ptr = p->s.ptr;
date.asm: 9f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: 9fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm:        p->s.size -= nunits;
date.asm: a01:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a07:	2b 45 ec             	sub    -0x14(%ebp),%eax
date.asm: a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm:        p += p->s.size;
date.asm: a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a1b:	01 45 f4             	add    %eax,-0xc(%ebp)
date.asm:        p->s.size = nunits;
date.asm: a1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a21:	8b 55 ec             	mov    -0x14(%ebp),%edx
date.asm: a27:	8b 45 f0             	mov    -0x10(%ebp),%eax
date.asm: a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a3c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
date.asm: a44:	ff 75 ec             	pushl  -0x14(%ebp)
date.asm: a4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.asm: a52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
date.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
date.asm: a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a62:	89 45 f0             	mov    %eax,-0x10(%ebp)
date.asm: a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
date.asm: a6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
date.c:  return (d+=m<3?y--:y-2,23*m/9+d+4+y/4-y/100+y/400)%7;
date.d:date.o: date.c /usr/include/stdc-predef.h RMME.h types.h user.h date.h
Binary file date.o matches
defs.h:// number of elements in fixed-size array
dot-bochsrc:# version is only available when you use "--with-wx" on the configure 
dot-bochsrc:# different platforms.  If you run configure with multiple --with-* options, 
dot-bochsrc:#   macintosh      use MacOS pre-10
dot-bochsrc:# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
dot-bochsrc:romimage: file=$BXSHARE/BIOS-bochs-latest
dot-bochsrc:# This defines cpu-related parameters inside Bochs:
dot-bochsrc:#  --enable-show-ips option enabled, to find your workstation's capability.
dot-bochsrc:#  IPS is used to calibrate many time-dependent events within the bochs 
dot-bochsrc:#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
dot-bochsrc:#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
dot-bochsrc:# OPTROMIMAGE[1-4]:
dot-bochsrc:# read-only area, typically between C8000 and EFFFF. These optional
dot-bochsrc:# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
dot-bochsrc:#vgaromimage: file=bios/VGABIOS-elpin-2.40
dot-bochsrc:vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
dot-bochsrc:#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
dot-bochsrc:# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
dot-bochsrc:# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
dot-bochsrc:# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
dot-bochsrc:#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
dot-bochsrc:#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
dot-bochsrc:#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
dot-bochsrc:#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
dot-bochsrc:#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
dot-bochsrc:#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
dot-bochsrc:#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
dot-bochsrc:#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
dot-bochsrc:ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
dot-bochsrc:ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
dot-bochsrc:#ata0-slave: type=cdrom, path=D:, status=inserted
dot-bochsrc:#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
dot-bochsrc:#ata0-slave: type=cdrom, path="drive", status=inserted
dot-bochsrc:#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
dot-bochsrc:# '-' the output is written to the console. If you really don't want it,
dot-bochsrc:#   logprefix: %t-%e-@%i-%d
dot-bochsrc:# If you really don't want it, make it /dev/null or '-'. :^(
dot-bochsrc:debugger_log: -
dot-bochsrc:# specified as the 'dev' parameter), 'raw' (use the real serial port - under
dot-bochsrc:# construction for win32), 'mouse' (standard serial mouse - requires
dot-bochsrc:#      non-continuous sound.  750000 is usually a good value.  This needs a
dot-bochsrc:# of emulated instructions-per-second your workstation can do, for this
dot-bochsrc:# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
dot-bochsrc:# connected with the 'mouse' device - requires PCI and USB support).
dot-bochsrc:#                   non-shared colormap.  This colormap will be used
dot-bochsrc:#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
dot-bochsrc:#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
dot-bochsrc:# exception is french macs, that do have a "at"-like keyboard.
dot-bochsrc:# 3 key names (listed below) separated with a '-' character. The old-style
dot-bochsrc:# syntax (without the '-') still works for the key combinations supported
dot-bochsrc:#   user_shortcut: keys=ctrl-alt-del
dot-bochsrc:#user_shortcut: keys=ctrl-alt-del
dot-bochsrc:# have a 3-button USB mouse.
dot-bochsrc:#-------------------------
dot-bochsrc:#-------------------------
dot-bochsrc:# vgaromimage: :bios:VGABIOS-elpin-2.40
dot-bochsrc:# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
Binary file _echo matches
echo.asm:_echo:     file format elf32-i386
echo.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
echo.asm:  14:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
echo.asm:  1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm:  33:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm:  55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
echo.asm:  59:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm:  94:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm:  b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm:  return (uchar)*p - (uchar)*q;
echo.asm: 100:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
echo.asm: 109:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
echo.asm: 10d:	8b 55 fc             	mov    -0x4(%ebp),%edx
echo.asm: 11c:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 144:	88 45 fc             	mov    %al,-0x4(%ebp)
echo.asm: 14f:	3a 45 fc             	cmp    -0x4(%ebp),%al
echo.asm: 174:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
echo.asm: 182:	8d 45 ef             	lea    -0x11(%ebp),%eax
echo.asm: 190:	89 45 f0             	mov    %eax,-0x10(%ebp)
echo.asm: 193:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
echo.asm: 199:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 19f:	89 55 f4             	mov    %edx,-0xc(%ebp)
echo.asm: 1a9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
echo.asm: 1af:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
echo.asm: 1b7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
echo.asm: 1bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 1cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
echo.asm: 1f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm: 1f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
echo.asm:    return -1;
echo.asm: 209:	ff 75 f4             	pushl  -0xc(%ebp)
echo.asm: 214:	89 45 f0             	mov    %eax,-0x10(%ebp)
echo.asm: 21a:	ff 75 f4             	pushl  -0xc(%ebp)
echo.asm: 225:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm: 230:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
echo.asm:  sign = (*s == '-') ? -1 : 1;
echo.asm: 25d:	89 45 f8             	mov    %eax,-0x8(%ebp)
echo.asm:  if (*s == '+'  || *s == '-')
echo.asm:    n = n*10 + *s++ - '0';
echo.asm: 27a:	8b 55 fc             	mov    -0x4(%ebp),%edx
echo.asm: 29c:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm:  sign = (*s == '-') ? -1 : 1;
echo.asm:  if (*s == '+'  || *s == '-')
echo.asm:    n = n*10 + *s++ - '0';
echo.asm: 2b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 2b6:	0f af 45 fc          	imul   -0x4(%ebp),%eax
echo.asm: 2c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
echo.asm:  sign = (*s == '-') ? -1 : 1;
echo.asm: 2ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
echo.asm:  if (*s == '+'  || *s == '-')
echo.asm:    n = n*8 + *s++ - '0';
echo.asm: 30c:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 32a:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm:  sign = (*s == '-') ? -1 : 1;
echo.asm:  if (*s == '+'  || *s == '-')
echo.asm:    n = n*8 + *s++ - '0';
echo.asm: 341:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 344:	0f af 45 fc          	imul   -0x4(%ebp),%eax
echo.asm: 353:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm: 359:	89 45 f8             	mov    %eax,-0x8(%ebp)
echo.asm:  while(n-- > 0)
echo.asm: 35e:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 364:	89 55 fc             	mov    %edx,-0x4(%ebp)
echo.asm: 367:	8b 55 f8             	mov    -0x8(%ebp),%edx
echo.asm: 36d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
echo.asm:  while(n-- > 0)
echo.asm: 378:	8d 50 ff             	lea    -0x1(%eax),%edx
echo.asm:# Added calls - Evghenii
echo.asm: 478:	88 45 f4             	mov    %al,-0xc(%ebp)
echo.asm: 480:	8d 45 f4             	lea    -0xc(%ebp),%eax
echo.asm: 499:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
echo.asm: 4ac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
echo.asm:    x = -xx;
echo.asm: 4b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
echo.asm: 4c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
echo.asm: 4c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
echo.asm: 4ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
echo.asm: 4d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm: 4d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
echo.asm: 4e9:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
echo.asm: 4f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
echo.asm: 4fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
echo.asm: 4fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
echo.asm: 503:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
echo.asm:    buf[i++] = '-';
echo.asm: 509:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 50f:	89 55 f4             	mov    %edx,-0xc(%ebp)
echo.asm: 512:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
echo.asm:  while(--i >= 0)
echo.asm: 519:	8d 55 dc             	lea    -0x24(%ebp),%edx
echo.asm: 51c:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm:    buf[i++] = '-';
echo.asm:  while(--i >= 0)
echo.asm: 536:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
echo.asm: 53a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
echo.asm: 541:	8b 5d fc             	mov    -0x4(%ebp),%ebx
echo.asm: 54c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
echo.asm: 559:	89 45 e8             	mov    %eax,-0x18(%ebp)
echo.asm: 55c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
echo.asm: 56b:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm: 57b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
echo.asm: 57e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
echo.asm: 584:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
echo.asm: 58a:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
echo.asm: 596:	8b 45 e4             	mov    -0x1c(%ebp),%eax
echo.asm: 5b0:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
echo.asm: 5ba:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
echo.asm: 5c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
echo.asm: 5d5:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
echo.asm: 5de:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
echo.asm: 5e4:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
echo.asm: 5ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
echo.asm: 5ff:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
echo.asm: 608:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
echo.asm: 60e:	8b 45 e8             	mov    -0x18(%ebp),%eax
echo.asm: 613:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm: 616:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
echo.asm: 61a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
echo.asm: 620:	c7 45 f4 05 09 00 00 	movl   $0x905,-0xc(%ebp)
echo.asm: 629:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 641:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
echo.asm: 645:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 651:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
echo.asm: 657:	8b 45 e8             	mov    -0x18(%ebp),%eax
echo.asm: 66e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
echo.asm: 674:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
echo.asm: 67a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
echo.asm: 6a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
echo.asm: 6b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
echo.asm: 6bd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
echo.asm: 6c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm:  bp = (Header*)ap - 1;
echo.asm: 6e3:	89 45 f8             	mov    %eax,-0x8(%ebp)
echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
echo.asm: 6eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
echo.asm: 6f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 6f5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
echo.asm: 6fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 6fd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
echo.asm: 702:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 707:	3b 45 f8             	cmp    -0x8(%ebp),%eax
echo.asm:  bp = (Header*)ap - 1;
echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
echo.asm: 70c:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 711:	89 45 fc             	mov    %eax,-0x4(%ebp)
echo.asm: 714:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 717:	3b 45 fc             	cmp    -0x4(%ebp),%eax
echo.asm: 71c:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 721:	3b 45 f8             	cmp    -0x8(%ebp),%eax
echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
echo.asm:  if(bp + bp->s.size == p->s.ptr){
echo.asm: 726:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 733:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 738:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm:    bp->s.size += p->s.ptr->s.size;
echo.asm: 741:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 747:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 751:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
echo.asm: 757:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm:    bp->s.ptr = p->s.ptr;
echo.asm: 765:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 76a:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm:  if(p + p->s.size == bp){
echo.asm: 76f:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 77c:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 781:	3b 45 f8             	cmp    -0x8(%ebp),%eax
echo.asm:    p->s.size += bp->s.size;
echo.asm: 786:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 78c:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 794:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm:    p->s.ptr = bp->s.ptr;
echo.asm: 79a:	8b 45 f8             	mov    -0x8(%ebp),%eax
echo.asm: 79f:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm:    p->s.ptr = bp;
echo.asm: 7a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 7a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
echo.asm: 7ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
echo.asm: 7e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm:  if(p == (char*)-1)
echo.asm: 7e4:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
echo.asm: 7f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 7f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
echo.asm:  hp->s.size = nu;
echo.asm: 7f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm: 800:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
echo.asm: 82b:	89 45 ec             	mov    %eax,-0x14(%ebp)
echo.asm: 833:	89 45 f0             	mov    %eax,-0x10(%ebp)
echo.asm: 836:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
echo.asm: 83c:	c7 45 f0 8c 0b 00 00 	movl   $0xb8c,-0x10(%ebp)
echo.asm: 843:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
echo.asm: 85f:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm: 864:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm:    if(p->s.size >= nunits){
echo.asm: 867:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 86d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
echo.asm:      if(p->s.size == nunits)
echo.asm: 872:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 878:	3b 45 ec             	cmp    -0x14(%ebp),%eax
echo.asm:        prevp->s.ptr = p->s.ptr;
echo.asm: 87d:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 882:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm:        p->s.size -= nunits;
echo.asm: 889:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 88f:	2b 45 ec             	sub    -0x14(%ebp),%eax
echo.asm: 894:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm:        p += p->s.size;
echo.asm: 89a:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 8a3:	01 45 f4             	add    %eax,-0xc(%ebp)
echo.asm:        p->s.size = nunits;
echo.asm: 8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 8a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
echo.asm: 8af:	8b 45 f0             	mov    -0x10(%ebp),%eax
echo.asm: 8b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 8c4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
echo.asm: 8cc:	ff 75 ec             	pushl  -0x14(%ebp)
echo.asm: 8d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.asm: 8da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
echo.asm: 8e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 8ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
echo.asm: 8ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
echo.asm: 8f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
echo.d:echo.o: echo.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file echo.o matches
entryother.asm:bootblockother.o:     file format elf32-i386
entryother.asm:#   - it uses the address at start-4, start-8, and start-12
entryother.asm:  movl    (start-12), %eax
entryother.asm:  movl    (start-4), %esp
entryother.asm:  call	 *(start-8)
entryother.S:# Each non-boot CPU ("AP") is started up in response to a STARTUP
entryother.S:# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
entryother.S:# set to XY00:0000, where XY is an 8-bit value sent with the
entryother.S:# STARTUP. Thus this code must start at a 4096-byte boundary.
entryother.S:# a newly allocated per-core stack in start-4,the address of the
entryother.S:# place to jump to (mpenter) in start-8, and the physical address
entryother.S:# of entrypgdir in start-12.
entryother.S:#   - it does not need to enable A20
entryother.S:#   - it uses the address at start-4, start-8, and start-12
entryother.S:  movl    (start-12), %eax
entryother.S:  movl    (start-4), %esp
entryother.S:  call	 *(start-8)
entryother.S:  .word   (gdtdesc - gdt - 1)
entry.S:  .long (-magic-flags)
entry.S:  # the assembler produces a PC-relative instruction
exec.c:    return -1;
exec.c:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
exec.c:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
exec.c:  ustack[2] = sp - (argc+1)*4;  // argv pointer
exec.c:  sp -= (3+argc+1) * 4;
exec.c:  safestrcpy(proc->name, last, sizeof(proc->name));
exec.c:  oldpgdir = proc->pgdir;
exec.c:  proc->pgdir = pgdir;
exec.c:  proc->sz = sz;
exec.c:  proc->tf->eip = elf.entry;  // main
exec.c:  proc->tf->esp = sp;
exec.c:  return -1;
exec.d:exec.o: exec.c /usr/include/stdc-predef.h RMME.h types.h param.h \
Binary file exec.o matches
file.c:    if(f->ref == 0){
file.c:      f->ref = 1;
file.c:  if(f->ref < 1)
file.c:  f->ref++;
file.c:  if(f->ref < 1)
file.c:  if(--f->ref > 0){
file.c:  f->ref = 0;
file.c:  f->type = FD_NONE;
file.c:  if(f->type == FD_INODE){
file.c:    ilock(f->ip);
file.c:    stati(f->ip, st);
file.c:    iunlock(f->ip);
file.c:  return -1;
file.c:  if(f->readable == 0)
file.c:    return -1;
file.c:  if(f->type == FD_PIPE)
file.c:    return piperead(f->pipe, addr, n);
file.c:  if(f->type == FD_INODE){
file.c:    ilock(f->ip);
file.c:    if((r = readi(f->ip, addr, f->off, n)) > 0)
file.c:      f->off += r;
file.c:    iunlock(f->ip);
file.c:  if(f->writable == 0)
file.c:    return -1;
file.c:  if(f->type == FD_PIPE)
file.c:    return pipewrite(f->pipe, addr, n);
file.c:  if(f->type == FD_INODE){
file.c:    // i-node, indirect block, allocation blocks,
file.c:    // and 2 blocks of slop for non-aligned writes.
file.c:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
file.c:      int n1 = n - i;
file.c:      ilock(f->ip);
file.c:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
file.c:        f->off += r;
file.c:      iunlock(f->ip);
file.c:    return i == n ? n : -1;
file.d:file.o: file.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
file.h:// in-memory copy of an inode
Binary file file.o matches
Binary file _forktest matches
forktest.asm:_forktest:     file format elf32-i386
forktest.asm:  41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
forktest.asm:  4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
forktest.asm:  52:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
forktest.asm:  58:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
forktest.asm:  63:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
forktest.asm:  67:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
forktest.asm:  73:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
forktest.asm:  for(; n > 0; n--){
forktest.asm:  for(; n > 0; n--){
forktest.asm:  b8:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
forktest.asm:  bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
forktest.asm:  if(wait() != -1){
forktest.asm:  ff:	ff 71 fc             	pushl  -0x4(%ecx)
forktest.asm: 142:	89 45 fc             	mov    %eax,-0x4(%ebp)
forktest.asm: 164:	8b 45 fc             	mov    -0x4(%ebp),%eax
forktest.asm:  return (uchar)*p - (uchar)*q;
forktest.asm: 1ae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
forktest.asm: 1b7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
forktest.asm: 1bb:	8b 55 fc             	mov    -0x4(%ebp),%edx
forktest.asm: 1ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
forktest.asm: 1f2:	88 45 fc             	mov    %al,-0x4(%ebp)
forktest.asm: 1fd:	3a 45 fc             	cmp    -0x4(%ebp),%al
forktest.asm: 222:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
forktest.asm: 230:	8d 45 ef             	lea    -0x11(%ebp),%eax
forktest.asm: 23e:	89 45 f0             	mov    %eax,-0x10(%ebp)
forktest.asm: 241:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
forktest.asm: 247:	8b 45 f4             	mov    -0xc(%ebp),%eax
forktest.asm: 24d:	89 55 f4             	mov    %edx,-0xc(%ebp)
forktest.asm: 257:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
forktest.asm: 25d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
forktest.asm: 265:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
forktest.asm: 26d:	8b 45 f4             	mov    -0xc(%ebp),%eax
forktest.asm: 27b:	8b 55 f4             	mov    -0xc(%ebp),%edx
forktest.asm: 2a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
forktest.asm: 2a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
forktest.asm:    return -1;
forktest.asm: 2b7:	ff 75 f4             	pushl  -0xc(%ebp)
forktest.asm: 2c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
forktest.asm: 2c8:	ff 75 f4             	pushl  -0xc(%ebp)
forktest.asm: 2d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
forktest.asm: 2de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
forktest.asm:  sign = (*s == '-') ? -1 : 1;
forktest.asm: 30b:	89 45 f8             	mov    %eax,-0x8(%ebp)
forktest.asm:  if (*s == '+'  || *s == '-')
forktest.asm:    n = n*10 + *s++ - '0';
forktest.asm: 328:	8b 55 fc             	mov    -0x4(%ebp),%edx
forktest.asm: 34a:	89 45 fc             	mov    %eax,-0x4(%ebp)
forktest.asm:  sign = (*s == '-') ? -1 : 1;
forktest.asm:  if (*s == '+'  || *s == '-')
forktest.asm:    n = n*10 + *s++ - '0';
forktest.asm: 361:	8b 45 f8             	mov    -0x8(%ebp),%eax
forktest.asm: 364:	0f af 45 fc          	imul   -0x4(%ebp),%eax
forktest.asm: 370:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
forktest.asm:  sign = (*s == '-') ? -1 : 1;
forktest.asm: 39d:	89 45 f8             	mov    %eax,-0x8(%ebp)
forktest.asm:  if (*s == '+'  || *s == '-')
forktest.asm:    n = n*8 + *s++ - '0';
forktest.asm: 3ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
forktest.asm: 3d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
forktest.asm:  sign = (*s == '-') ? -1 : 1;
forktest.asm:  if (*s == '+'  || *s == '-')
forktest.asm:    n = n*8 + *s++ - '0';
forktest.asm: 3ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
forktest.asm: 3f2:	0f af 45 fc          	imul   -0x4(%ebp),%eax
forktest.asm: 401:	89 45 fc             	mov    %eax,-0x4(%ebp)
forktest.asm: 407:	89 45 f8             	mov    %eax,-0x8(%ebp)
forktest.asm:  while(n-- > 0)
forktest.asm: 40c:	8b 45 fc             	mov    -0x4(%ebp),%eax
forktest.asm: 412:	89 55 fc             	mov    %edx,-0x4(%ebp)
forktest.asm: 415:	8b 55 f8             	mov    -0x8(%ebp),%edx
forktest.asm: 41b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
forktest.asm:  while(n-- > 0)
forktest.asm: 426:	8d 50 ff             	lea    -0x1(%eax),%edx
forktest.asm:# Added calls - Evghenii
forktest.c:  for(; n > 0; n--){
forktest.c:  if(wait() != -1){
forktest.d:forktest.o: forktest.c /usr/include/stdc-predef.h RMME.h types.h stat.h \
Binary file forktest.o matches
fs.c://   + Log: crash recovery for multi-step updates.
fs.c:// This file contains the low-level file system manipulation 
fs.c:// routines.  The (higher-level) system call implementations
fs.c:  memmove(sb, bp->data, sizeof(*sb));
fs.c:  memset(bp->data, 0, BSIZE);
fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
fs.c:  if((bp->data[bi/8] & m) == 0)
fs.c:  bp->data[bi/8] &= ~m;
fs.c:// The kernel keeps a cache of in-use inodes in memory
fs.c:// inodes include book-keeping information that is
fs.c:// not stored on disk: ip->ref and ip->flags.
fs.c:// An inode and its in-memory represtative go through a
fs.c://   is non-zero. ialloc() allocates, iput() frees if
fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
fs.c://   the number of in-memory pointers to the entry (open
fs.c://   is set in ip->flags. ilock() reads the inode from
fs.c://   I_VALID if ip->ref has fallen to zero.
fs.c://   ... examine and modify ip->xxx ...
fs.c:// get a long-term reference to an inode (as for an open file)
fs.c:// pathname lookup. iget() increments ip->ref so that the inode
fs.c:// multi-step atomic operations.
fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
fs.c:    if(dip->type == 0){  // a free inode
fs.c:      dip->type = type;
fs.c:// Copy a modified in-memory inode to disk.
fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
fs.c:  dip->type = ip->type;
fs.c:  dip->major = ip->major;
fs.c:  dip->minor = ip->minor;
fs.c:  dip->nlink = ip->nlink;
fs.c:  dip->size = ip->size;
fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
fs.c:// and return the in-memory copy. Does not lock
fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
fs.c:      ip->ref++;
fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
fs.c:  ip->dev = dev;
fs.c:  ip->inum = inum;
fs.c:  ip->ref = 1;
fs.c:  ip->flags = 0;
fs.c:  ip->ref++;
fs.c:  if(ip == 0 || ip->ref < 1)
fs.c:  while(ip->flags & I_BUSY)
fs.c:  ip->flags |= I_BUSY;
fs.c:  if(!(ip->flags & I_VALID)){
fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
fs.c:    ip->type = dip->type;
fs.c:    ip->major = dip->major;
fs.c:    ip->minor = dip->minor;
fs.c:    ip->nlink = dip->nlink;
fs.c:    ip->size = dip->size;
fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
fs.c:    ip->flags |= I_VALID;
fs.c:    if(ip->type == 0)
fs.c:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
fs.c:  ip->flags &= ~I_BUSY;
fs.c:// Drop a reference to an in-memory inode.
fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
fs.c:    if(ip->flags & I_BUSY)
fs.c:    ip->flags |= I_BUSY;
fs.c:    ip->type = 0;
fs.c:    ip->flags = 0;
fs.c:  ip->ref--;
fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are 
fs.c:// listed in block ip->addrs[NDIRECT].
fs.c:    if((addr = ip->addrs[bn]) == 0)
fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
fs.c:  bn -= NDIRECT;
fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
fs.c:    bp = bread(ip->dev, addr);
fs.c:    a = (uint*)bp->data;
fs.c:      a[bn] = addr = balloc(ip->dev);
fs.c:// and has no in-memory reference to it (is
fs.c:    if(ip->addrs[i]){
fs.c:      bfree(ip->dev, ip->addrs[i]);
fs.c:      ip->addrs[i] = 0;
fs.c:  if(ip->addrs[NDIRECT]){
fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
fs.c:    a = (uint*)bp->data;
fs.c:        bfree(ip->dev, a[j]);
fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
fs.c:    ip->addrs[NDIRECT] = 0;
fs.c:  ip->size = 0;
fs.c:  st->dev = ip->dev;
fs.c:  st->ino = ip->inum;
fs.c:  st->type = ip->type;
fs.c:  st->nlink = ip->nlink;
fs.c:  st->size = ip->size;
fs.c:  if(ip->type == T_DEV){
fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
fs.c:      return -1;
fs.c:    return devsw[ip->major].read(ip, dst, n);
fs.c:  if(off > ip->size || off + n < off)
fs.c:    return -1;
fs.c:  if(off + n > ip->size)
fs.c:    n = ip->size - off;
fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
fs.c:    m = min(n - tot, BSIZE - off%BSIZE);
fs.c:    memmove(dst, bp->data + off%BSIZE, m);
fs.c:  if(ip->type == T_DEV){
fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
fs.c:      return -1;
fs.c:    return devsw[ip->major].write(ip, src, n);
fs.c:  if(off > ip->size || off + n < off)
fs.c:    return -1;
fs.c:    return -1;
fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
fs.c:    m = min(n - tot, BSIZE - off%BSIZE);
fs.c:    memmove(bp->data + off%BSIZE, src, m);
fs.c:  if(n > 0 && off > ip->size){
fs.c:    ip->size = off;
fs.c:  if(dp->type != T_DIR)
fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
fs.c:      return iget(dp->dev, inum);
fs.c:    return -1;
fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
fs.c:  len = path - s;
fs.c:    ip = idup(proc->cwd);
fs.c:    if(ip->type != T_DIR){
fs.d:fs.o: fs.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
fs.h:// On-disk file system format. 
fs.h:#define ROOTINO 1  // root i-number
fs.h:// On-disk inode structure
Binary file fs.img matches
Binary file fs.o matches
gdbutil:# -*- gdb-script -*-
gdbutil:# Utility functions to pretty-print x86 segment/interrupt descriptors.
gdbutil:# IA32 2007, Volume 3A, Table 3-2
gdbutil:# IA32 2007, Volume 3A, Table 3-1
gdbutil:# xv6-specific
gdbutil:  # IA32 2007, Voume 3A, Figure 5-2
gdbutil:  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
gdbutil:        printf "16-bit (0)"
gdbutil:        printf "32-bit (1)"
Binary file _gp matches
gp.asm:_gp:     file format elf32-i386
gp.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
gp.asm:  16:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
gp.asm:  1d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
gp.asm:  24:	c7 45 d0 3c 00 00 00 	movl   $0x3c,-0x30(%ebp)
gp.asm:  5b:	89 45 d8             	mov    %eax,-0x28(%ebp)
gp.asm:  5e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
gp.asm:  64:	83 7d d8 48          	cmpl   $0x48,-0x28(%ebp)
gp.asm:  81:	8b 45 d8             	mov    -0x28(%ebp),%eax
gp.asm:  93:	89 45 cc             	mov    %eax,-0x34(%ebp)
gp.asm:  a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
gp.asm:  b6:	89 45 c8             	mov    %eax,-0x38(%ebp)
gp.asm:  b9:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
gp.asm:  d6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
gp.asm:  e1:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
gp.asm:  e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
gp.asm:  e8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
gp.asm:  ed:	8b 45 d8             	mov    -0x28(%ebp),%eax
gp.asm:  f3:	ff 75 cc             	pushl  -0x34(%ebp)
gp.asm:  ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
gp.asm: 102:	8b 45 d4             	mov    -0x2c(%ebp),%eax
gp.asm: 105:	3b 45 d8             	cmp    -0x28(%ebp),%eax
gp.asm: 125:	8b 45 cc             	mov    -0x34(%ebp),%eax
gp.asm: 128:	89 45 e4             	mov    %eax,-0x1c(%ebp)
gp.asm: 13d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
gp.asm: 149:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 14f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm: 152:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 158:	89 7d c0             	mov    %edi,-0x40(%ebp)
gp.asm: 15b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 184:	89 4d bc             	mov    %ecx,-0x44(%ebp)
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm: 187:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 197:	89 55 b8             	mov    %edx,-0x48(%ebp)
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm: 19a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 1b9:	89 7d b4             	mov    %edi,-0x4c(%ebp)
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm: 1bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm: 1eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm: 21a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 22c:	89 45 b0             	mov    %eax,-0x50(%ebp)
gp.asm: 22f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 235:	89 4d ac             	mov    %ecx,-0x54(%ebp)
gp.asm: 238:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 23e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm: 244:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 24a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 252:	ff 75 c4             	pushl  -0x3c(%ebp)
gp.asm: 255:	ff 75 c0             	pushl  -0x40(%ebp)
gp.asm: 258:	ff 75 bc             	pushl  -0x44(%ebp)
gp.asm: 25b:	ff 75 b8             	pushl  -0x48(%ebp)
gp.asm: 25e:	ff 75 b4             	pushl  -0x4c(%ebp)
gp.asm: 263:	ff 75 b0             	pushl  -0x50(%ebp)
gp.asm: 266:	ff 75 ac             	pushl  -0x54(%ebp)
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm: 27c:	83 45 e4 5c          	addl   $0x5c,-0x1c(%ebp)
gp.asm: 280:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
gp.asm: 284:	8b 45 dc             	mov    -0x24(%ebp),%eax
gp.asm: 287:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm: 2ad:	ff 75 cc             	pushl  -0x34(%ebp)
gp.asm: 2ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm: 30e:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm:  return (uchar)*p - (uchar)*q;
gp.asm: 358:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
gp.asm: 361:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
gp.asm: 365:	8b 55 fc             	mov    -0x4(%ebp),%edx
gp.asm: 374:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 39c:	88 45 fc             	mov    %al,-0x4(%ebp)
gp.asm: 3a7:	3a 45 fc             	cmp    -0x4(%ebp),%al
gp.asm: 3cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
gp.asm: 3da:	8d 45 ef             	lea    -0x11(%ebp),%eax
gp.asm: 3e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
gp.asm: 3eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
gp.asm: 3f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: 3f7:	89 55 f4             	mov    %edx,-0xc(%ebp)
gp.asm: 401:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
gp.asm: 407:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
gp.asm: 40f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
gp.asm: 417:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: 425:	8b 55 f4             	mov    -0xc(%ebp),%edx
gp.asm: 44b:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm: 44e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
gp.asm:    return -1;
gp.asm: 461:	ff 75 f4             	pushl  -0xc(%ebp)
gp.asm: 46c:	89 45 f0             	mov    %eax,-0x10(%ebp)
gp.asm: 472:	ff 75 f4             	pushl  -0xc(%ebp)
gp.asm: 47d:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm: 488:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
gp.asm:  sign = (*s == '-') ? -1 : 1;
gp.asm: 4b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
gp.asm:  if (*s == '+'  || *s == '-')
gp.asm:    n = n*10 + *s++ - '0';
gp.asm: 4d2:	8b 55 fc             	mov    -0x4(%ebp),%edx
gp.asm: 4f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm:  sign = (*s == '-') ? -1 : 1;
gp.asm:  if (*s == '+'  || *s == '-')
gp.asm:    n = n*10 + *s++ - '0';
gp.asm: 50b:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 50e:	0f af 45 fc          	imul   -0x4(%ebp),%eax
gp.asm: 51a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
gp.asm:  sign = (*s == '-') ? -1 : 1;
gp.asm: 547:	89 45 f8             	mov    %eax,-0x8(%ebp)
gp.asm:  if (*s == '+'  || *s == '-')
gp.asm:    n = n*8 + *s++ - '0';
gp.asm: 564:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 582:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm:  sign = (*s == '-') ? -1 : 1;
gp.asm:  if (*s == '+'  || *s == '-')
gp.asm:    n = n*8 + *s++ - '0';
gp.asm: 599:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 59c:	0f af 45 fc          	imul   -0x4(%ebp),%eax
gp.asm: 5ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm: 5b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
gp.asm:  while(n-- > 0)
gp.asm: 5b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 5bc:	89 55 fc             	mov    %edx,-0x4(%ebp)
gp.asm: 5bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
gp.asm: 5c5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
gp.asm:  while(n-- > 0)
gp.asm: 5d0:	8d 50 ff             	lea    -0x1(%eax),%edx
gp.asm:# Added calls - Evghenii
gp.asm: 6d0:	88 45 f4             	mov    %al,-0xc(%ebp)
gp.asm: 6d8:	8d 45 f4             	lea    -0xc(%ebp),%eax
gp.asm: 6f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
gp.asm: 704:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
gp.asm:    x = -xx;
gp.asm: 710:	89 45 ec             	mov    %eax,-0x14(%ebp)
gp.asm: 718:	89 45 ec             	mov    %eax,-0x14(%ebp)
gp.asm: 71b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
gp.asm: 722:	8b 4d f4             	mov    -0xc(%ebp),%ecx
gp.asm: 728:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm: 72e:	8b 45 ec             	mov    -0x14(%ebp),%eax
gp.asm: 741:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
gp.asm: 748:	8b 45 ec             	mov    -0x14(%ebp),%eax
gp.asm: 752:	89 45 ec             	mov    %eax,-0x14(%ebp)
gp.asm: 755:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
gp.asm: 75b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
gp.asm:    buf[i++] = '-';
gp.asm: 761:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: 767:	89 55 f4             	mov    %edx,-0xc(%ebp)
gp.asm: 76a:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
gp.asm:  while(--i >= 0)
gp.asm: 771:	8d 55 dc             	lea    -0x24(%ebp),%edx
gp.asm: 774:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm:    buf[i++] = '-';
gp.asm:  while(--i >= 0)
gp.asm: 78e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
gp.asm: 792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
gp.asm: 799:	8b 5d fc             	mov    -0x4(%ebp),%ebx
gp.asm: 7a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
gp.asm: 7b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
gp.asm: 7b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
gp.asm: 7c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm: 7d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
gp.asm: 7d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
gp.asm: 7dc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
gp.asm: 7e2:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
gp.asm: 7ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 808:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
gp.asm: 812:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
gp.asm: 818:	8b 45 e8             	mov    -0x18(%ebp),%eax
gp.asm: 82d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
gp.asm: 836:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
gp.asm: 83c:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
gp.asm: 842:	8b 45 e8             	mov    -0x18(%ebp),%eax
gp.asm: 857:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
gp.asm: 860:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
gp.asm: 866:	8b 45 e8             	mov    -0x18(%ebp),%eax
gp.asm: 86b:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm: 86e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
gp.asm: 872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
gp.asm: 878:	c7 45 f4 52 0c 00 00 	movl   $0xc52,-0xc(%ebp)
gp.asm: 881:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: 899:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
gp.asm: 89d:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: 8a9:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
gp.asm: 8af:	8b 45 e8             	mov    -0x18(%ebp),%eax
gp.asm: 8c6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
gp.asm: 8cc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
gp.asm: 8d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 8f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
gp.asm: 90e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
gp.asm: 915:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
gp.asm: 91c:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm:  bp = (Header*)ap - 1;
gp.asm: 93b:	89 45 f8             	mov    %eax,-0x8(%ebp)
gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
gp.asm: 943:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
gp.asm: 948:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 94d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
gp.asm: 952:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 955:	3b 45 fc             	cmp    -0x4(%ebp),%eax
gp.asm: 95a:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 95f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
gp.asm:  bp = (Header*)ap - 1;
gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
gp.asm: 964:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 969:	89 45 fc             	mov    %eax,-0x4(%ebp)
gp.asm: 96c:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 96f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
gp.asm: 974:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 979:	3b 45 f8             	cmp    -0x8(%ebp),%eax
gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
gp.asm:  if(bp + bp->s.size == p->s.ptr){
gp.asm: 97e:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 98b:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 990:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm:    bp->s.size += p->s.ptr->s.size;
gp.asm: 999:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 99f:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm:    bp->s.ptr = p->s.ptr->s.ptr;
gp.asm: 9af:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm:    bp->s.ptr = p->s.ptr;
gp.asm: 9bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm:  if(p + p->s.size == bp){
gp.asm: 9c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9d9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
gp.asm:    p->s.size += bp->s.size;
gp.asm: 9de:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: 9e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 9ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm:    p->s.ptr = bp->s.ptr;
gp.asm: 9f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
gp.asm: 9f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm:    p->s.ptr = bp;
gp.asm: 9fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: a01:	8b 55 f8             	mov    -0x8(%ebp),%edx
gp.asm: a06:	8b 45 fc             	mov    -0x4(%ebp),%eax
gp.asm: a39:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm:  if(p == (char*)-1)
gp.asm: a3c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
gp.asm: a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: a4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
gp.asm:  hp->s.size = nu;
gp.asm: a4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm: a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
gp.asm: a83:	89 45 ec             	mov    %eax,-0x14(%ebp)
gp.asm: a8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
gp.asm: a8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
gp.asm: a94:	c7 45 f0 e4 0e 00 00 	movl   $0xee4,-0x10(%ebp)
gp.asm: a9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
gp.asm: ab7:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm: abc:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm:    if(p->s.size >= nunits){
gp.asm: abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: ac5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
gp.asm:      if(p->s.size == nunits)
gp.asm: aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: ad0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
gp.asm:        prevp->s.ptr = p->s.ptr;
gp.asm: ad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: ada:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm:        p->s.size -= nunits;
gp.asm: ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: ae7:	2b 45 ec             	sub    -0x14(%ebp),%eax
gp.asm: aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm:        p += p->s.size;
gp.asm: af2:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: afb:	01 45 f4             	add    %eax,-0xc(%ebp)
gp.asm:        p->s.size = nunits;
gp.asm: afe:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: b01:	8b 55 ec             	mov    -0x14(%ebp),%edx
gp.asm: b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
gp.asm: b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: b1c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
gp.asm: b24:	ff 75 ec             	pushl  -0x14(%ebp)
gp.asm: b2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.asm: b32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
gp.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
gp.asm: b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: b42:	89 45 f0             	mov    %eax,-0x10(%ebp)
gp.asm: b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
gp.asm: b4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
gp.c:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.c:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.c:             (cp->elapsed_ticks) % 10,
gp.c:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.d:gp.o: gp.c /usr/include/stdc-predef.h RMME.h types.h user.h uproc.h
Binary file gp.o matches
Binary file _grep matches
grep.asm:_grep:     file format elf32-i386
grep.asm:   6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
grep.asm:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
grep.asm:  12:	8b 45 ec             	mov    -0x14(%ebp),%eax
grep.asm:  15:	01 45 f4             	add    %eax,-0xc(%ebp)
grep.asm:  18:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm:  23:	c7 45 f0 40 0f 00 00 	movl   $0xf40,-0x10(%ebp)
grep.asm:  2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm:  35:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm:  47:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm:        write(1, p, q+1 - p);
grep.asm:  4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm:  55:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:  60:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm:  6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm:  73:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
grep.asm:  7b:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm:  86:	89 45 e8             	mov    %eax,-0x18(%ebp)
grep.asm:  89:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
grep.asm:        write(1, p, q+1 - p);
grep.asm:  8f:	81 7d f0 40 0f 00 00 	cmpl   $0xf40,-0x10(%ebp)
grep.asm:  98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
grep.asm:  9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
grep.asm:      m -= p - buf;
grep.asm:  a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:  af:	29 45 f4             	sub    %eax,-0xc(%ebp)
grep.asm:  b5:	ff 75 f4             	pushl  -0xc(%ebp)
grep.asm:  b8:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
grep.asm:  c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm:  d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm:  ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm:  f1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
grep.asm:      m -= p - buf;
grep.asm: 105:	ff 71 fc             	pushl  -0x4(%ecx)
grep.asm: 134:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm: 141:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm: 151:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
grep.asm: 15a:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 179:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm: 17c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
grep.asm: 182:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 1ae:	ff 75 ec             	pushl  -0x14(%ebp)
grep.asm: 1b1:	ff 75 f0             	pushl  -0x10(%ebp)
grep.asm: 1bf:	ff 75 ec             	pushl  -0x14(%ebp)
grep.asm: 1ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
grep.asm: 1ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 365:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm: 387:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm:  return (uchar)*p - (uchar)*q;
grep.asm: 3d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
grep.asm: 3da:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
grep.asm: 3de:	8b 55 fc             	mov    -0x4(%ebp),%edx
grep.asm: 3ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 415:	88 45 fc             	mov    %al,-0x4(%ebp)
grep.asm: 420:	3a 45 fc             	cmp    -0x4(%ebp),%al
grep.asm: 445:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
grep.asm: 453:	8d 45 ef             	lea    -0x11(%ebp),%eax
grep.asm: 461:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm: 464:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
grep.asm: 46a:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 470:	89 55 f4             	mov    %edx,-0xc(%ebp)
grep.asm: 47a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
grep.asm: 480:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
grep.asm: 488:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
grep.asm: 490:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 49e:	8b 55 f4             	mov    -0xc(%ebp),%edx
grep.asm: 4c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm: 4c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
grep.asm:    return -1;
grep.asm: 4da:	ff 75 f4             	pushl  -0xc(%ebp)
grep.asm: 4e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm: 4eb:	ff 75 f4             	pushl  -0xc(%ebp)
grep.asm: 4f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm: 501:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
grep.asm:  sign = (*s == '-') ? -1 : 1;
grep.asm: 52e:	89 45 f8             	mov    %eax,-0x8(%ebp)
grep.asm:  if (*s == '+'  || *s == '-')
grep.asm:    n = n*10 + *s++ - '0';
grep.asm: 54b:	8b 55 fc             	mov    -0x4(%ebp),%edx
grep.asm: 56d:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm:  sign = (*s == '-') ? -1 : 1;
grep.asm:  if (*s == '+'  || *s == '-')
grep.asm:    n = n*10 + *s++ - '0';
grep.asm: 584:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: 587:	0f af 45 fc          	imul   -0x4(%ebp),%eax
grep.asm: 593:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
grep.asm:  sign = (*s == '-') ? -1 : 1;
grep.asm: 5c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
grep.asm:  if (*s == '+'  || *s == '-')
grep.asm:    n = n*8 + *s++ - '0';
grep.asm: 5dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 5fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm:  sign = (*s == '-') ? -1 : 1;
grep.asm:  if (*s == '+'  || *s == '-')
grep.asm:    n = n*8 + *s++ - '0';
grep.asm: 612:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: 615:	0f af 45 fc          	imul   -0x4(%ebp),%eax
grep.asm: 624:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm: 62a:	89 45 f8             	mov    %eax,-0x8(%ebp)
grep.asm:  while(n-- > 0)
grep.asm: 62f:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 635:	89 55 fc             	mov    %edx,-0x4(%ebp)
grep.asm: 638:	8b 55 f8             	mov    -0x8(%ebp),%edx
grep.asm: 63e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
grep.asm:  while(n-- > 0)
grep.asm: 649:	8d 50 ff             	lea    -0x1(%eax),%edx
grep.asm:# Added calls - Evghenii
grep.asm: 749:	88 45 f4             	mov    %al,-0xc(%ebp)
grep.asm: 751:	8d 45 f4             	lea    -0xc(%ebp),%eax
grep.asm: 76a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
grep.asm: 77d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
grep.asm:    x = -xx;
grep.asm: 789:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm: 791:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm: 794:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
grep.asm: 79b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
grep.asm: 7a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm: 7a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
grep.asm: 7ba:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
grep.asm: 7c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
grep.asm: 7cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm: 7ce:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
grep.asm: 7d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
grep.asm:    buf[i++] = '-';
grep.asm: 7da:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 7e0:	89 55 f4             	mov    %edx,-0xc(%ebp)
grep.asm: 7e3:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
grep.asm:  while(--i >= 0)
grep.asm: 7ea:	8d 55 dc             	lea    -0x24(%ebp),%edx
grep.asm: 7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm:    buf[i++] = '-';
grep.asm:  while(--i >= 0)
grep.asm: 807:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
grep.asm: 80b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
grep.asm: 812:	8b 5d fc             	mov    -0x4(%ebp),%ebx
grep.asm: 81d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
grep.asm: 82a:	89 45 e8             	mov    %eax,-0x18(%ebp)
grep.asm: 82d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
grep.asm: 83c:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm: 84c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
grep.asm: 84f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
grep.asm: 855:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
grep.asm: 85b:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
grep.asm: 867:	8b 45 e4             	mov    -0x1c(%ebp),%eax
grep.asm: 881:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
grep.asm: 88b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
grep.asm: 891:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm: 8a6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
grep.asm: 8af:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
grep.asm: 8b5:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
grep.asm: 8bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm: 8d0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
grep.asm: 8d9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
grep.asm: 8df:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm: 8e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm: 8e7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
grep.asm: 8eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
grep.asm: 8f1:	c7 45 f4 06 0c 00 00 	movl   $0xc06,-0xc(%ebp)
grep.asm: 8fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 912:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
grep.asm: 916:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: 922:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
grep.asm: 928:	8b 45 e8             	mov    -0x18(%ebp),%eax
grep.asm: 93f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
grep.asm: 945:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
grep.asm: 94b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
grep.asm: 972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
grep.asm: 987:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
grep.asm: 98e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
grep.asm: 995:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:  bp = (Header*)ap - 1;
grep.asm: 9b4:	89 45 f8             	mov    %eax,-0x8(%ebp)
grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
grep.asm: 9bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
grep.asm: 9c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 9c6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
grep.asm: 9cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: 9ce:	3b 45 fc             	cmp    -0x4(%ebp),%eax
grep.asm: 9d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 9d8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
grep.asm:  bp = (Header*)ap - 1;
grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
grep.asm: 9dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 9e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
grep.asm: 9e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: 9e8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
grep.asm: 9ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: 9f2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
grep.asm:  if(bp + bp->s.size == p->s.ptr){
grep.asm: 9f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: a04:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: a09:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm:    bp->s.size += p->s.ptr->s.size;
grep.asm: a12:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: a18:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a22:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
grep.asm: a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm:    bp->s.ptr = p->s.ptr;
grep.asm: a36:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm:  if(p + p->s.size == bp){
grep.asm: a40:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a52:	3b 45 f8             	cmp    -0x8(%ebp),%eax
grep.asm:    p->s.size += bp->s.size;
grep.asm: a57:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: a65:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm:    p->s.ptr = bp->s.ptr;
grep.asm: a6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
grep.asm: a70:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm:    p->s.ptr = bp;
grep.asm: a77:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: a7a:	8b 55 f8             	mov    -0x8(%ebp),%edx
grep.asm: a7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
grep.asm: ab2:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm:  if(p == (char*)-1)
grep.asm: ab5:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
grep.asm: ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: ac5:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm:  hp->s.size = nu;
grep.asm: ac8:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm: ad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
grep.asm: afc:	89 45 ec             	mov    %eax,-0x14(%ebp)
grep.asm: b04:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm: b07:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
grep.asm: b0d:	c7 45 f0 20 0f 00 00 	movl   $0xf20,-0x10(%ebp)
grep.asm: b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
grep.asm: b30:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm: b35:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm:    if(p->s.size >= nunits){
grep.asm: b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b3e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
grep.asm:      if(p->s.size == nunits)
grep.asm: b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
grep.asm:        prevp->s.ptr = p->s.ptr;
grep.asm: b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b53:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm:        p->s.size -= nunits;
grep.asm: b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b60:	2b 45 ec             	sub    -0x14(%ebp),%eax
grep.asm: b65:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm:        p += p->s.size;
grep.asm: b6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b74:	01 45 f4             	add    %eax,-0xc(%ebp)
grep.asm:        p->s.size = nunits;
grep.asm: b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
grep.asm: b80:	8b 45 f0             	mov    -0x10(%ebp),%eax
grep.asm: b88:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: b95:	39 45 f4             	cmp    %eax,-0xc(%ebp)
grep.asm: b9d:	ff 75 ec             	pushl  -0x14(%ebp)
grep.asm: ba8:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.asm: bab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
grep.asm: bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: bbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
grep.asm: bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
grep.asm: bc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
grep.c:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
grep.c:        write(1, p, q+1 - p);
grep.c:      m -= p - buf;
grep.d:grep.o: grep.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file grep.o matches
Binary file _halt matches
halt.asm:_halt:     file format elf32-i386
halt.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
halt.asm:  20:	8d 61 fc             	lea    -0x4(%ecx),%esp
halt.asm:  53:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm:  75:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm:  return (uchar)*p - (uchar)*q;
halt.asm:  bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
halt.asm:  c8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
halt.asm:  cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
halt.asm:  db:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 103:	88 45 fc             	mov    %al,-0x4(%ebp)
halt.asm: 10e:	3a 45 fc             	cmp    -0x4(%ebp),%al
halt.asm: 133:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
halt.asm: 141:	8d 45 ef             	lea    -0x11(%ebp),%eax
halt.asm: 14f:	89 45 f0             	mov    %eax,-0x10(%ebp)
halt.asm: 152:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
halt.asm: 158:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 15e:	89 55 f4             	mov    %edx,-0xc(%ebp)
halt.asm: 168:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
halt.asm: 16e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
halt.asm: 176:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
halt.asm: 17e:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 18c:	8b 55 f4             	mov    -0xc(%ebp),%edx
halt.asm: 1b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm: 1b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
halt.asm:    return -1;
halt.asm: 1c8:	ff 75 f4             	pushl  -0xc(%ebp)
halt.asm: 1d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
halt.asm: 1d9:	ff 75 f4             	pushl  -0xc(%ebp)
halt.asm: 1e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm: 1ef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
halt.asm:  sign = (*s == '-') ? -1 : 1;
halt.asm: 21c:	89 45 f8             	mov    %eax,-0x8(%ebp)
halt.asm:  if (*s == '+'  || *s == '-')
halt.asm:    n = n*10 + *s++ - '0';
halt.asm: 239:	8b 55 fc             	mov    -0x4(%ebp),%edx
halt.asm: 25b:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm:  sign = (*s == '-') ? -1 : 1;
halt.asm:  if (*s == '+'  || *s == '-')
halt.asm:    n = n*10 + *s++ - '0';
halt.asm: 272:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 275:	0f af 45 fc          	imul   -0x4(%ebp),%eax
halt.asm: 281:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
halt.asm:  sign = (*s == '-') ? -1 : 1;
halt.asm: 2ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
halt.asm:  if (*s == '+'  || *s == '-')
halt.asm:    n = n*8 + *s++ - '0';
halt.asm: 2cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 2e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm:  sign = (*s == '-') ? -1 : 1;
halt.asm:  if (*s == '+'  || *s == '-')
halt.asm:    n = n*8 + *s++ - '0';
halt.asm: 300:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 303:	0f af 45 fc          	imul   -0x4(%ebp),%eax
halt.asm: 312:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm: 318:	89 45 f8             	mov    %eax,-0x8(%ebp)
halt.asm:  while(n-- > 0)
halt.asm: 31d:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 323:	89 55 fc             	mov    %edx,-0x4(%ebp)
halt.asm: 326:	8b 55 f8             	mov    -0x8(%ebp),%edx
halt.asm: 32c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
halt.asm:  while(n-- > 0)
halt.asm: 337:	8d 50 ff             	lea    -0x1(%eax),%edx
halt.asm:# Added calls - Evghenii
halt.asm: 437:	88 45 f4             	mov    %al,-0xc(%ebp)
halt.asm: 43f:	8d 45 f4             	lea    -0xc(%ebp),%eax
halt.asm: 458:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
halt.asm: 46b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
halt.asm:    x = -xx;
halt.asm: 477:	89 45 ec             	mov    %eax,-0x14(%ebp)
halt.asm: 47f:	89 45 ec             	mov    %eax,-0x14(%ebp)
halt.asm: 482:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
halt.asm: 489:	8b 4d f4             	mov    -0xc(%ebp),%ecx
halt.asm: 48f:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm: 495:	8b 45 ec             	mov    -0x14(%ebp),%eax
halt.asm: 4a8:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
halt.asm: 4af:	8b 45 ec             	mov    -0x14(%ebp),%eax
halt.asm: 4b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
halt.asm: 4bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
halt.asm: 4c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
halt.asm:    buf[i++] = '-';
halt.asm: 4c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 4ce:	89 55 f4             	mov    %edx,-0xc(%ebp)
halt.asm: 4d1:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
halt.asm:  while(--i >= 0)
halt.asm: 4d8:	8d 55 dc             	lea    -0x24(%ebp),%edx
halt.asm: 4db:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm:    buf[i++] = '-';
halt.asm:  while(--i >= 0)
halt.asm: 4f5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
halt.asm: 4f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
halt.asm: 500:	8b 5d fc             	mov    -0x4(%ebp),%ebx
halt.asm: 50b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
halt.asm: 518:	89 45 e8             	mov    %eax,-0x18(%ebp)
halt.asm: 51b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
halt.asm: 52a:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm: 53a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
halt.asm: 53d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
halt.asm: 543:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
halt.asm: 549:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
halt.asm: 555:	8b 45 e4             	mov    -0x1c(%ebp),%eax
halt.asm: 56f:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
halt.asm: 579:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
halt.asm: 57f:	8b 45 e8             	mov    -0x18(%ebp),%eax
halt.asm: 594:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
halt.asm: 59d:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
halt.asm: 5a3:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
halt.asm: 5a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
halt.asm: 5be:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
halt.asm: 5c7:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
halt.asm: 5cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
halt.asm: 5d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm: 5d5:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
halt.asm: 5d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
halt.asm: 5df:	c7 45 f4 bb 08 00 00 	movl   $0x8bb,-0xc(%ebp)
halt.asm: 5e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 600:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
halt.asm: 604:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 610:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
halt.asm: 616:	8b 45 e8             	mov    -0x18(%ebp),%eax
halt.asm: 62d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
halt.asm: 633:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
halt.asm: 639:	8b 45 e4             	mov    -0x1c(%ebp),%eax
halt.asm: 660:	8b 45 e4             	mov    -0x1c(%ebp),%eax
halt.asm: 675:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
halt.asm: 67c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
halt.asm: 683:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm:  bp = (Header*)ap - 1;
halt.asm: 6a2:	89 45 f8             	mov    %eax,-0x8(%ebp)
halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
halt.asm: 6aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
halt.asm: 6af:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 6b4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
halt.asm: 6b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 6bc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
halt.asm: 6c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 6c6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
halt.asm:  bp = (Header*)ap - 1;
halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
halt.asm: 6cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 6d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
halt.asm: 6d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 6d6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
halt.asm: 6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 6e0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
halt.asm:  if(bp + bp->s.size == p->s.ptr){
halt.asm: 6e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 6f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 6f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm:    bp->s.size += p->s.ptr->s.size;
halt.asm: 700:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 706:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 710:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm:    bp->s.ptr = p->s.ptr->s.ptr;
halt.asm: 716:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 71d:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm:    bp->s.ptr = p->s.ptr;
halt.asm: 724:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 729:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm:  if(p + p->s.size == bp){
halt.asm: 72e:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 73b:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 740:	3b 45 f8             	cmp    -0x8(%ebp),%eax
halt.asm:    p->s.size += bp->s.size;
halt.asm: 745:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 74b:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 753:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm:    p->s.ptr = bp->s.ptr;
halt.asm: 759:	8b 45 f8             	mov    -0x8(%ebp),%eax
halt.asm: 75e:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm:    p->s.ptr = bp;
halt.asm: 765:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 768:	8b 55 f8             	mov    -0x8(%ebp),%edx
halt.asm: 76d:	8b 45 fc             	mov    -0x4(%ebp),%eax
halt.asm: 7a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm:  if(p == (char*)-1)
halt.asm: 7a3:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
halt.asm: 7b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 7b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
halt.asm:  hp->s.size = nu;
halt.asm: 7b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm: 7bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
halt.asm: 7ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
halt.asm: 7f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
halt.asm: 7f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
halt.asm: 7fb:	c7 45 f0 48 0b 00 00 	movl   $0xb48,-0x10(%ebp)
halt.asm: 802:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
halt.asm: 81e:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm: 823:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm:    if(p->s.size >= nunits){
halt.asm: 826:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 82c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
halt.asm:      if(p->s.size == nunits)
halt.asm: 831:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 837:	3b 45 ec             	cmp    -0x14(%ebp),%eax
halt.asm:        prevp->s.ptr = p->s.ptr;
halt.asm: 83c:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 841:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm:        p->s.size -= nunits;
halt.asm: 848:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 84e:	2b 45 ec             	sub    -0x14(%ebp),%eax
halt.asm: 853:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm:        p += p->s.size;
halt.asm: 859:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 862:	01 45 f4             	add    %eax,-0xc(%ebp)
halt.asm:        p->s.size = nunits;
halt.asm: 865:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 868:	8b 55 ec             	mov    -0x14(%ebp),%edx
halt.asm: 86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
halt.asm: 876:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 883:	39 45 f4             	cmp    %eax,-0xc(%ebp)
halt.asm: 88b:	ff 75 ec             	pushl  -0x14(%ebp)
halt.asm: 896:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.asm: 899:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
halt.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
halt.asm: 8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 8a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
halt.asm: 8ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
halt.asm: 8b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
halt.d:halt.o: halt.c /usr/include/stdc-predef.h RMME.h types.h user.h
Binary file halt.o matches
ide.c:// Simple PIO-based (non-DMA) IDE driver code.
ide.c:// idequeue->qnext points to the next buf to be processed.
ide.c:    return -1;
ide.c:  ioapicenable(IRQ_IDE, ncpu - 1);
ide.c:  if(b->blockno >= FSSIZE)
ide.c:  int sector = b->blockno * sector_per_block;
ide.c:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
ide.c:  if(b->flags & B_DIRTY){
ide.c:    outsl(0x1f0, b->data, BSIZE/4);
ide.c:  idequeue = b->qnext;
ide.c:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
ide.c:    insl(0x1f0, b->data, BSIZE/4);
ide.c:  b->flags |= B_VALID;
ide.c:  b->flags &= ~B_DIRTY;
ide.c:  if(!(b->flags & B_BUSY))
ide.c:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
ide.c:  if(b->dev != 0 && !havedisk1)
ide.c:  acquire(&idelock);  //DOC:acquire-lock
ide.c:  b->qnext = 0;
ide.c:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
ide.c:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
ide.d:ide.o: ide.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file ide.o matches
Binary file _init matches
init.asm:_init:     file format elf32-i386
init.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
init.asm:  7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm:  81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm:  9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm:  e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm:  ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
init.asm:  f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm:  f7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
init.asm: 130:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm: 152:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm:  return (uchar)*p - (uchar)*q;
init.asm: 19c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
init.asm: 1a5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
init.asm: 1a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
init.asm: 1b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 1e0:	88 45 fc             	mov    %al,-0x4(%ebp)
init.asm: 1eb:	3a 45 fc             	cmp    -0x4(%ebp),%al
init.asm: 210:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
init.asm: 21e:	8d 45 ef             	lea    -0x11(%ebp),%eax
init.asm: 22c:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm: 22f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
init.asm: 235:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 23b:	89 55 f4             	mov    %edx,-0xc(%ebp)
init.asm: 245:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
init.asm: 24b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
init.asm: 253:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
init.asm: 25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 269:	8b 55 f4             	mov    -0xc(%ebp),%edx
init.asm: 28f:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm: 292:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm:    return -1;
init.asm: 2a5:	ff 75 f4             	pushl  -0xc(%ebp)
init.asm: 2b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm: 2b6:	ff 75 f4             	pushl  -0xc(%ebp)
init.asm: 2c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm: 2cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
init.asm:  sign = (*s == '-') ? -1 : 1;
init.asm: 2f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
init.asm:  if (*s == '+'  || *s == '-')
init.asm:    n = n*10 + *s++ - '0';
init.asm: 316:	8b 55 fc             	mov    -0x4(%ebp),%edx
init.asm: 338:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm:  sign = (*s == '-') ? -1 : 1;
init.asm:  if (*s == '+'  || *s == '-')
init.asm:    n = n*10 + *s++ - '0';
init.asm: 34f:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 352:	0f af 45 fc          	imul   -0x4(%ebp),%eax
init.asm: 35e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
init.asm:  sign = (*s == '-') ? -1 : 1;
init.asm: 38b:	89 45 f8             	mov    %eax,-0x8(%ebp)
init.asm:  if (*s == '+'  || *s == '-')
init.asm:    n = n*8 + *s++ - '0';
init.asm: 3a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 3c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm:  sign = (*s == '-') ? -1 : 1;
init.asm:  if (*s == '+'  || *s == '-')
init.asm:    n = n*8 + *s++ - '0';
init.asm: 3dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 3e0:	0f af 45 fc          	imul   -0x4(%ebp),%eax
init.asm: 3ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm: 3f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
init.asm:  while(n-- > 0)
init.asm: 3fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 400:	89 55 fc             	mov    %edx,-0x4(%ebp)
init.asm: 403:	8b 55 f8             	mov    -0x8(%ebp),%edx
init.asm: 409:	89 4d f8             	mov    %ecx,-0x8(%ebp)
init.asm:  while(n-- > 0)
init.asm: 414:	8d 50 ff             	lea    -0x1(%eax),%edx
init.asm:# Added calls - Evghenii
init.asm: 514:	88 45 f4             	mov    %al,-0xc(%ebp)
init.asm: 51c:	8d 45 f4             	lea    -0xc(%ebp),%eax
init.asm: 535:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
init.asm: 548:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
init.asm:    x = -xx;
init.asm: 554:	89 45 ec             	mov    %eax,-0x14(%ebp)
init.asm: 55c:	89 45 ec             	mov    %eax,-0x14(%ebp)
init.asm: 55f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
init.asm: 566:	8b 4d f4             	mov    -0xc(%ebp),%ecx
init.asm: 56c:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm: 572:	8b 45 ec             	mov    -0x14(%ebp),%eax
init.asm: 585:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
init.asm: 58c:	8b 45 ec             	mov    -0x14(%ebp),%eax
init.asm: 596:	89 45 ec             	mov    %eax,-0x14(%ebp)
init.asm: 599:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
init.asm: 59f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
init.asm:    buf[i++] = '-';
init.asm: 5a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 5ab:	89 55 f4             	mov    %edx,-0xc(%ebp)
init.asm: 5ae:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
init.asm:  while(--i >= 0)
init.asm: 5b5:	8d 55 dc             	lea    -0x24(%ebp),%edx
init.asm: 5b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm:    buf[i++] = '-';
init.asm:  while(--i >= 0)
init.asm: 5d2:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
init.asm: 5d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm: 5dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
init.asm: 5e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
init.asm: 5f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
init.asm: 5f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
init.asm: 607:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm: 617:	89 45 e4             	mov    %eax,-0x1c(%ebp)
init.asm: 61a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
init.asm: 620:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
init.asm: 626:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
init.asm: 632:	8b 45 e4             	mov    -0x1c(%ebp),%eax
init.asm: 64c:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
init.asm: 656:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
init.asm: 65c:	8b 45 e8             	mov    -0x18(%ebp),%eax
init.asm: 671:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
init.asm: 67a:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
init.asm: 680:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
init.asm: 686:	8b 45 e8             	mov    -0x18(%ebp),%eax
init.asm: 69b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
init.asm: 6a4:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
init.asm: 6aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
init.asm: 6af:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm: 6b2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
init.asm: 6b6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm: 6bc:	c7 45 f4 e8 09 00 00 	movl   $0x9e8,-0xc(%ebp)
init.asm: 6c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 6dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
init.asm: 6e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 6ed:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
init.asm: 6f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
init.asm: 70a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
init.asm: 710:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
init.asm: 716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
init.asm: 73d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
init.asm: 752:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
init.asm: 759:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
init.asm: 760:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm:  bp = (Header*)ap - 1;
init.asm: 77f:	89 45 f8             	mov    %eax,-0x8(%ebp)
init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
init.asm: 787:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
init.asm: 78c:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 791:	3b 45 fc             	cmp    -0x4(%ebp),%eax
init.asm: 796:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 799:	3b 45 fc             	cmp    -0x4(%ebp),%eax
init.asm: 79e:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 7a3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
init.asm:  bp = (Header*)ap - 1;
init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
init.asm: 7a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 7ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
init.asm: 7b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 7b3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
init.asm: 7b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 7bd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
init.asm:  if(bp + bp->s.size == p->s.ptr){
init.asm: 7c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 7cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 7d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm:    bp->s.size += p->s.ptr->s.size;
init.asm: 7dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 7e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 7ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
init.asm: 7f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 7fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm:    bp->s.ptr = p->s.ptr;
init.asm: 801:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 806:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm:  if(p + p->s.size == bp){
init.asm: 80b:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 818:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 81d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
init.asm:    p->s.size += bp->s.size;
init.asm: 822:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 828:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 830:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm:    p->s.ptr = bp->s.ptr;
init.asm: 836:	8b 45 f8             	mov    -0x8(%ebp),%eax
init.asm: 83b:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm:    p->s.ptr = bp;
init.asm: 842:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 845:	8b 55 f8             	mov    -0x8(%ebp),%edx
init.asm: 84a:	8b 45 fc             	mov    -0x4(%ebp),%eax
init.asm: 87d:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm:  if(p == (char*)-1)
init.asm: 880:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
init.asm: 88d:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 890:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm:  hp->s.size = nu;
init.asm: 893:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm: 89c:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
init.asm: 8c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
init.asm: 8cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm: 8d2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
init.asm: 8d8:	c7 45 f0 74 0c 00 00 	movl   $0xc74,-0x10(%ebp)
init.asm: 8df:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
init.asm: 8fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm: 900:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm:    if(p->s.size >= nunits){
init.asm: 903:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 909:	3b 45 ec             	cmp    -0x14(%ebp),%eax
init.asm:      if(p->s.size == nunits)
init.asm: 90e:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 914:	3b 45 ec             	cmp    -0x14(%ebp),%eax
init.asm:        prevp->s.ptr = p->s.ptr;
init.asm: 919:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 91e:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm:        p->s.size -= nunits;
init.asm: 925:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 92b:	2b 45 ec             	sub    -0x14(%ebp),%eax
init.asm: 930:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm:        p += p->s.size;
init.asm: 936:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 93f:	01 45 f4             	add    %eax,-0xc(%ebp)
init.asm:        p->s.size = nunits;
init.asm: 942:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 945:	8b 55 ec             	mov    -0x14(%ebp),%edx
init.asm: 94b:	8b 45 f0             	mov    -0x10(%ebp),%eax
init.asm: 953:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 960:	39 45 f4             	cmp    %eax,-0xc(%ebp)
init.asm: 968:	ff 75 ec             	pushl  -0x14(%ebp)
init.asm: 973:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.asm: 976:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
init.asm: 983:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 986:	89 45 f0             	mov    %eax,-0x10(%ebp)
init.asm: 989:	8b 45 f4             	mov    -0xc(%ebp),%eax
init.asm: 98e:	89 45 f4             	mov    %eax,-0xc(%ebp)
init.c:// init: The initial user-level program
initcode.asm:initcode.o:     file format elf32-i386
init.d:init.o: init.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h \
Binary file init.o matches
ioapic.c:#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
ioapic.c:  ioapic->reg = reg;
ioapic.c:  return ioapic->data;
ioapic.c:  ioapic->reg = reg;
ioapic.c:  ioapic->data = data;
ioapic.c:  // Mark all interrupts edge-triggered, active high, disabled,
ioapic.c:  // Mark interrupt edge-triggered, active high,
ioapic.d:ioapic.o: ioapic.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file ioapic.o matches
kalloc.c:// and pipe buffers. Allocates 4096-byte pages.
kalloc.c:  r->next = kmem.freelist;
kalloc.c:// Allocate one 4096-byte page of physical memory.
kalloc.c:    kmem.freelist = r->next;
kalloc.d:kalloc.o: kalloc.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file kalloc.o matches
kbd.c:    return -1;
kbd.c:      c += 'A' - 'a';
kbd.c:      c += 'a' - 'A';
kbd.d:kbd.o: kbd.c /usr/include/stdc-predef.h RMME.h types.h x86.h defs.h kbd.h
kbd.h:// C('A') == Control-A
kbd.h:#define C(x) (x - '@')
kbd.h:  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
kbd.h:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
kbd.h:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
Binary file kbd.o matches
Binary file kernel matches
kernel.asm:kernel:     file format elf32-i386
kernel.asm:  # the assembler produces a PC-relative instruction
kernel.asm:80100063:	c7 45 f4 b4 d6 10 80 	movl   $0x8010d6b4,-0xc(%ebp)
kernel.asm:    b->next = bcache.head.next;
kernel.asm:80100072:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    b->prev = &bcache.head;
kernel.asm:80100078:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    b->dev = -1;
kernel.asm:80100082:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    bcache.head.next->prev = b;
kernel.asm:80100091:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80100097:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010009f:	81 45 f4 18 02 00 00 	addl   $0x218,-0xc(%ebp)
kernel.asm:801000ab:	39 45 f4             	cmp    %eax,-0xc(%ebp)
kernel.asm:    b->prev = &bcache.head;
kernel.asm:    b->dev = -1;
kernel.asm:    bcache.head.next->prev = b;
kernel.asm:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
kernel.asm:801000ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    if(b->dev == dev && b->blockno == blockno){
kernel.asm:801000d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801000de:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      if(!(b->flags & B_BUSY)){
kernel.asm:801000e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        b->flags |= B_BUSY;
kernel.asm:801000f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801000ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100114:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100124:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
kernel.asm:80100131:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100137:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010013a:	81 7d f4 84 15 11 80 	cmpl   $0x80111584,-0xc(%ebp)
kernel.asm:  // Not cached; recycle some non-busy and clean buffer.
kernel.asm:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
kernel.asm:80100148:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
kernel.asm:8010014d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100159:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      b->dev = dev;
kernel.asm:80100165:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      b->blockno = blockno;
kernel.asm:8010016e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      b->flags = B_BUSY;
kernel.asm:80100177:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100190:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  // Not cached; recycle some non-busy and clean buffer.
kernel.asm:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
kernel.asm:80100195:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010019b:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010019e:	81 7d f4 84 15 11 80 	cmpl   $0x80111584,-0xc(%ebp)
kernel.asm:      b->flags = B_BUSY;
kernel.asm:801001cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  if(!(b->flags & B_VALID)) {
kernel.asm:801001d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801001df:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801001ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  if((b->flags & B_BUSY) == 0)
kernel.asm:  b->flags |= B_DIRTY;
kernel.asm:  if((b->flags & B_BUSY) == 0)
kernel.asm:  b->next->prev = b->prev;
kernel.asm:  b->prev->next = b->next;
kernel.asm:  b->next = bcache.head.next;
kernel.asm:  b->prev = &bcache.head;
kernel.asm:  bcache.head.next->prev = b;
kernel.asm:  b->flags &= ~B_BUSY;
kernel.asm:801002dd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:801002e1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:801002e8:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:801002eb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:801002fd:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80100301:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80100304:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80100308:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:    x = -xx;
kernel.asm:8010033b:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100343:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100346:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:8010034d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
kernel.asm:80100353:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80100359:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80100365:	0f b6 80 04 a0 10 80 	movzbl -0x7fef5ffc(%eax),%eax
kernel.asm:8010036c:	88 44 0d e0          	mov    %al,-0x20(%ebp,%ecx,1)
kernel.asm:80100373:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010037d:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100380:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:    buf[i++] = '-';
kernel.asm:8010038c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100392:	89 55 f4             	mov    %edx,-0xc(%ebp)
kernel.asm:80100395:	c6 44 05 e0 2d       	movb   $0x2d,-0x20(%ebp,%eax,1)
kernel.asm:  while(--i >= 0)
kernel.asm:8010039c:	8d 55 e0             	lea    -0x20(%ebp),%edx
kernel.asm:8010039f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    buf[i++] = '-';
kernel.asm:  while(--i >= 0)
kernel.asm:801003b6:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
kernel.asm:801003ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:801003c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:801003d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:801003d4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:80100401:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100404:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80100410:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
kernel.asm:80100419:	ff 75 e4             	pushl  -0x1c(%ebp)
kernel.asm:8010042c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80100430:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100440:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80100443:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
kernel.asm:8010044d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:8010047c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80100482:	89 55 f0             	mov    %edx,-0x10(%ebp)
kernel.asm:8010049c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801004a2:	89 55 f0             	mov    %edx,-0x10(%ebp)
kernel.asm:801004b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801004bf:	89 55 f0             	mov    %edx,-0x10(%ebp)
kernel.asm:801004c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:801004c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:801004cd:	c7 45 ec 93 93 10 80 	movl   $0x80109393,-0x14(%ebp)
kernel.asm:801004d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801004eb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
kernel.asm:801004ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010051a:	ff 75 e4             	pushl  -0x1c(%ebp)
kernel.asm:80100526:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:8010052d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010053d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80100540:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
kernel.asm:8010054d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:  cprintf("cpu%d: panic: ", cpu->id);
kernel.asm:801005ba:	8d 45 cc             	lea    -0x34(%ebp),%eax
kernel.asm:801005ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:801005d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801005d6:	8b 44 85 cc          	mov    -0x34(%ebp,%eax,4),%eax
kernel.asm:  cprintf("cpu%d: panic: ", cpu->id);
kernel.asm:801005eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801005ef:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
kernel.asm:80100629:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010064b:	09 45 f4             	or     %eax,-0xc(%ebp)
kernel.asm:    pos += 80 - pos%80;
kernel.asm:80100654:	8b 4d f4             	mov    -0xc(%ebp),%ecx
kernel.asm:8010067f:	01 45 f4             	add    %eax,-0xc(%ebp)
kernel.asm:    if(pos > 0) --pos;
kernel.asm:8010068d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80100693:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
kernel.asm:8010069f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801006a5:	89 55 f4             	mov    %edx,-0xc(%ebp)
kernel.asm:801006b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:801006be:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
kernel.asm:801006d4:	81 7d f4 7f 07 00 00 	cmpl   $0x77f,-0xc(%ebp)
kernel.asm:    pos -= 80;
kernel.asm:801006ff:	83 6d f4 50          	subl   $0x50,-0xc(%ebp)
kernel.asm:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
kernel.asm:80100708:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:80100713:	8b 4d f4             	mov    -0xc(%ebp),%ecx
kernel.asm:8010073b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100767:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100783:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:#define C(x)  ((x)-'@')  // Control-x
kernel.asm:801007ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80100806:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kernel.asm:8010080d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:80100814:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
kernel.asm:8010081b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
kernel.asm:80100837:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80100883:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kernel.asm:8010088f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
kernel.asm:8010089b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
kernel.asm:801008a7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
kernel.asm:801008b3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
kernel.asm:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
kernel.asm:        input.e--;
kernel.asm:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
kernel.asm:801008fa:	0f b6 80 a0 17 11 80 	movzbl -0x7feee860(%eax),%eax
kernel.asm:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
kernel.asm:        input.e--;
kernel.asm:        input.e--;
kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
kernel.asm:8010093f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:8010095d:	83 7d e0 0d          	cmpl   $0xd,-0x20(%ebp)
kernel.asm:80100963:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:8010096d:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80100981:	8b 55 e0             	mov    -0x20(%ebp),%edx
kernel.asm:80100984:	88 90 a0 17 11 80    	mov    %dl,-0x7feee860(%eax)
kernel.asm:8010098d:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80100998:	83 7d e0 0a          	cmpl   $0xa,-0x20(%ebp)
kernel.asm:8010099e:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
kernel.asm:801009d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:801009d9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:801009f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:801009fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80100a09:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:80100a14:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:80100a1f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
kernel.asm:80100a44:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:      if(proc->killed){
kernel.asm:        return -1;
kernel.asm:        return -1;
kernel.asm:80100ac6:	0f b6 80 a0 17 11 80 	movzbl -0x7feee860(%eax),%eax
kernel.asm:80100ad0:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100ad3:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
kernel.asm:80100adc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:        // caller gets a 0-byte result.
kernel.asm:        input.r--;
kernel.asm:80100af9:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:    --n;
kernel.asm:80100b02:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
kernel.asm:        // caller gets a 0-byte result.
kernel.asm:        input.r--;
kernel.asm:    --n;
kernel.asm:  return target - n;
kernel.asm:80100b35:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80100b62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80100b6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80100b88:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80100b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100c2b:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:80100c2e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
kernel.asm:    return -1;
kernel.asm:80100c46:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:80100c51:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
kernel.asm:80100c5c:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
kernel.asm:80100c63:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:80100c77:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
kernel.asm:80100c8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
kernel.asm:80100c90:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
kernel.asm:80100c9a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
kernel.asm:80100ca1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:80100ca8:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
kernel.asm:80100cae:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80100cb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80100cbc:	8d 85 ec fe ff ff    	lea    -0x114(%ebp),%eax
kernel.asm:80100cc3:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:80100cd7:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
kernel.asm:80100ce2:	8b 95 00 ff ff ff    	mov    -0x100(%ebp),%edx
kernel.asm:80100ce8:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
kernel.asm:80100cf6:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
kernel.asm:80100cfc:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
kernel.asm:80100d08:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80100d0b:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100d16:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80100d19:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:80100d23:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
kernel.asm:80100d29:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
kernel.asm:80100d2f:	8b 8d f4 fe ff ff    	mov    -0x10c(%ebp),%ecx
kernel.asm:80100d3a:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:80100d3e:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100d54:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
kernel.asm:80100d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80100d5e:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80100d61:	0f b7 85 38 ff ff ff 	movzwl -0xc8(%ebp),%eax
kernel.asm:80100d6b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kernel.asm:80100d77:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:80100d87:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
kernel.asm:80100d8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80100d9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80100d9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80100daa:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80100dad:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100db8:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80100dbb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
kernel.asm:80100dc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80100dd1:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100ddc:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80100ddf:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:80100de2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
kernel.asm:80100dee:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
kernel.asm:80100df8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100e17:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:80100e22:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:80100e25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100e47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100e5a:	ff 75 dc             	pushl  -0x24(%ebp)
kernel.asm:80100e5d:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100e70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100e76:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:80100e79:	89 84 95 40 ff ff ff 	mov    %eax,-0xc0(%ebp,%edx,4)
kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
kernel.asm:80100e80:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
kernel.asm:80100e84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
kernel.asm:80100e9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100ea3:	c7 84 85 40 ff ff ff 	movl   $0x0,-0xc0(%ebp,%eax,4)
kernel.asm:80100eae:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
kernel.asm:80100eb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100ebb:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
kernel.asm:  ustack[2] = sp - (argc+1)*4;  // argv pointer
kernel.asm:80100ec1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100ece:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:80100ed3:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
kernel.asm:  sp -= (3+argc+1) * 4;
kernel.asm:80100ed9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100ee2:	29 45 dc             	sub    %eax,-0x24(%ebp)
kernel.asm:80100ee5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80100eef:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
kernel.asm:80100ef6:	ff 75 dc             	pushl  -0x24(%ebp)
kernel.asm:80100ef9:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80100f12:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100f15:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80100f1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80100f2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:  sp -= (3+argc+1) * 4;
kernel.asm:80100f2d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80100f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  safestrcpy(proc->name, last, sizeof(proc->name));
kernel.asm:80100f49:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  oldpgdir = proc->pgdir;
kernel.asm:80100f5e:	89 45 d0             	mov    %eax,-0x30(%ebp)
kernel.asm:  proc->pgdir = pgdir;
kernel.asm:80100f67:	8b 55 d4             	mov    -0x2c(%ebp),%edx
kernel.asm:  proc->sz = sz;
kernel.asm:80100f73:	8b 55 e0             	mov    -0x20(%ebp),%edx
kernel.asm:  proc->tf->eip = elf.entry;  // main
kernel.asm:80100f81:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
kernel.asm:  proc->tf->esp = sp;
kernel.asm:80100f93:	8b 55 dc             	mov    -0x24(%ebp),%edx
kernel.asm:80100fae:	ff 75 d0             	pushl  -0x30(%ebp)
kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
kernel.asm:  ustack[2] = sp - (argc+1)*4;  // argv pointer
kernel.asm:  sp -= (3+argc+1) * 4;
kernel.asm:80100fdf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
kernel.asm:80100fe8:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:80100ff3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
kernel.asm:80100ffc:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:  return -1;
kernel.asm:80101047:	c7 45 f4 74 18 11 80 	movl   $0x80111874,-0xc(%ebp)
kernel.asm:    if(f->ref == 0){
kernel.asm:80101050:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      f->ref = 1;
kernel.asm:8010105a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101074:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101079:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)
kernel.asm:80101082:	39 45 f4             	cmp    %eax,-0xc(%ebp)
kernel.asm:      f->ref = 1;
kernel.asm:  if(f->ref < 1)
kernel.asm:  f->ref++;
kernel.asm:  if(f->ref < 1)
kernel.asm:  if(--f->ref > 0){
kernel.asm:80101122:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:8010114f:	89 55 e0             	mov    %edx,-0x20(%ebp)
kernel.asm:80101155:	89 55 e4             	mov    %edx,-0x1c(%ebp)
kernel.asm:8010115b:	89 55 e8             	mov    %edx,-0x18(%ebp)
kernel.asm:80101161:	89 55 ec             	mov    %edx,-0x14(%ebp)
kernel.asm:80101167:	89 55 f0             	mov    %edx,-0x10(%ebp)
kernel.asm:8010116d:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  f->ref = 0;
kernel.asm:  f->type = FD_NONE;
kernel.asm:80101193:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:8010119b:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
kernel.asm:801011a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801011b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:801011c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  if(f->type == FD_INODE){
kernel.asm:    ilock(f->ip);
kernel.asm:    stati(f->ip, st);
kernel.asm:    iunlock(f->ip);
kernel.asm:  return -1;
kernel.asm:  if(f->readable == 0)
kernel.asm:    return -1;
kernel.asm:  if(f->type == FD_PIPE)
kernel.asm:    return piperead(f->pipe, addr, n);
kernel.asm:  if(f->type == FD_INODE){
kernel.asm:    ilock(f->ip);
kernel.asm:    if((r = readi(f->ip, addr, f->off, n)) > 0)
kernel.asm:801012a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801012a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      f->off += r;
kernel.asm:801012b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    iunlock(f->ip);
kernel.asm:801012d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  if(f->writable == 0)
kernel.asm:    return -1;
kernel.asm:  if(f->type == FD_PIPE)
kernel.asm:    return pipewrite(f->pipe, addr, n);
kernel.asm:  if(f->type == FD_INODE){
kernel.asm:    // i-node, indirect block, allocation blocks,
kernel.asm:    // and 2 blocks of slop for non-aligned writes.
kernel.asm:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
kernel.asm:80101337:	c7 45 ec 00 1a 00 00 	movl   $0x1a00,-0x14(%ebp)
kernel.asm:8010133e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:      int n1 = n - i;
kernel.asm:8010134d:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:80101350:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80101353:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101356:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kernel.asm:8010135b:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010135e:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:      ilock(f->ip);
kernel.asm:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
kernel.asm:80101378:	8b 4d f0             	mov    -0x10(%ebp),%ecx
kernel.asm:80101381:	8b 5d f4             	mov    -0xc(%ebp),%ebx
kernel.asm:8010139b:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:8010139e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:        f->off += r;
kernel.asm:801013aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:      iunlock(f->ip);
kernel.asm:801013cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:801013d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:801013d5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:801013e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:801013ea:	01 45 f4             	add    %eax,-0xc(%ebp)
kernel.asm:    // and 2 blocks of slop for non-aligned writes.
kernel.asm:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
kernel.asm:801013ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        f->off += r;
kernel.asm:      iunlock(f->ip);
kernel.asm:    return i == n ? n : -1;
kernel.asm:801013fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010141d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:80101439:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
kernel.asm:8010143c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101456:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:8010147d:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  memset(bp->data, 0, BSIZE);
kernel.asm:80101480:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010149c:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801014aa:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801014be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:801014c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:801014d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801014fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:801014fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kernel.asm:80101509:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101522:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
kernel.asm:80101525:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101535:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80101540:	23 45 e8             	and    -0x18(%ebp),%eax
kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
kernel.asm:80101547:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101555:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:8010155f:	8b 55 e8             	mov    -0x18(%ebp),%edx
kernel.asm:80101566:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:80101570:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:8010157e:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:80101589:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:8010158c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801015a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801015a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801015ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
kernel.asm:801015af:	81 7d f0 ff 0f 00 00 	cmpl   $0xfff,-0x10(%ebp)
kernel.asm:801015b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801015bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801015d2:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801015dd:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:801015ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010163c:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101647:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010164a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101663:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:  if((bp->data[bi/8] & m) == 0)
kernel.asm:80101666:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101676:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101681:	23 45 ec             	and    -0x14(%ebp),%eax
kernel.asm:  bp->data[bi/8] &= ~m;
kernel.asm:80101695:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801016a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801016ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:801016b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801016c0:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801016ce:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80101712:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80101738:	ff 75 e4             	pushl  -0x1c(%ebp)
kernel.asm:8010174f:	8d 65 f4             	lea    -0xc(%ebp),%esp
kernel.asm:80101760:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
kernel.asm:80101764:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kernel.asm:80101770:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010178e:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
kernel.asm:80101791:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101797:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801017a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    if(dip->type == 0){  // a free inode
kernel.asm:801017a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801017b7:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:      dip->type = type;
kernel.asm:801017c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801017c5:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
kernel.asm:801017cf:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801017dd:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801017e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801017ff:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:8010180a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80101814:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:// Copy a modified in-memory inode to disk.
kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel.asm:80101858:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel.asm:8010185b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010186f:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:  dip->type = ip->type;
kernel.asm:80101879:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  dip->major = ip->major;
kernel.asm:80101886:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  dip->minor = ip->minor;
kernel.asm:80101894:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  dip->nlink = ip->nlink;
kernel.asm:801018a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  dip->size = ip->size;
kernel.asm:801018af:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel.asm:801018bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801018d3:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801018e1:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:// and return the in-memory copy. Does not lock
kernel.asm:80101905:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kernel.asm:8010190c:	c7 45 f4 94 22 11 80 	movl   $0x80112294,-0xc(%ebp)
kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel.asm:80101915:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010191f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101929:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      ip->ref++;
kernel.asm:80101934:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010193d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101953:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel.asm:80101958:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:8010195e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101968:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010196b:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010196e:	83 45 f4 50          	addl   $0x50,-0xc(%ebp)
kernel.asm:80101972:	81 7d f4 34 32 11 80 	cmpl   $0x80113234,-0xc(%ebp)
kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel.asm:8010197b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:8010198e:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101991:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  ip->dev = dev;
kernel.asm:80101994:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  ip->inum = inum;
kernel.asm:8010199c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  ip->ref = 1;
kernel.asm:801019a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  ip->flags = 0;
kernel.asm:801019af:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801019c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  ip->ref++;
kernel.asm:  if(ip == 0 || ip->ref < 1)
kernel.asm:  while(ip->flags & I_BUSY)
kernel.asm:  if(ip == 0 || ip->ref < 1)
kernel.asm:  while(ip->flags & I_BUSY)
kernel.asm:  ip->flags |= I_BUSY;
kernel.asm:  if(!(ip->flags & I_VALID)){
kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel.asm:80101ab3:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel.asm:80101ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101aca:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    ip->type = dip->type;
kernel.asm:80101acd:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    ip->major = dip->major;
kernel.asm:80101ada:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    ip->minor = dip->minor;
kernel.asm:80101ae8:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    ip->nlink = dip->nlink;
kernel.asm:80101af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    ip->size = dip->size;
kernel.asm:80101b04:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel.asm:80101b10:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101b2e:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    ip->flags |= I_VALID;
kernel.asm:    if(ip->type == 0)
kernel.asm:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
kernel.asm:  ip->flags &= ~I_BUSY;
kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
kernel.asm:    if(ip->flags & I_BUSY)
kernel.asm:    ip->flags |= I_BUSY;
kernel.asm:    ip->type = 0;
kernel.asm:    ip->flags = 0;
kernel.asm:  ip->ref--;
kernel.asm:80101cac:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:    if((addr = ip->addrs[bn]) == 0)
kernel.asm:80101d07:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101d0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel.asm:80101d21:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101d2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80101d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  bn -= NDIRECT;
kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel.asm:80101d50:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101d53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel.asm:80101d6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101d70:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:    bp = bread(ip->dev, addr);
kernel.asm:80101d7e:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80101d8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    a = (uint*)bp->data;
kernel.asm:80101d8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101d93:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80101da0:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80101da7:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101daa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      a[bn] = addr = balloc(ip->dev);
kernel.asm:80101dba:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80101dd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80101dd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101ddc:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80101dea:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80101df5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80101e07:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:// and has no in-memory reference to it (is
kernel.asm:80101e12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    if(ip->addrs[i]){
kernel.asm:80101e1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:      bfree(ip->dev, ip->addrs[i]);
kernel.asm:80101e2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:      ip->addrs[i] = 0;
kernel.asm:80101e4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80101e5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80101e60:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
kernel.asm:      bfree(ip->dev, ip->addrs[i]);
kernel.asm:      ip->addrs[i] = 0;
kernel.asm:  if(ip->addrs[NDIRECT]){
kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:80101e8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    a = (uint*)bp->data;
kernel.asm:80101e8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80101e95:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80101e98:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kernel.asm:80101ea1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101eab:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:        bfree(ip->dev, a[j]);
kernel.asm:80101eb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80101ec0:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:  if(ip->addrs[NDIRECT]){
kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:    a = (uint*)bp->data;
kernel.asm:80101ed9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
kernel.asm:80101edd:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:        bfree(ip->dev, a[j]);
kernel.asm:80101ee8:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:    ip->addrs[NDIRECT] = 0;
kernel.asm:  ip->size = 0;
kernel.asm:  st->dev = ip->dev;
kernel.asm:  st->ino = ip->inum;
kernel.asm:  st->type = ip->type;
kernel.asm:  st->nlink = ip->nlink;
kernel.asm:  st->size = ip->size;
kernel.asm:  if(ip->type == T_DEV){
kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
kernel.asm:80101faa:	8b 04 c5 e0 21 11 80 	mov    -0x7feede20(,%eax,8),%eax
kernel.asm:      return -1;
kernel.asm:    return devsw[ip->major].read(ip, dst, n);
kernel.asm:80101fc7:	8b 04 c5 e0 21 11 80 	mov    -0x7feede20(,%eax,8),%eax
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    return -1;
kernel.asm:  if(off + n > ip->size)
kernel.asm:    n = ip->size - off;
kernel.asm:80102025:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:8010205a:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
kernel.asm:8010206f:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:80102077:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
kernel.asm:8010207a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010208d:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:8010209f:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    return -1;
kernel.asm:  if(off + n > ip->size)
kernel.asm:    n = ip->size - off;
kernel.asm:801020aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801020ad:	01 45 f4             	add    %eax,-0xc(%ebp)
kernel.asm:801020b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801020b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801020bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
kernel.asm:  if(ip->type == T_DEV){
kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
kernel.asm:80102101:	8b 04 c5 e4 21 11 80 	mov    -0x7feede1c(,%eax,8),%eax
kernel.asm:      return -1;
kernel.asm:    return devsw[ip->major].write(ip, src, n);
kernel.asm:8010211e:	8b 04 c5 e4 21 11 80 	mov    -0x7feede1c(,%eax,8),%eax
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    return -1;
kernel.asm:    return -1;
kernel.asm:80102177:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:801021ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
kernel.asm:801021c1:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:801021c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
kernel.asm:801021cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801021df:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801021f1:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801021ff:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    return -1;
kernel.asm:    return -1;
kernel.asm:8010220a:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010220d:	01 45 f4             	add    %eax,-0xc(%ebp)
kernel.asm:80102210:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80102216:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010221c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
kernel.asm:  if(n > 0 && off > ip->size){
kernel.asm:    ip->size = off;
kernel.asm:  if(dp->type != T_DIR)
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:80102290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:8010229b:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:8010229e:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:801022bf:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
kernel.asm:801022cb:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:801022ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801022ef:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
kernel.asm:801022f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:      return iget(dp->dev, inum);
kernel.asm:80102301:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:  if(dp->type != T_DIR)
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:80102310:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
kernel.asm:8010231a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:      return iget(dp->dev, inum);
kernel.asm:80102343:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80102346:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:8010234f:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:    return -1;
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:80102364:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:8010236d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102373:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:80102394:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:8010239d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801023a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801023ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801023be:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:801023d0:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
kernel.asm:801023d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801023da:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:8010242c:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  len = path - s;
kernel.asm:8010244c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102453:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80102456:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
kernel.asm:80102461:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102471:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80102478:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102486:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:801024c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    ip = idup(proc->cwd);
kernel.asm:801024e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801024ed:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    if(ip->type != T_DIR){
kernel.asm:801024f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102508:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102530:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:8010253b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010254b:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102556:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80102559:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80102562:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102577:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102582:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80102585:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    ip = idup(proc->cwd);
kernel.asm:801025af:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801025c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801025cf:	8d 45 ea             	lea    -0x16(%ebp),%eax
kernel.asm:80102606:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:8010260a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:80102611:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:80102614:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:8010264c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80102650:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80102653:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80102657:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:8010269c:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:8010269f:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:801026b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  ioapicenable(IRQ_IDE, ncpu - 1);
kernel.asm:8010272a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:  ioapicenable(IRQ_IDE, ncpu - 1);
kernel.asm:80102753:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80102757:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
kernel.asm:  if(b->blockno >= FSSIZE)
kernel.asm:801027ab:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kernel.asm:  int sector = b->blockno * sector_per_block;
kernel.asm:801027b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801027be:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:801027c1:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
kernel.asm:801027f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010280a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80102821:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010283b:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
kernel.asm:80102863:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  if(b->flags & B_DIRTY){
kernel.asm:    outsl(0x1f0, b->data, BSIZE/4);
kernel.asm:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
kernel.asm:  if(b->flags & B_DIRTY){
kernel.asm:    outsl(0x1f0, b->data, BSIZE/4);
kernel.asm:801028f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801028f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:  idequeue = b->qnext;
kernel.asm:8010290f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
kernel.asm:8010291a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    insl(0x1f0, b->data, BSIZE/4);
kernel.asm:80102937:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  b->flags |= B_VALID;
kernel.asm:80102953:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010295d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  b->flags &= ~B_DIRTY;
kernel.asm:80102962:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010296c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102974:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  if(!(b->flags & B_BUSY))
kernel.asm:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
kernel.asm:  if(b->dev != 0 && !havedisk1)
kernel.asm:  acquire(&idelock);  //DOC:acquire-lock
kernel.asm:  b->qnext = 0;
kernel.asm:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
kernel.asm:80102a1e:	c7 45 f4 54 c6 10 80 	movl   $0x8010c654,-0xc(%ebp)
kernel.asm:80102a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102a2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80102a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
kernel.asm:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
kernel.asm:  ioapic->reg = reg;
kernel.asm:  return ioapic->data;
kernel.asm:  ioapic->reg = reg;
kernel.asm:  ioapic->data = data;
kernel.asm:80102af1:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80102b01:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80102b0e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
kernel.asm:80102b23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80102b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
kernel.asm:80102b67:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80102b6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102b6e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:  // Mark interrupt edge-triggered, active high,
kernel.asm:  // Mark interrupt edge-triggered, active high,
kernel.asm:static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
kernel.asm:80102c3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80102c45:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80102c50:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:80102c57:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102cd2:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  r->next = kmem.freelist;
kernel.asm:80102cdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102ce0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:// Allocate one 4096-byte page of physical memory.
kernel.asm:80102d28:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80102d2b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    kmem.freelist = r->next;
kernel.asm:80102d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80102d62:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:80102d66:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:80102d6d:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:80102d70:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:80102d89:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80102d8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80102dad:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80102db0:	81 7d fc e0 00 00 00 	cmpl   $0xe0,-0x4(%ebp)
kernel.asm:80102dd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102de8:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102df0:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102df3:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80102df6:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102e2d:	81 4d fc 80 00 00 00 	orl    $0x80,-0x4(%ebp)
kernel.asm:80102e41:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102e5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102e7d:	8b 14 85 20 a5 10 80 	mov    -0x7fef5ae0(,%eax,4),%edx
kernel.asm:80102e84:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80102e8f:	89 45 f8             	mov    %eax,-0x8(%ebp)
kernel.asm:80102e9e:	83 7d f8 60          	cmpl   $0x60,-0x8(%ebp)
kernel.asm:80102ea4:	83 7d f8 7a          	cmpl   $0x7a,-0x8(%ebp)
kernel.asm:      c += 'A' - 'a';
kernel.asm:80102eaa:	83 6d f8 20          	subl   $0x20,-0x8(%ebp)
kernel.asm:80102eb0:	83 7d f8 40          	cmpl   $0x40,-0x8(%ebp)
kernel.asm:80102eb6:	83 7d f8 5a          	cmpl   $0x5a,-0x8(%ebp)
kernel.asm:      c += 'a' - 'A';
kernel.asm:80102ebc:	83 45 f8 20          	addl   $0x20,-0x8(%ebp)
kernel.asm:80102ec0:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80102ee7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:80102eeb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:80102ef2:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:80102ef5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:80102f07:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80102f0b:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80102f0e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80102f12:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:80102f22:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80102f25:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  // Clear error status register (requires back-to-back writes).
kernel.asm:  // Send an Init Level De-Assert to synchronise arbitration ID's.
kernel.asm:801030ed:	88 45 ec             	mov    %al,-0x14(%ebp)
kernel.asm:80103108:	c7 45 f8 67 04 00 80 	movl   $0x80000467,-0x8(%ebp)
kernel.asm:8010310f:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80103117:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:  // Send INIT (level-triggered) interrupt to reset other CPU.
kernel.asm:80103126:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
kernel.asm:80103176:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kernel.asm:8010317f:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
kernel.asm:801031b8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:801031bc:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)
kernel.asm:  r->second = cmos_read(SECS);
kernel.asm:  r->minute = cmos_read(MINS);
kernel.asm:  r->hour   = cmos_read(HOURS);
kernel.asm:  r->day    = cmos_read(DAY);
kernel.asm:  r->month  = cmos_read(MONTH);
kernel.asm:  r->year   = cmos_read(YEAR);
kernel.asm:// qemu seems to use 24-hour GWT and the values are BCD encoded
kernel.asm:80103276:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80103279:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103287:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010328a:	8d 45 d8             	lea    -0x28(%ebp),%eax
kernel.asm:801032a9:	8d 45 c0             	lea    -0x40(%ebp),%eax
kernel.asm:801032ba:	8d 45 c0             	lea    -0x40(%ebp),%eax
kernel.asm:801032be:	8d 45 d8             	lea    -0x28(%ebp),%eax
kernel.asm:801032d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:801032de:	8b 45 d8             	mov    -0x28(%ebp),%eax
kernel.asm:801032f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
kernel.asm:801032f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:801032fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:8010330f:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:80103317:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:8010331a:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:8010332d:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80103335:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80103338:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:8010334b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80103353:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80103356:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80103369:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80103371:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80103374:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103387:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010338f:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80103395:	8b 55 d8             	mov    -0x28(%ebp),%edx
kernel.asm:8010339a:	8b 55 dc             	mov    -0x24(%ebp),%edx
kernel.asm:801033a0:	8b 55 e0             	mov    -0x20(%ebp),%edx
kernel.asm:801033a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
kernel.asm:801033ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
kernel.asm:801033b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:  r->year += 2000;
kernel.asm:801033eb:	8d 45 dc             	lea    -0x24(%ebp),%eax
kernel.asm:801033fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103402:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80103420:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80103432:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010344e:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103451:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103457:	8b 04 85 8c 32 11 80 	mov    -0x7feecd74(,%eax,4),%eax
kernel.asm:80103472:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
kernel.asm:80103475:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010347b:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103496:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801034a4:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801034b2:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801034bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801034c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
kernel.asm:// Read the log header from disk into the in-memory log header
kernel.asm:801034f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
kernel.asm:801034f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801034fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:  log.lh.n = lh->n;
kernel.asm:801034fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103507:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    log.lh.block[i] = lh->block[i];
kernel.asm:80103510:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103513:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:8010351a:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80103520:	89 04 95 8c 32 11 80 	mov    %eax,-0x7feecd74(,%edx,4)
kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
kernel.asm:  log.lh.n = lh->n;
kernel.asm:80103527:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80103530:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    log.lh.block[i] = lh->block[i];
kernel.asm:80103538:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:// Write in-memory log header to disk.
kernel.asm:80103565:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:  struct logheader *hb = (struct logheader *) (buf->data);
kernel.asm:80103568:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010356e:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:  hb->n = log.lh.n;
kernel.asm:80103577:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010357c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    hb->block[i] = log.lh.block[i];
kernel.asm:80103585:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010358b:	8b 0c 85 8c 32 11 80 	mov    -0x7feecd74(,%eax,4),%ecx
kernel.asm:80103592:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103595:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  struct logheader *hb = (struct logheader *) (buf->data);
kernel.asm:  hb->n = log.lh.n;
kernel.asm:8010359c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801035a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    hb->block[i] = log.lh.block[i];
kernel.asm:801035ad:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801035bb:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:8010367d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:  log.outstanding -= 1;
kernel.asm:801036c0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kernel.asm:801036f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80103741:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80103753:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010376f:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103772:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103778:	8b 04 85 8c 32 11 80 	mov    -0x7feecd74(,%eax,4),%eax
kernel.asm:80103793:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    memmove(to->data, from->data, BSIZE);
kernel.asm:80103796:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:8010379c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801037b7:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801037c5:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801037d3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801037de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801037e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    memmove(to->data, from->data, BSIZE);
kernel.asm:    write_head();    // Write header to disk -- the real commit
kernel.asm://   modify bp->data[]
kernel.asm:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
kernel.asm:80103878:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
kernel.asm:80103881:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103887:	8b 04 85 8c 32 11 80 	mov    -0x7feecd74(,%eax,4),%eax
kernel.asm:8010389a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801038a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
kernel.asm:  log.lh.block[i] = b->blockno;
kernel.asm:801038b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801038b9:	89 14 85 8c 32 11 80 	mov    %edx,-0x7feecd74(,%eax,4)
kernel.asm:801038c5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:  b->flags |= B_DIRTY; // prevent eviction
kernel.asm:  // The + in "+m" denotes a read-modify-write operand.
kernel.asm:80103925:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80103928:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80103934:	ff 71 fc             	pushl  -0x4(%ecx)
kernel.asm:  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
kernel.asm:  cprintf("cpu%d: starting\n", cpu->id);
kernel.asm:  xchg(&cpu->started, 1); // tell startothers() we're up
kernel.asm:// Start the non-boot (AP) processors.
kernel.asm:80103a57:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103a68:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80103a73:	c7 45 f4 80 33 11 80 	movl   $0x80113380,-0xc(%ebp)
kernel.asm:80103a8f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:80103a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:    *(void**)(code-4) = stack + KSTACKSIZE;
kernel.asm:80103a9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103aa2:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:    *(void**)(code-8) = mpenter;
kernel.asm:80103aad:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    *(int**)(code-12) = (void *) v2p(entrypgdir);
kernel.asm:80103ab9:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103abc:	8d 58 f4             	lea    -0xc(%eax),%ebx
kernel.asm:    lapicstartap(c->id, v2p(code));
kernel.asm:80103ad4:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80103ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    while(c->started == 0)
kernel.asm:80103af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103b08:	81 45 f4 bc 00 00 00 	addl   $0xbc,-0xc(%ebp)
kernel.asm:80103b1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
kernel.asm:    while(c->started == 0)
kernel.asm:80103b29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:80103b44:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:80103b48:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:80103b4f:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:80103b52:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:80103b64:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80103b68:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80103b6b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80103b6f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:  return bcpu-cpus;
kernel.asm:80103b9b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
kernel.asm:80103ba2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kernel.asm:80103bab:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:80103bb9:	01 45 f8             	add    %eax,-0x8(%ebp)
kernel.asm:80103bbc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:80103bc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80103bc8:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80103bde:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103be4:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103be9:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80103bec:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103bef:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80103bfe:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80103c12:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80103c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103c26:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
kernel.asm:80103c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103c2d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kernel.asm:80103c3f:	c7 45 f4 00 04 00 80 	movl   $0x80000400,-0xc(%ebp)
kernel.asm:80103c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103c57:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103c68:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103c6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80103c79:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80103c84:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80103c87:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:80103c8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80103c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103cb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
kernel.asm:80103cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80103cd3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:80103cd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
kernel.asm:80103d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80103d03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80103d09:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
kernel.asm:80103d1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103d2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103d3c:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(conf->version != 1 && conf->version != 4)
kernel.asm:80103d52:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103d5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  if(sum((uchar*)conf, conf->length) != 0)
kernel.asm:80103d6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103d7d:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80103d96:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80103d9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103db3:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:80103dbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80103dc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:  lapic = (uint*)conf->lapicaddr;
kernel.asm:80103dd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
kernel.asm:80103de1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103de7:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80103dea:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80103df9:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80103e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103e13:	8b 04 85 94 96 10 80 	mov    -0x7fef696c(,%eax,4),%eax
kernel.asm:80103e1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103e1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:      if(ncpu != proc->apicid){
kernel.asm:80103e22:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:        cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
kernel.asm:80103e35:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:      if(proc->flags & MPBOOT)
kernel.asm:80103e60:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80103eab:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
kernel.asm:80103eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103eb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:      ioapicid = ioapic->apicno;
kernel.asm:80103eb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80103ec3:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
kernel.asm:80103ec9:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
kernel.asm:80103ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  lapic = (uint*)conf->lapicaddr;
kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
kernel.asm:80103ef3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80103ef6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kernel.asm:  if(mp->imcrp){
kernel.asm:80103f25:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80103f71:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80103f75:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80103f78:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80103f7c:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:80103f8d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
kernel.asm:80103f91:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
kernel.asm:80103f9b:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
kernel.asm:80103fad:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
kernel.asm:  //        (slave PIC) 3-bit # of slave's connection to master
kernel.asm:  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
kernel.asm:  // Set up slave (8259A-2)
kernel.asm:801040e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80104136:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80104139:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:  p->readopen = 1;
kernel.asm:80104143:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->writeopen = 1;
kernel.asm:80104150:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->nwrite = 0;
kernel.asm:8010415d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->nread = 0;
kernel.asm:8010416a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  initlock(&p->lock, "pipe");
kernel.asm:80104177:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  (*f0)->type = FD_PIPE;
kernel.asm:  (*f0)->readable = 1;
kernel.asm:  (*f0)->writable = 0;
kernel.asm:  (*f0)->pipe = p;
kernel.asm:801041ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  (*f1)->type = FD_PIPE;
kernel.asm:  (*f1)->readable = 0;
kernel.asm:  (*f1)->writable = 1;
kernel.asm:  (*f1)->pipe = p;
kernel.asm:801041d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  (*f1)->pipe = p;
kernel.asm:801041e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:801041ec:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  return -1;
kernel.asm:  acquire(&p->lock);
kernel.asm:    p->writeopen = 0;
kernel.asm:    wakeup(&p->nread);
kernel.asm:    p->readopen = 0;
kernel.asm:    wakeup(&p->nwrite);
kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
kernel.asm:    release(&p->lock);
kernel.asm:    release(&p->lock);
kernel.asm:  acquire(&p->lock);
kernel.asm:801042f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
kernel.asm:      if(p->readopen == 0 || proc->killed){
kernel.asm:        release(&p->lock);
kernel.asm:        return -1;
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:  acquire(&p->lock);
kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
kernel.asm:        return -1;
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
kernel.asm:80104394:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  acquire(&p->lock);
kernel.asm:801043a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801043aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
kernel.asm:  release(&p->lock);
kernel.asm:  acquire(&p->lock);
kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
kernel.asm:    if(proc->killed){
kernel.asm:      release(&p->lock);
kernel.asm:      return -1;
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:  acquire(&p->lock);
kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
kernel.asm:      release(&p->lock);
kernel.asm:      return -1;
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:  for(i = 0; i < n; i++){  //DOC: piperead-copy
kernel.asm:80104454:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    if(p->nread == p->nwrite)
kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
kernel.asm:80104473:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:      release(&p->lock);
kernel.asm:      return -1;
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:  for(i = 0; i < n; i++){  //DOC: piperead-copy
kernel.asm:801044a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801044a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    if(p->nread == p->nwrite)
kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
kernel.asm:  release(&p->lock);
kernel.asm:801044d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801044d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:801044eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:801044ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:    if(p->state == UNUSED)
kernel.asm:80104540:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80104543:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    if(p->state == UNUSED)
kernel.asm:  p->state = EMBRYO;
kernel.asm:80104564:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->pid = nextpid++;
kernel.asm:8010457e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104587:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  if((p->kstack = kalloc()) == 0){
kernel.asm:801045ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801045b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801045d3:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    p->state = UNUSED;
kernel.asm:801045f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104601:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    p->state = UNUSED;
kernel.asm:  sp = p->kstack + KSTACKSIZE;
kernel.asm:8010462b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104636:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:  sp -= sizeof *p->tf;
kernel.asm:80104639:	83 6d f0 4c          	subl   $0x4c,-0x10(%ebp)
kernel.asm:  p->tf = (struct trapframe*)sp;
kernel.asm:8010463d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104640:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:  sp -= 4;
kernel.asm:80104646:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
kernel.asm:8010464f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  sp -= sizeof *p->context;
kernel.asm:80104654:	83 6d f0 14          	subl   $0x14,-0x10(%ebp)
kernel.asm:  p->context = (struct context*)sp;
kernel.asm:80104658:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010465b:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:  memset(p->context, 0, sizeof *p->context);
kernel.asm:80104661:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->context->eip = (uint)forkret;
kernel.asm:80104677:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->start_ticks = ticks;
kernel.asm:8010468b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->cpu_ticks_in = 0;
kernel.asm:80104691:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  p->cpu_ticks_total = 0;
kernel.asm:8010469e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801046ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  for (int i = 0; i < NPROC - 1; i++) {
kernel.asm:80104702:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:8010470b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104722:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  for (int i = 0; i < NPROC - 1; i++) {
kernel.asm:80104732:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80104736:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
kernel.asm:80104765:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80104768:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  if((p->pgdir = setupkvm()) == 0)
kernel.asm:80104777:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010477d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
kernel.asm:80104799:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->sz = PGSIZE;
kernel.asm:801047b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
kernel.asm:801047ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
kernel.asm:801047d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
kernel.asm:801047dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->tf->es = p->tf->ds;
kernel.asm:801047e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801047ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:  p->tf->ss = p->tf->ds;
kernel.asm:801047fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104802:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:  p->tf->eflags = FL_IF;
kernel.asm:80104810:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->tf->esp = PGSIZE;
kernel.asm:8010481d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
kernel.asm:8010482a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->uid = DEFUID;
kernel.asm:80104837:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->gid = DEFGID;
kernel.asm:80104844:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
kernel.asm:80104851:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  p->cwd = namei("/");
kernel.asm:8010487c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104897:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  p->state = RUNNABLE;
kernel.asm:801048b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801048c5:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:// Return 0 on success, -1 on failure.
kernel.asm:  sz = proc->sz;
kernel.asm:801048f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
kernel.asm:80104902:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104914:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80104920:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80104923:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
kernel.asm:80104939:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010494b:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80104957:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010495a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:  proc->sz = sz;
kernel.asm:8010496d:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80104999:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:8010499c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:    return -1;
kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
kernel.asm:801049cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:801049d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:    kfree(np->kstack);
kernel.asm:801049e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:    np->kstack = 0;
kernel.asm:80104a02:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104a11:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:    np->state = UNUSED;
kernel.asm:80104a32:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104a3f:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:    return -1;
kernel.asm:  np->sz = proc->sz;
kernel.asm:80104a71:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  np->parent = proc;
kernel.asm:80104a7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:80104a83:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  np->tf->eax = 0;
kernel.asm:80104aa1:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104aae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
kernel.asm:    if(proc->ofile[i])
kernel.asm:80104abd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:80104ad1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
kernel.asm:80104ae9:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104aec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:  np->tf->eax = 0;
kernel.asm:80104af6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
kernel.asm:80104afa:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%ebp)
kernel.asm:    if(proc->ofile[i])
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:80104b17:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
kernel.asm:80104b26:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  pid = np->pid;
kernel.asm:80104b3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104b41:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:  np->uid = proc->uid;
kernel.asm:80104b50:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  np->gid = proc->gid;
kernel.asm:80104b65:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:  // lock to force the compiler to emit the np->state write last.
kernel.asm:80104b83:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:  np->state = RUNNABLE;
kernel.asm:80104ba4:	8b 45 e0             	mov    -0x20(%ebp),%eax
kernel.asm:80104bb1:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80104bd1:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:80104bd4:	8d 65 f4             	lea    -0xc(%ebp),%esp
kernel.asm:80104be7:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:80104bef:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:80104bf7:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80104bff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80104c02:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
kernel.asm:80104c26:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:    if(proc->ofile[fd]){
kernel.asm:80104c35:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:      fileclose(proc->ofile[fd]);
kernel.asm:80104c49:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:      proc->ofile[fd] = 0;
kernel.asm:80104c65:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:80104c73:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
kernel.asm:80104c77:	83 7d ec 0f          	cmpl   $0xf,-0x14(%ebp)
kernel.asm:      fileclose(proc->ofile[fd]);
kernel.asm:      proc->ofile[fd] = 0;
kernel.asm:  iput(proc->cwd);
kernel.asm:  proc->cwd = 0;
kernel.asm:  wakeup1(proc->parent);
kernel.asm:80104cce:	8d 45 d8             	lea    -0x28(%ebp),%eax
kernel.asm:80104cd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80104cd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:      if(p->parent == proc) {
kernel.asm:80104ce0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        p->parent = initproc;
kernel.asm:80104cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        if(p->state == ZOMBIE)
kernel.asm:80104cfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:          cprintf("ZZZZZ: %d\n", p->pid);
kernel.asm:80104d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      p = p->next;
kernel.asm:80104d2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104d38:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80104d3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:  wakeup1(proc->parent);
kernel.asm:80104d41:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
kernel.asm:80104d45:	8d 45 d8             	lea    -0x28(%ebp),%eax
kernel.asm:80104d48:	8b 55 e8             	mov    -0x18(%ebp),%edx
kernel.asm:80104d50:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:      p = p->next;
kernel.asm:  proc->state = ZOMBIE;
kernel.asm:80104dc0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
kernel.asm:80104dc8:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:80104dd0:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:80104dd8:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:80104ddb:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
kernel.asm:80104df2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:80104df9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
kernel.asm:80104dfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80104e04:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:        if(p->parent == proc) {
kernel.asm:80104e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104e25:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
kernel.asm:          if (p->state == ZOMBIE) {
kernel.asm:80104e2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            pid = p->pid;
kernel.asm:80104e3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104e41:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:            kfree(p->kstack);
kernel.asm:80104e44:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->kstack = 0;
kernel.asm:80104e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            freevm(p->pgdir);
kernel.asm:80104e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->pid = 0;
kernel.asm:80104e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->parent = 0;
kernel.asm:80104e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->name[0] = 0;
kernel.asm:80104e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->killed = 0;
kernel.asm:80104e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104e9c:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:            cprintf("REMOVED ZOMBIE: %d", p->pid);
kernel.asm:80104ebd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:            p->state = UNUSED;
kernel.asm:80104ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104ef1:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80104f01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:        p = p->next;
kernel.asm:80104f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80104f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80104f12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80104f1c:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
kernel.asm:80104f20:	8d 45 d4             	lea    -0x2c(%ebp),%eax
kernel.asm:80104f23:	8b 55 e8             	mov    -0x18(%ebp),%edx
kernel.asm:80104f2b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:        p = p->next;
kernel.asm:    if(!havekids || proc->killed){
kernel.asm:80104f34:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:      return -1;
kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
kernel.asm:80104f87:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kernel.asm:80104fb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80104fb3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80104fb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80104fc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104fcc:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:      p->state = RUNNING;
kernel.asm:80104fd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      p->cpu_ticks_in = ticks;
kernel.asm:80104fe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80104ff3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:      swtch(&cpu->scheduler, proc->context);
kernel.asm:      // It should have changed its p->state before coming back.
kernel.asm:80105043:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:  cpu->intena = intena;
kernel.asm:  if(cpu->ncli != 1)
kernel.asm:  if(proc->state == RUNNING)
kernel.asm:  intena = cpu->intena;
kernel.asm:801050e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  proc->cpu_ticks_total += (ticks - proc->cpu_ticks_in);   // Update total cpu time
kernel.asm:  swtch(&proc->context, cpu->scheduler);
kernel.asm:  cpu->intena = intena;
kernel.asm:8010513f:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80105149:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:  proc->state = RUNNABLE;
kernel.asm:  // change p->state and then call sched.
kernel.asm:  proc->chan = chan;
kernel.asm:  proc->state = SLEEPING;
kernel.asm:  proc->chan = 0;
kernel.asm:      p->state = RUNNABLE;
kernel.asm:80105304:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  int i = -1;
kernel.asm:80105307:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
kernel.asm:  while(p && i <= NPROC - 1) {
kernel.asm:    if(p->chan == chan) {
kernel.asm:80105310:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010531b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
kernel.asm:8010531f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105322:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80105325:	89 94 85 ec fe ff ff 	mov    %edx,-0x114(%ebp,%eax,4)
kernel.asm:    p = p->next;
kernel.asm:8010532c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105335:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  int i = -1;
kernel.asm:  while(p && i <= NPROC - 1) {
kernel.asm:80105338:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:8010533e:	83 7d f0 3f          	cmpl   $0x3f,-0x10(%ebp)
kernel.asm:    p = p->next;
kernel.asm:80105344:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kernel.asm:8010534d:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80105350:	8b 84 85 ec fe ff ff 	mov    -0x114(%ebp,%eax,4),%eax
kernel.asm:80105357:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010535f:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    p->state = RUNNABLE;
kernel.asm:80105380:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010538d:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    p = p->next;
kernel.asm:8010539d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
kernel.asm:801053a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801053a4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:    p->state = RUNNABLE;
kernel.asm:  return -1;p->killed
kernel.asm:801053ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:801053f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:801053fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80105406:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80105409:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
kernel.asm:80105420:	8d 45 dc             	lea    -0x24(%ebp),%eax
kernel.asm:80105423:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010542b:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105430:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:      if(p->pid == pid) {
kernel.asm:80105438:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        p->killed = 1;
kernel.asm:80105445:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:        if(p->state == SLEEPING) {
kernel.asm:8010544f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010545f:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:          p->state = RUNNABLE;
kernel.asm:80105480:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010548d:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:      p = p->next;
kernel.asm:801054b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801054bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801054c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:801054ca:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
kernel.asm:801054ce:	8d 45 dc             	lea    -0x24(%ebp),%eax
kernel.asm:801054d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:801054d9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:      p = p->next;
kernel.asm:  return -1;
kernel.asm:80105511:	c7 45 f0 b4 39 11 80 	movl   $0x801139b4,-0x10(%ebp)
kernel.asm:    if(p->state == UNUSED)
kernel.asm:8010551d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel.asm:8010552b:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105536:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010553c:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
kernel.asm:      state = states[p->state];
kernel.asm:80105547:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010554d:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
kernel.asm:80105554:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80105559:	c7 45 ec a8 99 10 80 	movl   $0x801099a8,-0x14(%ebp)
kernel.asm:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
kernel.asm:      elaps       = (ticks - p->start_ticks);
kernel.asm:80105566:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105570:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:80105573:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
kernel.asm:8010558b:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:8010558e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
kernel.asm:801055bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:801055be:	8b 55 dc             	mov    -0x24(%ebp),%edx
kernel.asm:801055ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
kernel.asm:801055d1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
kernel.asm:801055fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:80105601:	8b 55 d8             	mov    -0x28(%ebp),%edx
kernel.asm:80105611:	89 45 d8             	mov    %eax,-0x28(%ebp)
kernel.asm:80105614:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
kernel.asm:80105637:	89 45 d4             	mov    %eax,-0x2c(%ebp)
kernel.asm:      cputick_1   = p->cpu_ticks_total/1000;       // CPU time in seconds
kernel.asm:8010563a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010564f:	89 45 d0             	mov    %eax,-0x30(%ebp)
kernel.asm:      cputick_10  = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
kernel.asm:80105652:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105680:	89 55 cc             	mov    %edx,-0x34(%ebp)
kernel.asm:      if(p->pid == 1)
kernel.asm:80105683:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010568e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
kernel.asm:        ppid = p->parent->pid;
kernel.asm:80105697:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
kernel.asm:801056a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801056ca:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:801056cd:	ff 75 cc             	pushl  -0x34(%ebp)
kernel.asm:801056d0:	ff 75 d0             	pushl  -0x30(%ebp)
kernel.asm:801056d3:	ff 75 d4             	pushl  -0x2c(%ebp)
kernel.asm:801056d6:	ff 75 d8             	pushl  -0x28(%ebp)
kernel.asm:801056d9:	ff 75 dc             	pushl  -0x24(%ebp)
kernel.asm:801056dc:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:801056df:	ff 75 e8             	pushl  -0x18(%ebp)
kernel.asm:    if(p->state == SLEEPING){
kernel.asm:801056f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
kernel.asm:8010570e:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010571f:	8d 45 a4             	lea    -0x5c(%ebp),%eax
kernel.asm:8010572c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80105735:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105738:	8b 44 85 a4          	mov    -0x5c(%ebp,%eax,4),%eax
kernel.asm:    if(p->state == SLEEPING){
kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
kernel.asm:8010574d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80105751:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
kernel.asm:80105757:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010575a:	8b 44 85 a4          	mov    -0x5c(%ebp,%eax,4),%eax
kernel.asm:    if(p->state == UNUSED)
kernel.asm:80105775:	81 45 f0 94 00 00 00 	addl   $0x94,-0x10(%ebp)
kernel.asm:8010577c:	81 7d f0 b4 5e 11 80 	cmpl   $0x80115eb4,-0x10(%ebp)
kernel.asm:8010578a:	8d 65 f8             	lea    -0x8(%ebp),%esp
kernel.asm:80105797:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:801057be:	c7 45 f0 b4 39 11 80 	movl   $0x801139b4,-0x10(%ebp)
kernel.asm:    if(p->state != EMBRYO && p->state != UNUSED) {
kernel.asm:801057ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801057d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->pid = p->pid;
kernel.asm:801057e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->uid = p->uid;
kernel.asm:801057f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->gid = p->gid;
kernel.asm:80105801:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      if(p->pid == 1)
kernel.asm:80105810:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:        procs->ppid = 1;
kernel.asm:        procs->ppid = p->parent->pid;
kernel.asm:80105827:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->elapsed_ticks = ticks - p->start_ticks;
kernel.asm:8010583c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->CPU_total_ticks = p->cpu_ticks_total;
kernel.asm:8010584a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      procs->size = p->sz;
kernel.asm:80105859:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
kernel.asm:80105864:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010586a:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
kernel.asm:80105886:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801058a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:801058a9:	81 45 f0 94 00 00 00 	addl   $0x94,-0x10(%ebp)
kernel.asm:801058b0:	81 7d f0 b4 5e 11 80 	cmpl   $0x80115eb4,-0x10(%ebp)
kernel.asm:801058b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
kernel.asm:801058d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801058e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801058e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:  while(p->next) {
kernel.asm:    cprintf("%d -> ", p->pid);
kernel.asm:801058fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    p = p->next;
kernel.asm:80105915:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010591e:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  while(p->next) {
kernel.asm:80105921:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    cprintf("%d -> ", p->pid);
kernel.asm:    p = p->next;
kernel.asm:  cprintf("%d\n", p->pid);
kernel.asm:8010592e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801059a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801059a9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
kernel.asm:801059c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      ppid = p->parent->pid;  // Get PPID of proc is not init
kernel.asm:801059e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801059f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    cprintf("(%d,%d)", p->pid, ppid);
kernel.asm:801059f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801059fd:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:    if(p->next) {
kernel.asm:80105a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      cprintf(" -> ");
kernel.asm:    p = p->next;
kernel.asm:80105a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105a34:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80105a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    if(p->next) {
kernel.asm:      cprintf(" -> ");
kernel.asm:    p = p->next;
kernel.asm:80105a4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80105a4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kernel.asm:80105a56:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
kernel.asm:    p = p->next;
kernel.asm:80105a5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105a63:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80105a66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    p = p->next;
kernel.asm:80105a6f:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:    cprintf("Attempted to remove proc with state \'%s\' from a \'%s\' state list.", states[state], states[(*list)->state]);
kernel.asm:80105ab8:	8b 14 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%edx
kernel.asm:80105ac2:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
kernel.asm:80105aed:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  *list = (*list)->next;
kernel.asm:  p->next = 0;
kernel.asm:80105b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80105b1d:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:    while(curr->next)
kernel.asm:      curr = curr->next;
kernel.asm:    curr->next = proc;
kernel.asm:    while(curr->next)
kernel.asm:      curr = curr->next;
kernel.asm:80105b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80105b3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:    while(curr->next)
kernel.asm:80105b3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:      curr = curr->next;
kernel.asm:    curr->next = proc;
kernel.asm:80105b4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  proc->next = *list;
kernel.asm:  if(proc->state != state) {
kernel.asm:    cprintf("Attempted to remove \'%s\' proc from a state list. Actual state: %s.\n", states[state], states[proc->state]);
kernel.asm:80105b8e:	8b 14 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%edx
kernel.asm:80105b98:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
kernel.asm:80105bc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80105bd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    while(curr != proc && curr->next) {
kernel.asm:80105bd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:      curr = curr->next;
kernel.asm:80105bdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105be4:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    while(curr != proc && curr->next) {
kernel.asm:80105be7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105bef:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:      curr = curr->next;
kernel.asm:80105bfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105c09:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:        *list = (*list)->next;  // Removing proc from the head
kernel.asm:        prev->next = curr->next; // Removing proc from elsewhere
kernel.asm:80105c20:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80105c29:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      curr->next = 0;
kernel.asm:80105c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    if(proc->state == state)
kernel.asm:80105c77:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80105c7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  // The + in "+m" denotes a read-modify-write operand.
kernel.asm:80105c9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80105ca2:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  lk->name = name;
kernel.asm:  lk->locked = 0;
kernel.asm:  lk->cpu = 0;
kernel.asm:  while(xchg(&lk->locked, 1) != 0)
kernel.asm:  lk->cpu = cpu;
kernel.asm:  getcallerpcs(&lk, lk->pcs);
kernel.asm:  lk->pcs[0] = 0;
kernel.asm:  lk->cpu = 0;
kernel.asm:  // Paper says that Intel 64 and IA-32 will not move a load
kernel.asm:  // after a store. So lock->locked = 0 would work here.
kernel.asm:  xchg(&lk->locked, 0);
kernel.asm:  ebp = (uint*)v - 2;
kernel.asm:80105d8e:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80105d91:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
kernel.asm:80105d9a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
kernel.asm:80105da0:	81 7d fc ff ff ff 7f 	cmpl   $0x7fffffff,-0x4(%ebp)
kernel.asm:80105da9:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
kernel.asm:80105daf:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80105dbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80105dc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80105dcb:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:  ebp = (uint*)v - 2;
kernel.asm:80105dce:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
kernel.asm:80105dd2:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
kernel.asm:80105dda:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80105def:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
kernel.asm:80105df3:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
kernel.asm:  return lock->locked && lock->cpu == cpu;
kernel.asm:80105e31:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:  if(cpu->ncli++ == 0)
kernel.asm:    cpu->intena = eflags & FL_IF;
kernel.asm:80105e59:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:    panic("popcli - interruptible");
kernel.asm:  if(--cpu->ncli < 0)
kernel.asm:  if(cpu->ncli == 0 && cpu->intena)
kernel.asm:80105f9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80105fa2:	89 45 f8             	mov    %eax,-0x8(%ebp)
kernel.asm:  while(n-- > 0){
kernel.asm:80105fa7:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80105fad:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:      return *s1 - *s2;
kernel.asm:80105fb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80105fc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80105fcf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:80105fd3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
kernel.asm:  while(n-- > 0){
kernel.asm:80105fda:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:      return *s1 - *s2;
kernel.asm:80105ff4:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80105ffa:	89 45 f8             	mov    %eax,-0x8(%ebp)
kernel.asm:80105ffd:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80106000:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kernel.asm:80106005:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:8010600d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kernel.asm:80106015:	01 45 fc             	add    %eax,-0x4(%ebp)
kernel.asm:8010601b:	01 45 f8             	add    %eax,-0x8(%ebp)
kernel.asm:    while(n-- > 0)
kernel.asm:      *--d = *--s;
kernel.asm:80106020:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
kernel.asm:80106024:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
kernel.asm:80106028:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010602e:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:    while(n-- > 0)
kernel.asm:80106036:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:    while(n-- > 0)
kernel.asm:      *--d = *--s;
kernel.asm:    while(n-- > 0)
kernel.asm:80106042:	8b 45 f8             	mov    -0x8(%ebp),%eax
kernel.asm:80106048:	89 55 f8             	mov    %edx,-0x8(%ebp)
kernel.asm:8010604b:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:80106051:	89 4d fc             	mov    %ecx,-0x4(%ebp)
kernel.asm:    while(n-- > 0)
kernel.asm:      *--d = *--s;
kernel.asm:    while(n-- > 0)
kernel.asm:8010605c:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:    n--, p++, q++;
kernel.asm:    n--, p++, q++;
kernel.asm:  return (uchar)*p - (uchar)*q;
kernel.asm:801060e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:  while(n-- > 0 && (*s++ = *t++) != 0)
kernel.asm:801060e7:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:  while(n-- > 0)
kernel.asm:  while(n-- > 0 && (*s++ = *t++) != 0)
kernel.asm:  while(n-- > 0)
kernel.asm:80106120:	8d 50 ff             	lea    -0x1(%eax),%edx
kernel.asm:8010612a:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:// Like strncpy but guaranteed to NUL-terminate.
kernel.asm:80106138:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80106141:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  while(--n > 0 && (*s++ = *t++) != 0)
kernel.asm:80106174:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010617f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kernel.asm:80106188:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:8010618c:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:8010619b:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  # Save old callee-save registers
kernel.asm:  # Load new callee-save registers
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:    return -1;
kernel.asm:// Fetch the nul-terminated string at addr from the current process.
kernel.asm:// Doesn't actually copy the string - just sets *pp to point at it.
kernel.asm:  if(addr >= proc->sz)
kernel.asm:    return -1;
kernel.asm:  ep = (char*)proc->sz;
kernel.asm:80106219:	89 45 f8             	mov    %eax,-0x8(%ebp)
kernel.asm:80106221:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80106226:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:      return s - *pp;
kernel.asm:80106230:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:  if(addr >= proc->sz)
kernel.asm:    return -1;
kernel.asm:  ep = (char*)proc->sz;
kernel.asm:8010623e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:80106242:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80106245:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kernel.asm:      return s - *pp;
kernel.asm:  return -1;
kernel.asm:// Fetch the nth 32-bit system call argument.
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:// Fetch the nth word-sized system call argument as a pointer
kernel.asm:8010627f:	8d 45 fc             	lea    -0x4(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
kernel.asm:801062a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:801062a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801062c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:// Check that the pointer is valid and the string is nul-terminated.
kernel.asm:801062dc:	8d 45 fc             	lea    -0x4(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801062f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:  num = proc->tf->eax;
kernel.asm:8010631a:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010631d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80106323:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010632b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010632e:	8b 04 85 40 c0 10 80 	mov    -0x7fef3fc0(,%eax,4),%eax
kernel.asm:    proc->tf->eax = syscalls[num]();
kernel.asm:80106342:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106345:	8b 04 85 40 c0 10 80 	mov    -0x7fef3fc0(,%eax,4),%eax
kernel.asm:    cprintf("%s -> %d \n", syscallnames[num], proc->tf->eax);
kernel.asm:            proc->pid, proc->name, num);
kernel.asm:    cprintf("%s -> %d \n", syscallnames[num], proc->tf->eax);
kernel.asm:80106365:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:            proc->pid, proc->name, num);
kernel.asm:    proc->tf->eax = -1;
kernel.asm:80106388:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:// Fetch the nth word-sized system call argument as a file descriptor
kernel.asm:80106396:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:801063b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801063b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801063c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:801063cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801063d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:801063e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:801063f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80106408:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:80106417:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:8010642b:	8b 55 fc             	mov    -0x4(%ebp),%edx
kernel.asm:80106438:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010643d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:80106441:	83 7d fc 0f          	cmpl   $0xf,-0x4(%ebp)
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:  return -1;
kernel.asm:80106457:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80106472:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106481:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106484:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106491:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801064a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801064ae:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:801064c5:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:801064d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801064de:	8d 45 ec             	lea    -0x14(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801064f7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
kernel.asm:801064fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:801064fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106519:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:80106530:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:80106542:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106549:	8d 45 ec             	lea    -0x14(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80106562:	8b 4d f0             	mov    -0x10(%ebp),%ecx
kernel.asm:80106565:	8b 55 ec             	mov    -0x14(%ebp),%edx
kernel.asm:80106568:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106584:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:80106588:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  proc->ofile[fd] = 0;
kernel.asm:801065a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801065b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801065d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:801065ed:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80106606:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:80106609:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106624:	8d 45 d8             	lea    -0x28(%ebp),%eax
kernel.asm:80106639:	8d 45 dc             	lea    -0x24(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:8010665a:	8b 45 d8             	mov    -0x28(%ebp),%eax
kernel.asm:80106669:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010666c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106684:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  if(ip->type == T_DIR){
kernel.asm:8010668f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010669f:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:  ip->nlink++;
kernel.asm:801066b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801066c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801066cf:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801066dd:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801066e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
kernel.asm:801066ee:	8d 55 e2             	lea    -0x1e(%ebp),%edx
kernel.asm:801066fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:801066fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80106707:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel.asm:80106712:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106717:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106720:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010672a:	8d 45 e2             	lea    -0x1e(%ebp),%eax
kernel.asm:8010672e:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106740:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106750:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:8010675e:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  ip->nlink++;
kernel.asm:80106779:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  ip->nlink--;
kernel.asm:80106784:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106790:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010679a:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801067a8:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  return -1;
kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel.asm:801067c5:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
kernel.asm:801067ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801067d4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
kernel.asm:801067f5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel.asm:80106805:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010680b:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106814:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010682b:	8d 45 cc             	lea    -0x34(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:8010684c:	8b 45 cc             	mov    -0x34(%ebp),%eax
kernel.asm:80106852:	8d 55 d2             	lea    -0x2e(%ebp),%edx
kernel.asm:8010685f:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106862:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:8010687a:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:8010688d:	8d 45 d2             	lea    -0x2e(%ebp),%eax
kernel.asm:801068a9:	8d 45 d2             	lea    -0x2e(%ebp),%eax
kernel.asm:801068c0:	8d 45 c8             	lea    -0x38(%ebp),%eax
kernel.asm:801068c4:	8d 45 d2             	lea    -0x2e(%ebp),%eax
kernel.asm:801068c8:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801068d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:801068d6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:801068e3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(ip->nlink < 1)
kernel.asm:801068ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel.asm:80106907:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106917:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106929:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106940:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:8010694c:	8b 45 c8             	mov    -0x38(%ebp),%eax
kernel.asm:80106952:	8d 45 e0             	lea    -0x20(%ebp),%eax
kernel.asm:80106956:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  if(ip->type == T_DIR){
kernel.asm:80106973:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    dp->nlink--;
kernel.asm:80106980:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010698c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106996:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:801069a4:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  ip->nlink--;
kernel.asm:801069af:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801069bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:801069c5:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801069d3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801069ee:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  return -1;
kernel.asm:80106a14:	66 89 4d d4          	mov    %cx,-0x2c(%ebp)
kernel.asm:80106a18:	66 89 55 d0          	mov    %dx,-0x30(%ebp)
kernel.asm:80106a1c:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
kernel.asm:80106a23:	8d 45 de             	lea    -0x22(%ebp),%eax
kernel.asm:80106a32:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106a35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80106a48:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106a56:	8d 45 ec             	lea    -0x14(%ebp),%eax
kernel.asm:80106a5a:	8d 45 de             	lea    -0x22(%ebp),%eax
kernel.asm:80106a5e:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106a69:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80106a6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80106a75:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106a83:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
kernel.asm:80106a8e:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
kernel.asm:80106a95:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106aa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106aad:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
kernel.asm:80106ac2:	0f bf 55 d4          	movswl -0x2c(%ebp),%edx
kernel.asm:80106ac6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106ad8:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80106adb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80106af1:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  ip->major = major;
kernel.asm:80106afc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106aff:	0f b7 55 d0          	movzwl -0x30(%ebp),%edx
kernel.asm:  ip->minor = minor;
kernel.asm:80106b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106b0a:	0f b7 55 cc          	movzwl -0x34(%ebp),%edx
kernel.asm:  ip->nlink = 1;
kernel.asm:80106b12:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106b1e:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106b29:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
kernel.asm:    dp->nlink++;  // for ".."
kernel.asm:80106b30:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106b46:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel.asm:80106b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106b60:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106b6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106b7e:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
kernel.asm:80106b9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106ba4:	8d 45 de             	lea    -0x22(%ebp),%eax
kernel.asm:80106ba8:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106bc7:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106be0:	8d 45 e8             	lea    -0x18(%ebp),%eax
kernel.asm:80106bf5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80106c16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106c22:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80106c34:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106c37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:80106c4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80106c5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106c5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:80106c76:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel.asm:80106c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106c8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106c98:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:80106cb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80106cba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80106cc3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106cce:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80106cd1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:80106cd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80106ce0:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106cee:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106d08:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  f->type = FD_INODE;
kernel.asm:80106d18:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  f->ip = ip;
kernel.asm:80106d21:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106d24:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  f->off = 0;
kernel.asm:80106d2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  f->readable = !(omode & O_WRONLY);
kernel.asm:80106d34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
kernel.asm:80106d47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106d51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106d69:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106d6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80106d82:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:80106d94:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106da6:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106da9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106dbe:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80106de3:	8d 45 ec             	lea    -0x14(%ebp),%eax
kernel.asm:80106df1:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106df4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80106dfd:	8d 45 e8             	lea    -0x18(%ebp),%eax
kernel.asm:80106e12:	8d 45 e4             	lea    -0x1c(%ebp),%eax
kernel.asm:80106e24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:80106e2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80106e30:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80106e40:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80106e43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:    return -1;
kernel.asm:80106e58:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80106e7d:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:80106e8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106e9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80106ea1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106eb6:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  if(ip->type != T_DIR){
kernel.asm:80106ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106ed1:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:80106eeb:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:  iput(proc->cwd);
kernel.asm:  proc->cwd = ip;
kernel.asm:80106f16:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80106f2f:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:80106f44:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80106f6d:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
kernel.asm:80106f7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80106f83:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      return -1;
kernel.asm:80106f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106f9d:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
kernel.asm:80106fa8:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
kernel.asm:      return -1;
kernel.asm:80106fc3:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
kernel.asm:80106fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80106fd0:	c7 84 85 70 ff ff ff 	movl   $0x0,-0x90(%ebp,%eax,4)
kernel.asm:      return -1;
kernel.asm:80106fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80106fe2:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
kernel.asm:      return -1;
kernel.asm:80106ff4:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
kernel.asm:80106ffa:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:80107002:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
kernel.asm:      return -1;
kernel.asm:    return -1;
kernel.asm:80107020:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:80107036:	8d 45 ec             	lea    -0x14(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80107055:	8d 45 e4             	lea    -0x1c(%ebp),%eax
kernel.asm:80107059:	8d 45 e8             	lea    -0x18(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  fd0 = -1;
kernel.asm:80107073:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
kernel.asm:8010707a:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:80107089:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:8010708c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80107092:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:801070a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:801070a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:801070aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:      proc->ofile[fd0] = 0;
kernel.asm:801070b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801070c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:801070d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801070e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801070ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:801070f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801070f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010710f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80107113:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
kernel.asm:80107117:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
kernel.asm:8010711b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:80107159:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80107172:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  return proc->pid;
kernel.asm:8010719a:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  addr = proc->sz;
kernel.asm:801071bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801071be:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801071d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801071e6:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80107204:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  while(ticks - ticks0 < n){
kernel.asm:    if(proc->killed){
kernel.asm:      return -1;
kernel.asm:    return -1;
kernel.asm:  while(ticks - ticks0 < n){
kernel.asm:80107234:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:80107237:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:    if(proc->killed){
kernel.asm:      return -1;
kernel.asm:80107250:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:80107253:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:// Added functions - Evghenii
kernel.asm:80107295:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801072ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801072cd:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801072e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801072ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  proc->uid = (uint)uid;
kernel.asm:80107304:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:8010731d:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:80107336:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010733d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:  proc->gid = (uint)gid;
kernel.asm:80107354:	8b 55 f4             	mov    -0xc(%ebp),%edx
kernel.asm:  return proc->uid;
kernel.asm:  return proc->gid;
kernel.asm:  if(proc->pid == 1) {
kernel.asm:  return proc->parent->pid;
kernel.asm:801073b5:	8d 45 f4             	lea    -0xc(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801073d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
kernel.asm:    return -1;
kernel.asm:801073ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
kernel.asm:801073ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010740d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:80107411:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:80107414:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:80107418:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:  # Set up data and per-cpu segments.
kernel.asm:  pd[0] = size-1;
kernel.asm:801074a0:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
kernel.asm:801074a7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
kernel.asm:801074b1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
kernel.asm:801074b5:	8d 45 fa             	lea    -0x6(%ebp),%eax
kernel.asm:801074c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
kernel.asm:801074ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:801074d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kernel.asm:801074e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:801074e4:	8b 04 85 b8 c0 10 80 	mov    -0x7fef3f48(,%eax,4),%eax
kernel.asm:801074ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:801074f0:	66 89 14 c5 e0 5e 11 	mov    %dx,-0x7feea120(,%eax,8)
kernel.asm:801074f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:801074fb:	66 c7 04 c5 e2 5e 11 	movw   $0x8,-0x7feea11e(,%eax,8)
kernel.asm:80107505:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80107508:	0f b6 14 c5 e4 5e 11 	movzbl -0x7feea11c(,%eax,8),%edx
kernel.asm:80107513:	88 14 c5 e4 5e 11 80 	mov    %dl,-0x7feea11c(,%eax,8)
kernel.asm:8010751a:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010751d:	0f b6 14 c5 e4 5e 11 	movzbl -0x7feea11c(,%eax,8),%edx
kernel.asm:80107528:	88 14 c5 e4 5e 11 80 	mov    %dl,-0x7feea11c(,%eax,8)
kernel.asm:8010752f:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80107532:	0f b6 14 c5 e5 5e 11 	movzbl -0x7feea11b(,%eax,8),%edx
kernel.asm:80107540:	88 14 c5 e5 5e 11 80 	mov    %dl,-0x7feea11b(,%eax,8)
kernel.asm:80107547:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010754a:	0f b6 14 c5 e5 5e 11 	movzbl -0x7feea11b(,%eax,8),%edx
kernel.asm:80107555:	88 14 c5 e5 5e 11 80 	mov    %dl,-0x7feea11b(,%eax,8)
kernel.asm:8010755c:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:8010755f:	0f b6 14 c5 e5 5e 11 	movzbl -0x7feea11b(,%eax,8),%edx
kernel.asm:8010756a:	88 14 c5 e5 5e 11 80 	mov    %dl,-0x7feea11b(,%eax,8)
kernel.asm:80107571:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80107574:	0f b6 14 c5 e5 5e 11 	movzbl -0x7feea11b(,%eax,8),%edx
kernel.asm:8010757f:	88 14 c5 e5 5e 11 80 	mov    %dl,-0x7feea11b(,%eax,8)
kernel.asm:80107586:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80107589:	8b 04 85 b8 c0 10 80 	mov    -0x7fef3f48(,%eax,4),%eax
kernel.asm:80107595:	8b 45 fc             	mov    -0x4(%ebp),%eax
kernel.asm:80107598:	66 89 14 c5 e6 5e 11 	mov    %dx,-0x7feea11a(,%eax,8)
kernel.asm:801075a0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kernel.asm:801075a4:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
kernel.asm:  if(tf->trapno == T_SYSCALL){
kernel.asm:    if(proc->killed)
kernel.asm:    proc->tf = tf;
kernel.asm:    if(proc->killed)
kernel.asm:  switch(tf->trapno){
kernel.asm:801076ac:	8b 04 85 78 9c 10 80 	mov    -0x7fef6388(,%eax,4),%eax
kernel.asm:   if(cpu->id == 0){
kernel.asm:            cpu->id, tf->cs, tf->eip);
kernel.asm:            cpu->id, tf->cs, tf->eip);
kernel.asm:            cpu->id, tf->cs, tf->eip);
kernel.asm:    if(proc == 0 || (tf->cs&3) == 0){
kernel.asm:              tf->trapno, cpu->id, tf->eip, rcr2());
kernel.asm:    if(proc == 0 || (tf->cs&3) == 0){
kernel.asm:              tf->trapno, cpu->id, tf->eip, rcr2());
kernel.asm:801077af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
kernel.asm:              tf->trapno, cpu->id, tf->eip, rcr2());
kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
kernel.asm:              tf->trapno, cpu->id, tf->eip, rcr2());
kernel.asm:801077e2:	ff 75 e4             	pushl  -0x1c(%ebp)
kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
kernel.asm:    proc->killed = 1;
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:  if(proc && proc->state == RUNNING &&
kernel.asm:	  tf->trapno == T_IRQ0+IRQ_TIMER && ticks%SCHED_INTERVAL==0)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:  if(proc && proc->state == RUNNING &&
kernel.asm:	  tf->trapno == T_IRQ0+IRQ_TIMER && ticks%SCHED_INTERVAL==0)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:    proc->tf = tf;
kernel.asm:    if(proc->killed)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:801078b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
kernel.asm:801078c3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
kernel.asm:801078c7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
kernel.asm:801078ce:	88 45 ff             	mov    %al,-0x1(%ebp)
kernel.asm:801078d1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
kernel.asm:801078e3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
kernel.asm:801078e7:	88 45 f8             	mov    %al,-0x8(%ebp)
kernel.asm:801078ea:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
kernel.asm:801078ee:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
kernel.asm:  // Acknowledge pre-existing interrupt conditions;
kernel.asm:801079b9:	c7 45 f4 f8 9c 10 80 	movl   $0x80109cf8,-0xc(%ebp)
kernel.asm:801079c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801079d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801079db:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801079f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80107a0f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:80107a13:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
kernel.asm:    return -1;
kernel.asm:    return -1;
kernel.asm:# generated by vectors.pl - do not edit
kernel.asm:  pd[0] = size-1;
kernel.asm:80108529:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
kernel.asm:80108530:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
kernel.asm:8010853a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
kernel.asm:8010853e:	8d 45 fa             	lea    -0x6(%ebp),%eax
kernel.asm:80108550:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
kernel.asm:80108554:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
kernel.asm:80108567:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
kernel.asm:8010856b:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
kernel.asm:static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
kernel.asm:801085b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
kernel.asm:801085b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801085f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108604:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108611:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010861e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010862b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108638:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108645:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
kernel.asm:8010864c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108658:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108664:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010866e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108684:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108697:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801086aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801086bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801086d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801086e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801086f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108709:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010871c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
kernel.asm:80108726:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108732:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010873e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108748:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010875e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108771:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108784:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108797:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801087aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801087bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801087d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801087e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801087f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
kernel.asm:80108800:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010880c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108818:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108822:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108838:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010884b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010885e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108871:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108884:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108897:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
kernel.asm:801088da:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801088fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010890a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108914:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010891d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108933:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108946:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108959:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010896c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010897f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108992:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801089a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801089b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801089cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  lgdt(c->gdt, sizeof(c->gdt));
kernel.asm:801089d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:  // Initialize cpu-local storage.
kernel.asm:801089f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108a0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:80108a27:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108a2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80108a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80108a49:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80108a59:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80108a5c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:80108a73:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80108a81:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80108a91:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80108aa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:// be page-aligned.
kernel.asm:80108abd:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
kernel.asm:80108ad0:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108ad8:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80108ae6:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80108ae9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:      return -1;
kernel.asm:80108af6:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80108b1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80108b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108b22:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:80108b27:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:      return -1;
kernel.asm:80108b4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108b4e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80108b68:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80108b97:	c7 45 f4 c0 c4 10 80 	movl   $0x8010c4c0,-0xc(%ebp)
kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
kernel.asm:80108ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:                (uint)k->phys_start, k->perm) < 0)
kernel.asm:80108ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
kernel.asm:80108bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108bba:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108bc6:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:                (uint)k->phys_start, k->perm) < 0)
kernel.asm:80108bdc:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
kernel.asm:80108be0:	81 7d f4 00 c5 10 80 	cmpl   $0x8010c500,-0xc(%ebp)
kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
kernel.asm:                (uint)k->phys_start, k->perm) < 0)
kernel.asm:80108be9:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80108bec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:// Switch h/w page table register to the kernel-only page table,
kernel.asm:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
kernel.asm:  cpu->gdt[SEG_TSS].s = 0;
kernel.asm:  cpu->ts.ss0 = SEG_KDATA << 3;
kernel.asm:  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
kernel.asm:  if(p->pgdir == 0)
kernel.asm:  lcr3(v2p(p->pgdir));  // switch to new address space
kernel.asm:80108d92:	8d 65 f8             	lea    -0x8(%ebp),%esp
kernel.asm:80108dba:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80108dc7:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80108dd5:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:80108e01:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:// Load a program segment into pgdir.  addr must be page-aligned
kernel.asm:80108e2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80108e3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108e54:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80108e57:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:80108e6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80108e74:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:    if(sz - i < PGSIZE)
kernel.asm:80108e7a:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:      n = sz - i;
kernel.asm:80108e87:	2b 45 f4             	sub    -0xc(%ebp),%eax
kernel.asm:80108e8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108e8f:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
kernel.asm:80108e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108ea2:	ff 75 e8             	pushl  -0x18(%ebp)
kernel.asm:80108ead:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80108ebd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
kernel.asm:      return -1;
kernel.asm:80108ec9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:80108ed0:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:      return -1;
kernel.asm:80108ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:80108f1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80108f24:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108f27:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:80108f62:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80108f70:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80108f7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108f97:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:80108f9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
kernel.asm:80108fd2:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80108fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80108fee:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:80108ff1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:      a += (NPTENTRIES - 1) * PGSIZE;
kernel.asm:80108ff7:	81 45 f4 00 f0 3f 00 	addl   $0x3ff000,-0xc(%ebp)
kernel.asm:80109000:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010900c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80109016:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:80109019:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:8010902f:	ff 75 ec             	pushl  -0x14(%ebp)
kernel.asm:8010903a:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:80109040:	ff 75 e8             	pushl  -0x18(%ebp)
kernel.asm:8010904b:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80109054:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:8010905b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010909a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:801090a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801090bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801090dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:801090e3:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:801090ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kernel.asm:801090f2:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
kernel.asm:80109125:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80109128:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kernel.asm:8010913b:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80109145:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80109159:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010915c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kernel.asm:8010916c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kernel.asm:80109178:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:8010918c:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:8010918f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kernel.asm:801091a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801091bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801091c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:801091c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801091d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kernel.asm:801091da:	89 45 e0             	mov    %eax,-0x20(%ebp)
kernel.asm:801091dd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
kernel.asm:801091e6:	ff 75 e8             	pushl  -0x18(%ebp)
kernel.asm:801091fa:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80109205:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
kernel.asm:8010920b:	ff 75 e0             	pushl  -0x20(%ebp)
kernel.asm:80109218:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80109226:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80109235:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
kernel.asm:8010923c:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80109248:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80109254:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:80109264:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kernel.asm:80109282:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:80109285:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:80109298:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801092ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
kernel.asm:801092cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
kernel.asm:801092d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
kernel.asm:801092dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:801092ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
kernel.asm:801092f1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
kernel.asm:      return -1;
kernel.asm:    n = PGSIZE - (va - va0);
kernel.asm:801092fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:80109309:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:8010930c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80109317:	89 45 f0             	mov    %eax,-0x10(%ebp)
kernel.asm:    memmove(pa0 + (va - va0), buf, n);
kernel.asm:8010931d:	2b 45 ec             	sub    -0x14(%ebp),%eax
kernel.asm:80109322:	8b 45 e8             	mov    -0x18(%ebp),%eax
kernel.asm:8010932a:	ff 75 f0             	pushl  -0x10(%ebp)
kernel.asm:8010932d:	ff 75 f4             	pushl  -0xc(%ebp)
kernel.asm:    len -= n;
kernel.asm:80109339:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:8010933f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kernel.asm:80109342:	01 45 f4             	add    %eax,-0xc(%ebp)
kernel.asm:80109345:	8b 45 ec             	mov    -0x14(%ebp),%eax
kernel.asm:    memmove(pa0 + (va - va0), buf, n);
kernel.asm:    len -= n;
kernel.ld:OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
kernel.ld:	/* Conventionally, Unix linkers provide pseudo-symbols
kernel.ld:	 * read-only rodata section between text and data. */
kernel.ld:		*(.eh_frame .note.GNU-stack)
Binary file _kill matches
kill.asm:_kill:     file format elf32-i386
kill.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
kill.asm:  30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
kill.asm:  39:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm:  62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kill.asm:  66:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm:  a1:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm:  c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm:  return (uchar)*p - (uchar)*q;
kill.asm: 10d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kill.asm: 116:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
kill.asm: 11a:	8b 55 fc             	mov    -0x4(%ebp),%edx
kill.asm: 129:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 151:	88 45 fc             	mov    %al,-0x4(%ebp)
kill.asm: 15c:	3a 45 fc             	cmp    -0x4(%ebp),%al
kill.asm: 181:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kill.asm: 18f:	8d 45 ef             	lea    -0x11(%ebp),%eax
kill.asm: 19d:	89 45 f0             	mov    %eax,-0x10(%ebp)
kill.asm: 1a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kill.asm: 1a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 1ac:	89 55 f4             	mov    %edx,-0xc(%ebp)
kill.asm: 1b6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
kill.asm: 1bc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
kill.asm: 1c4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
kill.asm: 1cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 1da:	8b 55 f4             	mov    -0xc(%ebp),%edx
kill.asm: 200:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm: 203:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kill.asm:    return -1;
kill.asm: 216:	ff 75 f4             	pushl  -0xc(%ebp)
kill.asm: 221:	89 45 f0             	mov    %eax,-0x10(%ebp)
kill.asm: 227:	ff 75 f4             	pushl  -0xc(%ebp)
kill.asm: 232:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm: 23d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kill.asm:  sign = (*s == '-') ? -1 : 1;
kill.asm: 26a:	89 45 f8             	mov    %eax,-0x8(%ebp)
kill.asm:  if (*s == '+'  || *s == '-')
kill.asm:    n = n*10 + *s++ - '0';
kill.asm: 287:	8b 55 fc             	mov    -0x4(%ebp),%edx
kill.asm: 2a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm:  sign = (*s == '-') ? -1 : 1;
kill.asm:  if (*s == '+'  || *s == '-')
kill.asm:    n = n*10 + *s++ - '0';
kill.asm: 2c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 2c3:	0f af 45 fc          	imul   -0x4(%ebp),%eax
kill.asm: 2cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
kill.asm:  sign = (*s == '-') ? -1 : 1;
kill.asm: 2fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
kill.asm:  if (*s == '+'  || *s == '-')
kill.asm:    n = n*8 + *s++ - '0';
kill.asm: 319:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 337:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm:  sign = (*s == '-') ? -1 : 1;
kill.asm:  if (*s == '+'  || *s == '-')
kill.asm:    n = n*8 + *s++ - '0';
kill.asm: 34e:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 351:	0f af 45 fc          	imul   -0x4(%ebp),%eax
kill.asm: 360:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm: 366:	89 45 f8             	mov    %eax,-0x8(%ebp)
kill.asm:  while(n-- > 0)
kill.asm: 36b:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 371:	89 55 fc             	mov    %edx,-0x4(%ebp)
kill.asm: 374:	8b 55 f8             	mov    -0x8(%ebp),%edx
kill.asm: 37a:	89 4d f8             	mov    %ecx,-0x8(%ebp)
kill.asm:  while(n-- > 0)
kill.asm: 385:	8d 50 ff             	lea    -0x1(%eax),%edx
kill.asm:# Added calls - Evghenii
kill.asm: 485:	88 45 f4             	mov    %al,-0xc(%ebp)
kill.asm: 48d:	8d 45 f4             	lea    -0xc(%ebp),%eax
kill.asm: 4a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kill.asm: 4b9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
kill.asm:    x = -xx;
kill.asm: 4c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
kill.asm: 4cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
kill.asm: 4d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
kill.asm: 4d7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
kill.asm: 4dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm: 4e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
kill.asm: 4f6:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
kill.asm: 4fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
kill.asm: 507:	89 45 ec             	mov    %eax,-0x14(%ebp)
kill.asm: 50a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kill.asm: 510:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kill.asm:    buf[i++] = '-';
kill.asm: 516:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 51c:	89 55 f4             	mov    %edx,-0xc(%ebp)
kill.asm: 51f:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
kill.asm:  while(--i >= 0)
kill.asm: 526:	8d 55 dc             	lea    -0x24(%ebp),%edx
kill.asm: 529:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm:    buf[i++] = '-';
kill.asm:  while(--i >= 0)
kill.asm: 543:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
kill.asm: 547:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kill.asm: 54e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
kill.asm: 559:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kill.asm: 566:	89 45 e8             	mov    %eax,-0x18(%ebp)
kill.asm: 569:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
kill.asm: 578:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm: 588:	89 45 e4             	mov    %eax,-0x1c(%ebp)
kill.asm: 58b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
kill.asm: 591:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
kill.asm: 597:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
kill.asm: 5a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kill.asm: 5bd:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
kill.asm: 5c7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
kill.asm: 5cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
kill.asm: 5e2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
kill.asm: 5eb:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
kill.asm: 5f1:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
kill.asm: 5f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
kill.asm: 60c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
kill.asm: 615:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
kill.asm: 61b:	8b 45 e8             	mov    -0x18(%ebp),%eax
kill.asm: 620:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm: 623:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
kill.asm: 627:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kill.asm: 62d:	c7 45 f4 1d 09 00 00 	movl   $0x91d,-0xc(%ebp)
kill.asm: 636:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 64e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
kill.asm: 652:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 65e:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
kill.asm: 664:	8b 45 e8             	mov    -0x18(%ebp),%eax
kill.asm: 67b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
kill.asm: 681:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
kill.asm: 687:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kill.asm: 6ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
kill.asm: 6c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
kill.asm: 6ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
kill.asm: 6d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm:  bp = (Header*)ap - 1;
kill.asm: 6f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
kill.asm: 6f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
kill.asm: 6fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 702:	3b 45 fc             	cmp    -0x4(%ebp),%eax
kill.asm: 707:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 70a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
kill.asm: 70f:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 714:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kill.asm:  bp = (Header*)ap - 1;
kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
kill.asm: 719:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 71e:	89 45 fc             	mov    %eax,-0x4(%ebp)
kill.asm: 721:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 724:	3b 45 fc             	cmp    -0x4(%ebp),%eax
kill.asm: 729:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 72e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
kill.asm:  if(bp + bp->s.size == p->s.ptr){
kill.asm: 733:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 740:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 745:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm:    bp->s.size += p->s.ptr->s.size;
kill.asm: 74e:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 754:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
kill.asm: 764:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 76b:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm:    bp->s.ptr = p->s.ptr;
kill.asm: 772:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 777:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm:  if(p + p->s.size == bp){
kill.asm: 77c:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 789:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 78e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
kill.asm:    p->s.size += bp->s.size;
kill.asm: 793:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 799:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 7a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm:    p->s.ptr = bp->s.ptr;
kill.asm: 7a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
kill.asm: 7ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm:    p->s.ptr = bp;
kill.asm: 7b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 7b6:	8b 55 f8             	mov    -0x8(%ebp),%edx
kill.asm: 7bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
kill.asm: 7ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm:  if(p == (char*)-1)
kill.asm: 7f1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
kill.asm: 7fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 801:	89 45 f0             	mov    %eax,-0x10(%ebp)
kill.asm:  hp->s.size = nu;
kill.asm: 804:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm: 80d:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
kill.asm: 838:	89 45 ec             	mov    %eax,-0x14(%ebp)
kill.asm: 840:	89 45 f0             	mov    %eax,-0x10(%ebp)
kill.asm: 843:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
kill.asm: 849:	c7 45 f0 a4 0b 00 00 	movl   $0xba4,-0x10(%ebp)
kill.asm: 850:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
kill.asm: 86c:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm: 871:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm:    if(p->s.size >= nunits){
kill.asm: 874:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 87a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kill.asm:      if(p->s.size == nunits)
kill.asm: 87f:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 885:	3b 45 ec             	cmp    -0x14(%ebp),%eax
kill.asm:        prevp->s.ptr = p->s.ptr;
kill.asm: 88a:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 88f:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm:        p->s.size -= nunits;
kill.asm: 896:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 89c:	2b 45 ec             	sub    -0x14(%ebp),%eax
kill.asm: 8a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm:        p += p->s.size;
kill.asm: 8a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 8b0:	01 45 f4             	add    %eax,-0xc(%ebp)
kill.asm:        p->s.size = nunits;
kill.asm: 8b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 8b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
kill.asm: 8bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
kill.asm: 8c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 8d1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
kill.asm: 8d9:	ff 75 ec             	pushl  -0x14(%ebp)
kill.asm: 8e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.asm: 8e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
kill.asm: 8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 8f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
kill.asm: 8fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
kill.asm: 8ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
kill.d:kill.o: kill.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file kill.o matches
lapic.c:// The local APIC manages internal (non-I/O) interrupts.
lapic.c:  // Clear error status register (requires back-to-back writes).
lapic.c:  // Send an Init Level De-Assert to synchronise arbitration ID's.
lapic.c:  // Send INIT (level-triggered) interrupt to reset other CPU.
lapic.c:  r->second = cmos_read(SECS);
lapic.c:  r->minute = cmos_read(MINS);
lapic.c:  r->hour   = cmos_read(HOURS);
lapic.c:  r->day    = cmos_read(DAY);
lapic.c:  r->month  = cmos_read(MONTH);
lapic.c:  r->year   = cmos_read(YEAR);
lapic.c:// qemu seems to use 24-hour GWT and the values are BCD encoded
lapic.c:  r->year += 2000;
lapic.d:lapic.o: lapic.c /usr/include/stdc-predef.h RMME.h types.h defs.h date.h \
Binary file lapic.o matches
LICENSE:Copyright (c) 2006-2009 Frans Kaashoek, Robert Morris, Russ Cox,
Binary file _ln matches
ln.asm:_ln:     file format elf32-i386
ln.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
ln.asm:  a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm:  c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm:  return (uchar)*p - (uchar)*q;
ln.asm: 10f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ln.asm: 118:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
ln.asm: 11c:	8b 55 fc             	mov    -0x4(%ebp),%edx
ln.asm: 12b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 153:	88 45 fc             	mov    %al,-0x4(%ebp)
ln.asm: 15e:	3a 45 fc             	cmp    -0x4(%ebp),%al
ln.asm: 183:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ln.asm: 191:	8d 45 ef             	lea    -0x11(%ebp),%eax
ln.asm: 19f:	89 45 f0             	mov    %eax,-0x10(%ebp)
ln.asm: 1a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ln.asm: 1a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 1ae:	89 55 f4             	mov    %edx,-0xc(%ebp)
ln.asm: 1b8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ln.asm: 1be:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ln.asm: 1c6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ln.asm: 1ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 1dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
ln.asm: 202:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm: 205:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ln.asm:    return -1;
ln.asm: 218:	ff 75 f4             	pushl  -0xc(%ebp)
ln.asm: 223:	89 45 f0             	mov    %eax,-0x10(%ebp)
ln.asm: 229:	ff 75 f4             	pushl  -0xc(%ebp)
ln.asm: 234:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm: 23f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ln.asm:  sign = (*s == '-') ? -1 : 1;
ln.asm: 26c:	89 45 f8             	mov    %eax,-0x8(%ebp)
ln.asm:  if (*s == '+'  || *s == '-')
ln.asm:    n = n*10 + *s++ - '0';
ln.asm: 289:	8b 55 fc             	mov    -0x4(%ebp),%edx
ln.asm: 2ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm:  sign = (*s == '-') ? -1 : 1;
ln.asm:  if (*s == '+'  || *s == '-')
ln.asm:    n = n*10 + *s++ - '0';
ln.asm: 2c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 2c5:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ln.asm: 2d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ln.asm:  sign = (*s == '-') ? -1 : 1;
ln.asm: 2fe:	89 45 f8             	mov    %eax,-0x8(%ebp)
ln.asm:  if (*s == '+'  || *s == '-')
ln.asm:    n = n*8 + *s++ - '0';
ln.asm: 31b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 339:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm:  sign = (*s == '-') ? -1 : 1;
ln.asm:  if (*s == '+'  || *s == '-')
ln.asm:    n = n*8 + *s++ - '0';
ln.asm: 350:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 353:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ln.asm: 362:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm: 368:	89 45 f8             	mov    %eax,-0x8(%ebp)
ln.asm:  while(n-- > 0)
ln.asm: 36d:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 373:	89 55 fc             	mov    %edx,-0x4(%ebp)
ln.asm: 376:	8b 55 f8             	mov    -0x8(%ebp),%edx
ln.asm: 37c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
ln.asm:  while(n-- > 0)
ln.asm: 387:	8d 50 ff             	lea    -0x1(%eax),%edx
ln.asm:# Added calls - Evghenii
ln.asm: 487:	88 45 f4             	mov    %al,-0xc(%ebp)
ln.asm: 48f:	8d 45 f4             	lea    -0xc(%ebp),%eax
ln.asm: 4a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ln.asm: 4bb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
ln.asm:    x = -xx;
ln.asm: 4c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
ln.asm: 4cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
ln.asm: 4d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ln.asm: 4d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
ln.asm: 4df:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm: 4e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
ln.asm: 4f8:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
ln.asm: 4ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
ln.asm: 509:	89 45 ec             	mov    %eax,-0x14(%ebp)
ln.asm: 50c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ln.asm: 512:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ln.asm:    buf[i++] = '-';
ln.asm: 518:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 51e:	89 55 f4             	mov    %edx,-0xc(%ebp)
ln.asm: 521:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
ln.asm:  while(--i >= 0)
ln.asm: 528:	8d 55 dc             	lea    -0x24(%ebp),%edx
ln.asm: 52b:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm:    buf[i++] = '-';
ln.asm:  while(--i >= 0)
ln.asm: 545:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
ln.asm: 549:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ln.asm: 550:	8b 5d fc             	mov    -0x4(%ebp),%ebx
ln.asm: 55b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ln.asm: 568:	89 45 e8             	mov    %eax,-0x18(%ebp)
ln.asm: 56b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ln.asm: 57a:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm: 58a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
ln.asm: 58d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ln.asm: 593:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ln.asm: 599:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
ln.asm: 5a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ln.asm: 5bf:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
ln.asm: 5c9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
ln.asm: 5cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
ln.asm: 5e4:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ln.asm: 5ed:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
ln.asm: 5f3:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
ln.asm: 5f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
ln.asm: 60e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ln.asm: 617:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
ln.asm: 61d:	8b 45 e8             	mov    -0x18(%ebp),%eax
ln.asm: 622:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm: 625:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ln.asm: 629:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ln.asm: 62f:	c7 45 f4 32 09 00 00 	movl   $0x932,-0xc(%ebp)
ln.asm: 638:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 650:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
ln.asm: 654:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 660:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
ln.asm: 666:	8b 45 e8             	mov    -0x18(%ebp),%eax
ln.asm: 67d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ln.asm: 683:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ln.asm: 689:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ln.asm: 6b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ln.asm: 6c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ln.asm: 6cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
ln.asm: 6d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm:  bp = (Header*)ap - 1;
ln.asm: 6f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ln.asm: 6fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ln.asm: 6ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 704:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ln.asm: 709:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 70c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ln.asm: 711:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 716:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ln.asm:  bp = (Header*)ap - 1;
ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ln.asm: 71b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 720:	89 45 fc             	mov    %eax,-0x4(%ebp)
ln.asm: 723:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 726:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ln.asm: 72b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 730:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ln.asm:  if(bp + bp->s.size == p->s.ptr){
ln.asm: 735:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 742:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 747:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm:    bp->s.size += p->s.ptr->s.size;
ln.asm: 750:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 756:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 760:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ln.asm: 766:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 76d:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm:    bp->s.ptr = p->s.ptr;
ln.asm: 774:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 779:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm:  if(p + p->s.size == bp){
ln.asm: 77e:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 78b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 790:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ln.asm:    p->s.size += bp->s.size;
ln.asm: 795:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 79b:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 7a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm:    p->s.ptr = bp->s.ptr;
ln.asm: 7a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
ln.asm: 7ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm:    p->s.ptr = bp;
ln.asm: 7b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 7b8:	8b 55 f8             	mov    -0x8(%ebp),%edx
ln.asm: 7bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
ln.asm: 7f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm:  if(p == (char*)-1)
ln.asm: 7f3:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
ln.asm: 800:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 803:	89 45 f0             	mov    %eax,-0x10(%ebp)
ln.asm:  hp->s.size = nu;
ln.asm: 806:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm: 80f:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ln.asm: 83a:	89 45 ec             	mov    %eax,-0x14(%ebp)
ln.asm: 842:	89 45 f0             	mov    %eax,-0x10(%ebp)
ln.asm: 845:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ln.asm: 84b:	c7 45 f0 bc 0b 00 00 	movl   $0xbbc,-0x10(%ebp)
ln.asm: 852:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ln.asm: 86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm: 873:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm:    if(p->s.size >= nunits){
ln.asm: 876:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 87c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ln.asm:      if(p->s.size == nunits)
ln.asm: 881:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 887:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ln.asm:        prevp->s.ptr = p->s.ptr;
ln.asm: 88c:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 891:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm:        p->s.size -= nunits;
ln.asm: 898:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 89e:	2b 45 ec             	sub    -0x14(%ebp),%eax
ln.asm: 8a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm:        p += p->s.size;
ln.asm: 8a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 8b2:	01 45 f4             	add    %eax,-0xc(%ebp)
ln.asm:        p->s.size = nunits;
ln.asm: 8b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 8b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
ln.asm: 8be:	8b 45 f0             	mov    -0x10(%ebp),%eax
ln.asm: 8c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 8d3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
ln.asm: 8db:	ff 75 ec             	pushl  -0x14(%ebp)
ln.asm: 8e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.asm: 8e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ln.asm: 8f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 8f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
ln.asm: 8fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
ln.asm: 901:	89 45 f4             	mov    %eax,-0xc(%ebp)
ln.d:ln.o: ln.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file ln.o matches
log.c:// the count of in-progress FS system calls and returns.
log.c:// The log is a physical re-do log containing disk blocks.
log.c:// The on-disk log format:
log.c:// Contents of the header block, used for both the on-disk header block
log.c:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
log.c:// Read the log header from disk into the in-memory log header
log.c:  struct logheader *lh = (struct logheader *) (buf->data);
log.c:  log.lh.n = lh->n;
log.c:    log.lh.block[i] = lh->block[i];
log.c:// Write in-memory log header to disk.
log.c:  struct logheader *hb = (struct logheader *) (buf->data);
log.c:  hb->n = log.lh.n;
log.c:    hb->block[i] = log.lh.block[i];
log.c:  log.outstanding -= 1;
log.c:    memmove(to->data, from->data, BSIZE);
log.c:    write_head();    // Write header to disk -- the real commit
log.c:// Caller has modified b->data and is done with the buffer.
log.c://   modify bp->data[]
log.c:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
log.c:    if (log.lh.block[i] == b->blockno)   // log absorbtion
log.c:  log.lh.block[i] = b->blockno;
log.c:  b->flags |= B_DIRTY; // prevent eviction
log.d:log.o: log.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file log.o matches
Binary file _ls matches
ls.asm:_ls:     file format elf32-i386
ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
ls.asm:  1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm:  21:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
ls.asm:  25:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm:  2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm:  37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
ls.asm:  // Return blank-padded name.
ls.asm:  3e:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm:  4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm:  56:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm:  65:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
ls.asm:  78:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm:  8f:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm:  b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
ls.asm:  d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
ls.asm:  d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
ls.asm:  fa:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
ls.asm: 101:	ff 75 e4             	pushl  -0x1c(%ebp)
ls.asm: 128:	ff 75 e4             	pushl  -0x1c(%ebp)
ls.asm: 138:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
ls.asm: 14e:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
ls.asm: 154:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
ls.asm: 15a:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
ls.asm: 1c2:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 1d4:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 1e5:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 1ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
ls.asm: 1f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
ls.asm: 1f6:	89 55 e0             	mov    %edx,-0x20(%ebp)
ls.asm: 201:	0f b7 85 d0 fd ff ff 	movzwl -0x230(%ebp),%eax
ls.asm: 217:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
ls.asm: 221:	ff 75 e0             	pushl  -0x20(%ebp)
ls.asm: 22c:	8b 45 e0             	mov    -0x20(%ebp),%eax
ls.asm: 238:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
ls.asm: 23f:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 255:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 26d:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
ls.asm: 273:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
ls.asm: 279:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
ls.asm: 286:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
ls.asm: 2b0:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
ls.asm: 2b7:	ff 75 e4             	pushl  -0x1c(%ebp)
ls.asm: 2cf:	ff 75 e4             	pushl  -0x1c(%ebp)
ls.asm: 2da:	8d 65 f4             	lea    -0xc(%ebp),%esp
ls.asm: 2e9:	ff 71 fc             	pushl  -0x4(%ecx)
ls.asm: 310:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
ls.asm: 319:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 336:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
ls.asm: 33a:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 375:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm: 397:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm:  return (uchar)*p - (uchar)*q;
ls.asm: 3e1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ls.asm: 3ea:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
ls.asm: 3ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
ls.asm: 3fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 425:	88 45 fc             	mov    %al,-0x4(%ebp)
ls.asm: 430:	3a 45 fc             	cmp    -0x4(%ebp),%al
ls.asm: 455:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ls.asm: 463:	8d 45 ef             	lea    -0x11(%ebp),%eax
ls.asm: 471:	89 45 f0             	mov    %eax,-0x10(%ebp)
ls.asm: 474:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ls.asm: 47a:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 480:	89 55 f4             	mov    %edx,-0xc(%ebp)
ls.asm: 48a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ls.asm: 490:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ls.asm: 498:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ls.asm: 4a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 4ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
ls.asm: 4d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm: 4d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ls.asm:    return -1;
ls.asm: 4ea:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm: 4f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
ls.asm: 4fb:	ff 75 f4             	pushl  -0xc(%ebp)
ls.asm: 506:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm: 511:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ls.asm:  sign = (*s == '-') ? -1 : 1;
ls.asm: 53e:	89 45 f8             	mov    %eax,-0x8(%ebp)
ls.asm:  if (*s == '+'  || *s == '-')
ls.asm:    n = n*10 + *s++ - '0';
ls.asm: 55b:	8b 55 fc             	mov    -0x4(%ebp),%edx
ls.asm: 57d:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm:  sign = (*s == '-') ? -1 : 1;
ls.asm:  if (*s == '+'  || *s == '-')
ls.asm:    n = n*10 + *s++ - '0';
ls.asm: 594:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: 597:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ls.asm: 5a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ls.asm:  sign = (*s == '-') ? -1 : 1;
ls.asm: 5d0:	89 45 f8             	mov    %eax,-0x8(%ebp)
ls.asm:  if (*s == '+'  || *s == '-')
ls.asm:    n = n*8 + *s++ - '0';
ls.asm: 5ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 60b:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm:  sign = (*s == '-') ? -1 : 1;
ls.asm:  if (*s == '+'  || *s == '-')
ls.asm:    n = n*8 + *s++ - '0';
ls.asm: 622:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: 625:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ls.asm: 634:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm: 63a:	89 45 f8             	mov    %eax,-0x8(%ebp)
ls.asm:  while(n-- > 0)
ls.asm: 63f:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 645:	89 55 fc             	mov    %edx,-0x4(%ebp)
ls.asm: 648:	8b 55 f8             	mov    -0x8(%ebp),%edx
ls.asm: 64e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
ls.asm:  while(n-- > 0)
ls.asm: 659:	8d 50 ff             	lea    -0x1(%eax),%edx
ls.asm:# Added calls - Evghenii
ls.asm: 759:	88 45 f4             	mov    %al,-0xc(%ebp)
ls.asm: 761:	8d 45 f4             	lea    -0xc(%ebp),%eax
ls.asm: 77a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ls.asm: 78d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
ls.asm:    x = -xx;
ls.asm: 799:	89 45 ec             	mov    %eax,-0x14(%ebp)
ls.asm: 7a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
ls.asm: 7a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ls.asm: 7ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
ls.asm: 7b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm: 7b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
ls.asm: 7ca:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
ls.asm: 7d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
ls.asm: 7db:	89 45 ec             	mov    %eax,-0x14(%ebp)
ls.asm: 7de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ls.asm: 7e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ls.asm:    buf[i++] = '-';
ls.asm: 7ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 7f0:	89 55 f4             	mov    %edx,-0xc(%ebp)
ls.asm: 7f3:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
ls.asm:  while(--i >= 0)
ls.asm: 7fa:	8d 55 dc             	lea    -0x24(%ebp),%edx
ls.asm: 7fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm:    buf[i++] = '-';
ls.asm:  while(--i >= 0)
ls.asm: 817:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
ls.asm: 81b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ls.asm: 822:	8b 5d fc             	mov    -0x4(%ebp),%ebx
ls.asm: 82d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ls.asm: 83a:	89 45 e8             	mov    %eax,-0x18(%ebp)
ls.asm: 83d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ls.asm: 84c:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm: 85c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
ls.asm: 85f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ls.asm: 865:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ls.asm: 86b:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
ls.asm: 877:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ls.asm: 891:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
ls.asm: 89b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
ls.asm: 8a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
ls.asm: 8b6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ls.asm: 8bf:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
ls.asm: 8c5:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
ls.asm: 8cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
ls.asm: 8e0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ls.asm: 8e9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
ls.asm: 8ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
ls.asm: 8f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm: 8f7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ls.asm: 8fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ls.asm: 901:	c7 45 f4 27 0c 00 00 	movl   $0xc27,-0xc(%ebp)
ls.asm: 90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 922:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
ls.asm: 926:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: 932:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
ls.asm: 938:	8b 45 e8             	mov    -0x18(%ebp),%eax
ls.asm: 94f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ls.asm: 955:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ls.asm: 95b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ls.asm: 982:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ls.asm: 997:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ls.asm: 99e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
ls.asm: 9a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm:  bp = (Header*)ap - 1;
ls.asm: 9c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ls.asm: 9cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ls.asm: 9d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 9d6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ls.asm: 9db:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: 9de:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ls.asm: 9e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 9e8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ls.asm:  bp = (Header*)ap - 1;
ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ls.asm: 9ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: 9f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
ls.asm: 9f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: 9f8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ls.asm: 9fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a02:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ls.asm:  if(bp + bp->s.size == p->s.ptr){
ls.asm: a07:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: a14:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: a19:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm:    bp->s.size += p->s.ptr->s.size;
ls.asm: a22:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a32:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ls.asm: a38:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm:    bp->s.ptr = p->s.ptr;
ls.asm: a46:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm:  if(p + p->s.size == bp){
ls.asm: a50:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a62:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ls.asm:    p->s.size += bp->s.size;
ls.asm: a67:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: a75:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm:    p->s.ptr = bp->s.ptr;
ls.asm: a7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
ls.asm: a80:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm:    p->s.ptr = bp;
ls.asm: a87:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: a8a:	8b 55 f8             	mov    -0x8(%ebp),%edx
ls.asm: a8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
ls.asm: ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm:  if(p == (char*)-1)
ls.asm: ac5:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
ls.asm: ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: ad5:	89 45 f0             	mov    %eax,-0x10(%ebp)
ls.asm:  hp->s.size = nu;
ls.asm: ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm: ae1:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ls.asm: b0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
ls.asm: b14:	89 45 f0             	mov    %eax,-0x10(%ebp)
ls.asm: b17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ls.asm: b1d:	c7 45 f0 14 0f 00 00 	movl   $0xf14,-0x10(%ebp)
ls.asm: b24:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ls.asm: b40:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm: b45:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm:    if(p->s.size >= nunits){
ls.asm: b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b4e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ls.asm:      if(p->s.size == nunits)
ls.asm: b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b59:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ls.asm:        prevp->s.ptr = p->s.ptr;
ls.asm: b5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b63:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm:        p->s.size -= nunits;
ls.asm: b6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b70:	2b 45 ec             	sub    -0x14(%ebp),%eax
ls.asm: b75:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm:        p += p->s.size;
ls.asm: b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b84:	01 45 f4             	add    %eax,-0xc(%ebp)
ls.asm:        p->s.size = nunits;
ls.asm: b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: b8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
ls.asm: b90:	8b 45 f0             	mov    -0x10(%ebp),%eax
ls.asm: b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: ba5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
ls.asm: bad:	ff 75 ec             	pushl  -0x14(%ebp)
ls.asm: bb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.asm: bbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ls.asm: bc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: bcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
ls.asm: bce:	8b 45 f4             	mov    -0xc(%ebp),%eax
ls.asm: bd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
ls.c:  // Return blank-padded name.
ls.c:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
ls.d:ls.o: ls.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h fs.h
Binary file ls.o matches
main.c:  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
main.c:  cprintf("cpu%d: starting\n", cpu->id);
main.c:  xchg(&cpu->started, 1); // tell startothers() we're up
main.c:// Start the non-boot (AP) processors.
main.c:    *(void**)(code-4) = stack + KSTACKSIZE;
main.c:    *(void**)(code-8) = mpenter;
main.c:    *(int**)(code-12) = (void *) v2p(entrypgdir);
main.c:    lapicstartap(c->id, v2p(code));
main.c:    while(c->started == 0)
main.d:main.o: main.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file main.o matches
Makefile:# 0 == original xv6-pdx distribution functionality
Makefile:CS333_CFLAGS += -DCS333_P4
Makefile:CS333_CFLAGS += -DPRINT_SYSCALLS
Makefile:CS333_CFLAGS += -DCS333_P1
Makefile:CS333_CFLAGS += -DCS333_P1 -DUSE_BUILTINS -DCS333_P2
Makefile:CS333_CFLAGS += -DCS333_P1 -DUSE_BUILTINS -DCS333_P2 -DCS333_P3P4
Makefile:CS333_CFLAGS += -DUSE_BUILTINS -DCS333_P1 -DCS333_P2 \
Makefile:		-DCS333_P3P4 -DCS333_P5
Makefile:# CS333_CFLAGS += -DCS333_P1 -DUSE_BUILTINS -DCS333_P2 -DCS333_P5
Makefile:CS333_TPROGS += # _p5-test _testsetuid
Makefile:CS333_MKFSFLAGS += -DCS333_P2 -DCS333_P5
Makefile:TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
Makefile:	then echo 'i386-jos-elf-'; \
Makefile:	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
Makefile:	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
Makefile:	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
Makefile:	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
Makefile:	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
Makefile:# QEMU = qemu-system-i386
Makefile:	elif which qemu-system-i386 > /dev/null; \
Makefile:	then echo qemu-system-i386; exit; \
Makefile:	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
Makefile:	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
Makefile:CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking \
Makefile:   -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
Makefile:CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null \
Makefile:   >/dev/null 2>&1 && echo -fno-stack-protector)
Makefile:ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
Makefile:LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
Makefile:	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
Makefile:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
Makefile:	$(OBJDUMP) -S bootblock.o > bootblock.asm
Makefile:	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
Makefile:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
Makefile:	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
Makefile:	$(OBJDUMP) -S bootblockother.o > entryother.asm
Makefile:	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
Makefile:	$(OBJCOPY) -S -O binary initcode.out initcode
Makefile:	$(OBJDUMP) -S initcode.o > initcode.asm
Makefile:	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
Makefile:	$(OBJDUMP) -S kernel > kernel.asm
Makefile:	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
Makefile:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
Makefile:	$(OBJDUMP) -S $@ > $*.asm
Makefile:	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
Makefile:	# forktest has less library code linked in - needs to be small
Makefile:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
Makefile:	$(OBJDUMP) -S _forktest > forktest.asm
Makefile:	gcc -Werror -Wall $(CS333_MKFSFLAGS) -o mkfs mkfs.c
Makefile:# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
Makefile:fs.img: mkfs README README-PSU $(UPROGS)
Makefile:	./mkfs fs.img README README-PSU $(UPROGS)
Makefile:-include *.d
Makefile:	rm -rf *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
Makefile:	fmt LucidaSans* dist* xv6.pdf xv6-pdx.tar.gz
Makefile:	rm -f *~ \#*\#
Makefile:	rm -f *~ \#*\#
Makefile:FILES = $(shell grep -v '^\#' runoff.list)
Makefile:PRINT = runoff.list runoff.spec README README-PSU toc.hdr toc.ftr $(FILES)
Makefile:	ls -l xv6.pdf
Makefile:	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
Makefile:	bochs -q
Makefile:GDBPORT = $(shell expr `id -u` % 5000 + 25000)
Makefile:QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
Makefile:	then echo "-gdb tcp::$(GDBPORT)"; \
Makefile:	else echo "-s -p $(GDBPORT)"; fi)
Makefile:QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
Makefile:qemu-nox: fs.img xv6.img 
Makefile:	$(QEMU) -nographic $(QEMUOPTS)
Makefile:qemu-nox-gdb: fs.img xv6.img .gdbinit 
Makefile:	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
Makefile:	README README-PSU dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
Makefile:	rm -rf dist
Makefile:		grep -v PAGEBREAK $$i >dist/$$i; \
Makefile:dist-test-nox:
Makefile:	rm -rf dist
Makefile:	rm -rf dist-test
Makefile:	mkdir dist-test
Makefile:	cp dist/* dist-test
Makefile:	cd dist-test; $(MAKE) qemu-nox
Makefile:	(tar cf - dist) | gzip >xv6-pdx.tar.gz
Makefile:.PHONY: dist-test dist dist-test-nox
memide.c:  // no-op
memide.c:  if(!(b->flags & B_BUSY))
memide.c:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
memide.c:  if(b->dev != 1)
memide.c:  if(b->blockno >= disksize)
memide.c:  p = memdisk + b->blockno*BSIZE;
memide.c:  if(b->flags & B_DIRTY){
memide.c:    b->flags &= ~B_DIRTY;
memide.c:    memmove(p, b->data, BSIZE);
memide.c:    memmove(b->data, p, BSIZE);
memide.c:  b->flags |= B_VALID;
memlayout.h:static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
memlayout.h:#define V2P(a) (((uint) (a)) - KERNBASE)
memlayout.h:#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
Binary file _mkdir matches
mkdir.asm:_mkdir:     file format elf32-i386
mkdir.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
mkdir.asm:  30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
mkdir.asm:  39:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm:  5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm:  80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
mkdir.asm:  84:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm:  bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm:  e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm:  return (uchar)*p - (uchar)*q;
mkdir.asm: 12b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
mkdir.asm: 134:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
mkdir.asm: 138:	8b 55 fc             	mov    -0x4(%ebp),%edx
mkdir.asm: 147:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 16f:	88 45 fc             	mov    %al,-0x4(%ebp)
mkdir.asm: 17a:	3a 45 fc             	cmp    -0x4(%ebp),%al
mkdir.asm: 19f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
mkdir.asm: 1ad:	8d 45 ef             	lea    -0x11(%ebp),%eax
mkdir.asm: 1bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
mkdir.asm: 1be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
mkdir.asm: 1c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 1ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
mkdir.asm: 1d4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
mkdir.asm: 1da:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
mkdir.asm: 1e2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
mkdir.asm: 1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 1f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
mkdir.asm: 21e:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm: 221:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
mkdir.asm:    return -1;
mkdir.asm: 234:	ff 75 f4             	pushl  -0xc(%ebp)
mkdir.asm: 23f:	89 45 f0             	mov    %eax,-0x10(%ebp)
mkdir.asm: 245:	ff 75 f4             	pushl  -0xc(%ebp)
mkdir.asm: 250:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm: 25b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
mkdir.asm:  sign = (*s == '-') ? -1 : 1;
mkdir.asm: 288:	89 45 f8             	mov    %eax,-0x8(%ebp)
mkdir.asm:  if (*s == '+'  || *s == '-')
mkdir.asm:    n = n*10 + *s++ - '0';
mkdir.asm: 2a5:	8b 55 fc             	mov    -0x4(%ebp),%edx
mkdir.asm: 2c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm:  sign = (*s == '-') ? -1 : 1;
mkdir.asm:  if (*s == '+'  || *s == '-')
mkdir.asm:    n = n*10 + *s++ - '0';
mkdir.asm: 2de:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 2e1:	0f af 45 fc          	imul   -0x4(%ebp),%eax
mkdir.asm: 2ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
mkdir.asm:  sign = (*s == '-') ? -1 : 1;
mkdir.asm: 31a:	89 45 f8             	mov    %eax,-0x8(%ebp)
mkdir.asm:  if (*s == '+'  || *s == '-')
mkdir.asm:    n = n*8 + *s++ - '0';
mkdir.asm: 337:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 355:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm:  sign = (*s == '-') ? -1 : 1;
mkdir.asm:  if (*s == '+'  || *s == '-')
mkdir.asm:    n = n*8 + *s++ - '0';
mkdir.asm: 36c:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 36f:	0f af 45 fc          	imul   -0x4(%ebp),%eax
mkdir.asm: 37e:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm: 384:	89 45 f8             	mov    %eax,-0x8(%ebp)
mkdir.asm:  while(n-- > 0)
mkdir.asm: 389:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 38f:	89 55 fc             	mov    %edx,-0x4(%ebp)
mkdir.asm: 392:	8b 55 f8             	mov    -0x8(%ebp),%edx
mkdir.asm: 398:	89 4d f8             	mov    %ecx,-0x8(%ebp)
mkdir.asm:  while(n-- > 0)
mkdir.asm: 3a3:	8d 50 ff             	lea    -0x1(%eax),%edx
mkdir.asm:# Added calls - Evghenii
mkdir.asm: 4a3:	88 45 f4             	mov    %al,-0xc(%ebp)
mkdir.asm: 4ab:	8d 45 f4             	lea    -0xc(%ebp),%eax
mkdir.asm: 4c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
mkdir.asm: 4d7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
mkdir.asm:    x = -xx;
mkdir.asm: 4e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
mkdir.asm: 4eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
mkdir.asm: 4ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
mkdir.asm: 4f5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
mkdir.asm: 4fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm: 501:	8b 45 ec             	mov    -0x14(%ebp),%eax
mkdir.asm: 514:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
mkdir.asm: 51b:	8b 45 ec             	mov    -0x14(%ebp),%eax
mkdir.asm: 525:	89 45 ec             	mov    %eax,-0x14(%ebp)
mkdir.asm: 528:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
mkdir.asm: 52e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
mkdir.asm:    buf[i++] = '-';
mkdir.asm: 534:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 53a:	89 55 f4             	mov    %edx,-0xc(%ebp)
mkdir.asm: 53d:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
mkdir.asm:  while(--i >= 0)
mkdir.asm: 544:	8d 55 dc             	lea    -0x24(%ebp),%edx
mkdir.asm: 547:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm:    buf[i++] = '-';
mkdir.asm:  while(--i >= 0)
mkdir.asm: 561:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
mkdir.asm: 565:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
mkdir.asm: 56c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
mkdir.asm: 577:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
mkdir.asm: 584:	89 45 e8             	mov    %eax,-0x18(%ebp)
mkdir.asm: 587:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
mkdir.asm: 596:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm: 5a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
mkdir.asm: 5a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
mkdir.asm: 5af:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
mkdir.asm: 5b5:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
mkdir.asm: 5c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
mkdir.asm: 5db:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
mkdir.asm: 5e5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
mkdir.asm: 5eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
mkdir.asm: 600:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
mkdir.asm: 609:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
mkdir.asm: 60f:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
mkdir.asm: 615:	8b 45 e8             	mov    -0x18(%ebp),%eax
mkdir.asm: 62a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
mkdir.asm: 633:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
mkdir.asm: 639:	8b 45 e8             	mov    -0x18(%ebp),%eax
mkdir.asm: 63e:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm: 641:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
mkdir.asm: 645:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
mkdir.asm: 64b:	c7 45 f4 5a 09 00 00 	movl   $0x95a,-0xc(%ebp)
mkdir.asm: 654:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 66c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
mkdir.asm: 670:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 67c:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
mkdir.asm: 682:	8b 45 e8             	mov    -0x18(%ebp),%eax
mkdir.asm: 699:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
mkdir.asm: 69f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
mkdir.asm: 6a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
mkdir.asm: 6cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
mkdir.asm: 6e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
mkdir.asm: 6e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
mkdir.asm: 6ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm:  bp = (Header*)ap - 1;
mkdir.asm: 70e:	89 45 f8             	mov    %eax,-0x8(%ebp)
mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
mkdir.asm: 716:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
mkdir.asm: 71b:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 720:	3b 45 fc             	cmp    -0x4(%ebp),%eax
mkdir.asm: 725:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 728:	3b 45 fc             	cmp    -0x4(%ebp),%eax
mkdir.asm: 72d:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 732:	3b 45 f8             	cmp    -0x8(%ebp),%eax
mkdir.asm:  bp = (Header*)ap - 1;
mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
mkdir.asm: 737:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 73c:	89 45 fc             	mov    %eax,-0x4(%ebp)
mkdir.asm: 73f:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 742:	3b 45 fc             	cmp    -0x4(%ebp),%eax
mkdir.asm: 747:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 74c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
mkdir.asm: 751:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 763:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm:    bp->s.size += p->s.ptr->s.size;
mkdir.asm: 76c:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 772:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 77c:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
mkdir.asm: 782:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 789:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm:    bp->s.ptr = p->s.ptr;
mkdir.asm: 790:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 795:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm:  if(p + p->s.size == bp){
mkdir.asm: 79a:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 7a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 7ac:	3b 45 f8             	cmp    -0x8(%ebp),%eax
mkdir.asm:    p->s.size += bp->s.size;
mkdir.asm: 7b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 7b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 7bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm:    p->s.ptr = bp->s.ptr;
mkdir.asm: 7c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
mkdir.asm: 7ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm:    p->s.ptr = bp;
mkdir.asm: 7d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 7d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
mkdir.asm: 7d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
mkdir.asm: 80c:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm:  if(p == (char*)-1)
mkdir.asm: 80f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
mkdir.asm: 81c:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 81f:	89 45 f0             	mov    %eax,-0x10(%ebp)
mkdir.asm:  hp->s.size = nu;
mkdir.asm: 822:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm: 82b:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
mkdir.asm: 856:	89 45 ec             	mov    %eax,-0x14(%ebp)
mkdir.asm: 85e:	89 45 f0             	mov    %eax,-0x10(%ebp)
mkdir.asm: 861:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
mkdir.asm: 867:	c7 45 f0 e4 0b 00 00 	movl   $0xbe4,-0x10(%ebp)
mkdir.asm: 86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
mkdir.asm: 88a:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm: 88f:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm:    if(p->s.size >= nunits){
mkdir.asm: 892:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 898:	3b 45 ec             	cmp    -0x14(%ebp),%eax
mkdir.asm:      if(p->s.size == nunits)
mkdir.asm: 89d:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
mkdir.asm:        prevp->s.ptr = p->s.ptr;
mkdir.asm: 8a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm:        p->s.size -= nunits;
mkdir.asm: 8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8ba:	2b 45 ec             	sub    -0x14(%ebp),%eax
mkdir.asm: 8bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm:        p += p->s.size;
mkdir.asm: 8c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8ce:	01 45 f4             	add    %eax,-0xc(%ebp)
mkdir.asm:        p->s.size = nunits;
mkdir.asm: 8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
mkdir.asm: 8da:	8b 45 f0             	mov    -0x10(%ebp),%eax
mkdir.asm: 8e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 8ef:	39 45 f4             	cmp    %eax,-0xc(%ebp)
mkdir.asm: 8f7:	ff 75 ec             	pushl  -0x14(%ebp)
mkdir.asm: 902:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.asm: 905:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
mkdir.asm: 912:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 915:	89 45 f0             	mov    %eax,-0x10(%ebp)
mkdir.asm: 918:	8b 45 f4             	mov    -0xc(%ebp),%eax
mkdir.asm: 91d:	89 45 f4             	mov    %eax,-0xc(%ebp)
mkdir.d:mkdir.o: mkdir.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file mkdir.o matches
Binary file mkfs matches
mkfs.c:  nblocks = FSSIZE - nmeta;
mkfs.c:      if(indirect[fbn - NDIRECT] == 0){
mkfs.c:        indirect[fbn - NDIRECT] = xint(freeblock++);
mkfs.c:      x = xint(indirect[fbn-NDIRECT]);
mkfs.c:    n1 = min(n, (fbn + 1) * BSIZE - off);
mkfs.c:    bcopy(p, buf + off - (fbn * BSIZE), n1);
mkfs.c:    n -= n1;
mmu.h:#define SEG_KCPU  3  // kernel per-cpu data
mmu.h:  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
mmu.h:#define STA_E       0x4     // Expand down (non-executable segments)
mmu.h:#define STA_W       0x2     // Writeable (non-executable segments)
mmu.h:#define STS_T16A    0x1     // Available 16-bit TSS
mmu.h:#define STS_T16B    0x3     // Busy 16-bit TSS
mmu.h:#define STS_CG16    0x4     // 16-bit Call Gate
mmu.h:#define STS_IG16    0x6     // 16-bit Interrupt Gate
mmu.h:#define STS_TG16    0x7     // 16-bit Trap Gate
mmu.h:#define STS_T32A    0x9     // Available 32-bit TSS
mmu.h:#define STS_T32B    0xB     // Busy 32-bit TSS
mmu.h:#define STS_CG32    0xC     // 32-bit Call Gate
mmu.h:#define STS_IG32    0xE     // 32-bit Interrupt Gate
mmu.h:#define STS_TG32    0xF     // 32-bit Trap Gate
mmu.h:// A virtual address 'la' has a three-part structure as follows:
mmu.h:// +--------10------+-------10-------+---------12----------+
mmu.h:// +----------------+----------------+---------------------+
mmu.h://  \--- PDX(va) --/ \--- PTX(va) --/ 
mmu.h:#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
mmu.h:#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
mmu.h:#define PTE_PWT         0x008   // Write-Through
mmu.h:#define PTE_PCD         0x010   // Cache-Disable
mmu.h:// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
mmu.h:// - sel: Code segment selector for interrupt/trap handler
mmu.h:// - off: Offset in code segment for interrupt/trap handler
mmu.h:// - dpl: Descriptor Privilege Level -
mp.c:  return bcpu-cpus;
mp.c:    if((mp = mpsearch1(p-1024, 1024)))
mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
mp.c:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
mp.c:  if(conf->version != 1 && conf->version != 4)
mp.c:  if(sum((uchar*)conf, conf->length) != 0)
mp.c:  lapic = (uint*)conf->lapicaddr;
mp.c:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
mp.c:      if(ncpu != proc->apicid){
mp.c:        cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
mp.c:      if(proc->flags & MPBOOT)
mp.c:      ioapicid = ioapic->apicno;
mp.c:  if(mp->imcrp){
mp.d:mp.o: mp.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file mp.o matches
Notes:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
Notes:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
Notes:sector-aligned. so you can't use ld -N. and the sections may also need
Notes:to be non-zero length, only really matters for tiny "kernels".
Notes:perhaps have fixed-size stack, put it in the data segment?
Notes:test out-of-fd cases for creating pipe.
Notes:  per-fd lock *just* protects count read-modify-write
Notes:in general, the table locks protect both free-ness and
Notes:  per-pipe lock
Notes:what does inode->busy mean?
Notes:  no-one is allowed to do anything to the inode
Notes:inode->count counts in-memory pointers to the struct
Notes:  prevents inode[] element from being re-used
Notes:blocks and inodes have ad-hoc sleep-locks
Notes:test: dup() shared fd->off
Notes:sh: stop stdin on ctrl-d (for cat > y)
p5-test.c:// P5 adds protection (via UNIX-like mode bits) to xv6. This 
p5-test.c:#include "p5-test.h"
p5-test.c:      if (i != NUMPERMSTOCHECK-1) printf(2, "**** exec call for %s **FAILED**.\n",  cmd[0]);
p5-test.c:  int baduids[] = {32767+5, -41, ~0};  // 32767 is max value
p5-test.c:  int badgids[] = {32767+5, -41, ~0};  // 32767 is max value
p5-test.c:    if (i != NUMPERMSTOCHECK-1)
p5-test.c:      if (i != NUMPERMSTOCHECK-1) printf(2, "**** exec call for %s **FAILED**.\n",  cmd[0]);
p5-test.h:  // {proc-uid, proc-gid, file-uid, file-gid}
param.h:#define KSTACKSIZE 4096  // size of per-process kernel stack
param.h:#define NINODE       50  // maximum number of active i-nodes
param.h:#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
picirq.c:#define IO_PIC1         0x20    // Master (IRQs 0-7)
picirq.c:#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
picirq.c:  // Set up master (8259A-1)
picirq.c:  //        (slave PIC) 3-bit # of slave's connection to master
picirq.c:  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
picirq.c:  // Set up slave (8259A-2)
picirq.d:picirq.o: picirq.c /usr/include/stdc-predef.h RMME.h types.h x86.h \
Binary file picirq.o matches
pipe.c:  p->readopen = 1;
pipe.c:  p->writeopen = 1;
pipe.c:  p->nwrite = 0;
pipe.c:  p->nread = 0;
pipe.c:  initlock(&p->lock, "pipe");
pipe.c:  (*f0)->type = FD_PIPE;
pipe.c:  (*f0)->readable = 1;
pipe.c:  (*f0)->writable = 0;
pipe.c:  (*f0)->pipe = p;
pipe.c:  (*f1)->type = FD_PIPE;
pipe.c:  (*f1)->readable = 0;
pipe.c:  (*f1)->writable = 1;
pipe.c:  (*f1)->pipe = p;
pipe.c:  return -1;
pipe.c:  acquire(&p->lock);
pipe.c:    p->writeopen = 0;
pipe.c:    wakeup(&p->nread);
pipe.c:    p->readopen = 0;
pipe.c:    wakeup(&p->nwrite);
pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
pipe.c:    release(&p->lock);
pipe.c:    release(&p->lock);
pipe.c:  acquire(&p->lock);
pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
pipe.c:      if(p->readopen == 0 || proc->killed){
pipe.c:        release(&p->lock);
pipe.c:        return -1;
pipe.c:      wakeup(&p->nread);
pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
pipe.c:  release(&p->lock);
pipe.c:  acquire(&p->lock);
pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
pipe.c:    if(proc->killed){
pipe.c:      release(&p->lock);
pipe.c:      return -1;
pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
pipe.c:  for(i = 0; i < n; i++){  //DOC: piperead-copy
pipe.c:    if(p->nread == p->nwrite)
pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
pipe.c:  release(&p->lock);
pipe.d:pipe.o: pipe.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file pipe.o matches
printf.c:    x = -xx;
printf.c:    buf[i++] = '-';
printf.c:  while(--i >= 0)
printf.d:printf.o: printf.c /usr/include/stdc-predef.h RMME.h types.h stat.h \
Binary file printf.o matches
print_mode.c:  switch (st->type) {
print_mode.c:    case T_FILE: printf(1, "-"); break;
print_mode.c:  if (st->mode.flags.u_r)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.u_w)
print_mode.c:    printf(1, "-");
print_mode.c:  if ((st->mode.flags.u_x) & (st->mode.flags.setuid))
print_mode.c:  else if (st->mode.flags.u_x)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.g_r)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.g_w)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.g_x)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.o_r)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.o_w)
print_mode.c:    printf(1, "-");
print_mode.c:  if (st->mode.flags.o_x)
print_mode.c:    printf(1, "-");
printpcs:for p in i386-jos-elf-addr2line addr2line; do
printpcs:       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
printpcs:# Enable as much pretty-printing as this addr2line can do
printpcs:$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
proc.c:    if(p->state == UNUSED)
proc.c:  p->state = EMBRYO;
proc.c:  p->pid = nextpid++;
proc.c:  if((p->kstack = kalloc()) == 0){
proc.c:    p->state = UNUSED;
proc.c:    p->state = UNUSED;
proc.c:  sp = p->kstack + KSTACKSIZE;
proc.c:  sp -= sizeof *p->tf;
proc.c:  p->tf = (struct trapframe*)sp;
proc.c:  sp -= 4;
proc.c:  sp -= sizeof *p->context;
proc.c:  p->context = (struct context*)sp;
proc.c:  memset(p->context, 0, sizeof *p->context);
proc.c:  p->context->eip = (uint)forkret;
proc.c:  p->start_ticks = ticks;
proc.c:  p->cpu_ticks_in = 0;
proc.c:  p->cpu_ticks_total = 0;
proc.c:  for (int i = 0; i < NPROC - 1; i++) {
proc.c:  if((p->pgdir = setupkvm()) == 0)
proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
proc.c:  p->sz = PGSIZE;
proc.c:  memset(p->tf, 0, sizeof(*p->tf));
proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
proc.c:  p->tf->es = p->tf->ds;
proc.c:  p->tf->ss = p->tf->ds;
proc.c:  p->tf->eflags = FL_IF;
proc.c:  p->tf->esp = PGSIZE;
proc.c:  p->tf->eip = 0;  // beginning of initcode.S
proc.c:  p->uid = DEFUID;
proc.c:  p->gid = DEFGID;
proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
proc.c:  p->cwd = namei("/");
proc.c:  p->state = RUNNABLE;
proc.c:// Return 0 on success, -1 on failure.
proc.c:  sz = proc->sz;
proc.c:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
proc.c:      return -1;
proc.c:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
proc.c:      return -1;
proc.c:  proc->sz = sz;
proc.c:    return -1;
proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
proc.c:    kfree(np->kstack);
proc.c:    np->kstack = 0;
proc.c:    np->state = UNUSED;
proc.c:    return -1;
proc.c:  np->sz = proc->sz;
proc.c:  np->parent = proc;
proc.c:  *np->tf = *proc->tf;
proc.c:  np->tf->eax = 0;
proc.c:    if(proc->ofile[i])
proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
proc.c:  np->cwd = idup(proc->cwd);
proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
proc.c:  pid = np->pid;
proc.c:  np->uid = proc->uid;
proc.c:  np->gid = proc->gid;
proc.c:  // lock to force the compiler to emit the np->state write last.
proc.c:  np->state = RUNNABLE;
proc.c:    return -1;
proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
proc.c:    kfree(np->kstack);
proc.c:    np->kstack = 0;
proc.c:    np->state = UNUSED;
proc.c:    return -1;
proc.c:  np->sz = proc->sz;
proc.c:  np->parent = proc;
proc.c:  *np->tf = *proc->tf;
proc.c:  np->tf->eax = 0;
proc.c:    if(proc->ofile[i])
proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
proc.c:  np->cwd = idup(proc->cwd);
proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
proc.c:  pid = np->pid;
proc.c:  np->uid = proc->uid;
proc.c:  np->gid = proc->gid;
proc.c:  // lock to force the compiler to emit the np->state write last.
proc.c:  np->state = RUNNABLE;
proc.c:    if(proc->ofile[fd]){
proc.c:      fileclose(proc->ofile[fd]);
proc.c:      proc->ofile[fd] = 0;
proc.c:  iput(proc->cwd);
proc.c:  proc->cwd = 0;
proc.c:  wakeup1(proc->parent);
proc.c:    if(p->parent == proc){
proc.c:      p->parent = initproc;
proc.c:      if(p->state == ZOMBIE)
proc.c:  proc->state = ZOMBIE;
proc.c:    if(proc->ofile[fd]){
proc.c:      fileclose(proc->ofile[fd]);
proc.c:      proc->ofile[fd] = 0;
proc.c:  iput(proc->cwd);
proc.c:  proc->cwd = 0;
proc.c:  wakeup1(proc->parent);
proc.c:      if(p->parent == proc) {
proc.c:        p->parent = initproc;
proc.c:        if(p->state == ZOMBIE)
proc.c:          cprintf("ZZZZZ: %d\n", p->pid);
proc.c:      p = p->next;
proc.c:  proc->state = ZOMBIE;
proc.c:// Return -1 if this process has no children.
proc.c:      if(p->parent != proc)
proc.c:      if(p->state == ZOMBIE){
proc.c:        pid = p->pid;
proc.c:        kfree(p->kstack);
proc.c:        p->kstack = 0;
proc.c:        freevm(p->pgdir);
proc.c:        p->state = UNUSED;
proc.c:        p->pid = 0;
proc.c:        p->parent = 0;
proc.c:        p->name[0] = 0;
proc.c:        p->killed = 0;
proc.c:    if(!havekids || proc->killed){
proc.c:      return -1;
proc.c:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
proc.c:        if(p->parent == proc) {
proc.c:          if (p->state == ZOMBIE) {
proc.c:            pid = p->pid;
proc.c:            kfree(p->kstack);
proc.c:            p->kstack = 0;
proc.c:            freevm(p->pgdir);
proc.c:            p->pid = 0;
proc.c:            p->parent = 0;
proc.c:            p->name[0] = 0;
proc.c:            p->killed = 0;
proc.c:            cprintf("REMOVED ZOMBIE: %d", p->pid);
proc.c:            p->state = UNUSED;
proc.c:        p = p->next;
proc.c:    if(!havekids || proc->killed){
proc.c:      return -1;
proc.c:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
proc.c:// Per-CPU process scheduler.
proc.c://  - choose a process to run
proc.c://  - swtch to start running that process
proc.c://  - eventually that process transfers control
proc.c:      if(p->state != RUNNABLE)
proc.c:      p->state = RUNNING;
proc.c:      p->cpu_ticks_in = ticks;
proc.c:      swtch(&cpu->scheduler, proc->context);
proc.c:      // It should have changed its p->state before coming back.
proc.c:      p->state = RUNNING;
proc.c:      p->cpu_ticks_in = ticks;
proc.c:      swtch(&cpu->scheduler, proc->context);
proc.c:      // It should have changed its p->state before coming back.
proc.c:// and have changed proc->state.
proc.c:  if(cpu->ncli != 1)
proc.c:  if(proc->state == RUNNING)
proc.c:  intena = cpu->intena;
proc.c:  proc->cpu_ticks_total += (ticks - proc->cpu_ticks_in);   // Update total cpu time
proc.c:  swtch(&proc->context, cpu->scheduler);
proc.c:  cpu->intena = intena;
proc.c:  if(cpu->ncli != 1)
proc.c:  if(proc->state == RUNNING)
proc.c:  intena = cpu->intena;
proc.c:  proc->cpu_ticks_total += (ticks - proc->cpu_ticks_in);   // Update total cpu time
proc.c:  swtch(&proc->context, cpu->scheduler);
proc.c:  cpu->intena = intena;
proc.c:  proc->state = RUNNABLE;
proc.c:  proc->state = RUNNABLE;
proc.c:  // change p->state and then call sched.
proc.c:  proc->chan = chan;
proc.c:  proc->state = SLEEPING;
proc.c:  proc->chan = 0;
proc.c:  // change p->state and then call sched.
proc.c:  proc->chan = chan;
proc.c:  proc->state = SLEEPING;
proc.c:  proc->chan = 0;
proc.c:    if(p->state == SLEEPING && p->chan == chan)
proc.c:      p->state = RUNNABLE;
proc.c:  int i = -1;
proc.c:  while(p && i <= NPROC - 1) {
proc.c:    if(p->chan == chan) {
proc.c:    p = p->next;
proc.c:    p->state = RUNNABLE;
proc.c:    if(p->pid == pid){
proc.c:      p->killed = 1;
proc.c:      if(p->state == SLEEPING)
proc.c:        p->state = RUNNABLE;
proc.c:  return -1;p->killed
proc.c:      if(p->pid == pid) {
proc.c:        p->killed = 1;
proc.c:        if(p->state == SLEEPING) {
proc.c:          p->state = RUNNABLE;
proc.c:      p = p->next;
proc.c:  return -1;
proc.c:    if(p->state == UNUSED)
proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
proc.c:      state = states[p->state];
proc.c:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
proc.c:      elaps       = (ticks - p->start_ticks);
proc.c:      cputick_1   = p->cpu_ticks_total/1000;       // CPU time in seconds
proc.c:      cputick_10  = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
proc.c:      if(p->pid == 1)
proc.c:        ppid = p->parent->pid;
proc.c:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
proc.c:              elaps_1, elaps_10, elaps_100, elaps_1000, cputick_1, cputick_10, state, p->sz);
proc.c:    if(p->state == SLEEPING){
proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
proc.c:    return -1;
proc.c:    if(p->state != EMBRYO && p->state != UNUSED) {
proc.c:      procs->pid = p->pid;
proc.c:      procs->uid = p->uid;
proc.c:      procs->gid = p->gid;
proc.c:      if(p->pid == 1)
proc.c:        procs->ppid = 1;
proc.c:        procs->ppid = p->parent->pid;
proc.c:      procs->elapsed_ticks = ticks - p->start_ticks;
proc.c:      procs->CPU_total_ticks = p->cpu_ticks_total;
proc.c:      procs->size = p->sz;
proc.c:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
proc.c:      safestrcpy(procs->name, p->name, sizeof(procs->name));
proc.c:  while(p->next) {
proc.c:    cprintf("%d -> ", p->pid);
proc.c:    p = p->next;
proc.c:  cprintf("%d\n", p->pid);
proc.c:      ppid = p->parent->pid;  // Get PPID of proc is not init
proc.c:    cprintf("(%d,%d)", p->pid, ppid);
proc.c:    if(p->next) {
proc.c:      cprintf(" -> ");
proc.c:    p = p->next;
proc.c:    p = p->next;
proc.c:    cprintf("Attempted to remove proc with state \'%s\' from a \'%s\' state list.", states[state], states[(*list)->state]);
proc.c:  *list = (*list)->next;
proc.c:  p->next = 0;
proc.c:    while(curr->next)
proc.c:      curr = curr->next;
proc.c:    curr->next = proc;
proc.c:  proc->next = *list;
proc.c:  if(proc->state != state) {
proc.c:    cprintf("Attempted to remove \'%s\' proc from a state list. Actual state: %s.\n", states[state], states[proc->state]);
proc.c:    while(curr != proc && curr->next) {
proc.c:      curr = curr->next;
proc.c:        *list = (*list)->next;  // Removing proc from the head
proc.c:        prev->next = curr->next; // Removing proc from elsewhere
proc.c:      curr->next = 0;
proc.c:    if(proc->state == state)
proc.d:proc.o: proc.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
proc.h:// Segments in proc->gdt.
proc.h:// Per-CPU state
proc.h:  // Cpu-local storage variables; see below
proc.h:  struct proc *proc;           // The currently-running process.
proc.h:// Per-CPU variables, holding pointers to the
proc.h:// This is similar to how thread-local variables are implemented
proc.h:// Per-process state
proc.h:  void *chan;                  // If non-zero, sleeping on chan
proc.h:  int killed;                  // If non-zero, have been killed
proc.h://   fixed-size stack
Binary file proc.o matches
pr.pl:if($ARGV[0] eq "-h"){
pr.pl:	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
Binary file _ps matches
ps.asm:_ps:     file format elf32-i386
ps.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
ps.asm:  14:	c7 45 dc 20 00 00 00 	movl   $0x20,-0x24(%ebp)
ps.asm:  1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
ps.asm:  2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
ps.asm:  30:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
ps.asm:  3a:	ff 75 d8             	pushl  -0x28(%ebp)
ps.asm:  3d:	ff 75 dc             	pushl  -0x24(%ebp)
ps.asm:  48:	89 45 d4             	mov    %eax,-0x2c(%ebp)
ps.asm:  4b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
ps.asm:  6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
ps.asm:  6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
ps.asm:  84:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
ps.asm:  90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:  96:	89 45 c4             	mov    %eax,-0x3c(%ebp)
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:  99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:  9f:	89 7d c0             	mov    %edi,-0x40(%ebp)
ps.asm:  a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:  cb:	89 4d bc             	mov    %ecx,-0x44(%ebp)
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:  ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:  de:	89 55 b8             	mov    %edx,-0x48(%ebp)
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:  e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 100:	89 7d b4             	mov    %edi,-0x4c(%ebp)
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm: 103:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm: 132:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm: 161:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 173:	89 45 b0             	mov    %eax,-0x50(%ebp)
ps.asm: 176:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 17c:	89 4d ac             	mov    %ecx,-0x54(%ebp)
ps.asm: 17f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 185:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm: 18b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 191:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 199:	ff 75 c4             	pushl  -0x3c(%ebp)
ps.asm: 19c:	ff 75 c0             	pushl  -0x40(%ebp)
ps.asm: 19f:	ff 75 bc             	pushl  -0x44(%ebp)
ps.asm: 1a2:	ff 75 b8             	pushl  -0x48(%ebp)
ps.asm: 1a5:	ff 75 b4             	pushl  -0x4c(%ebp)
ps.asm: 1aa:	ff 75 b0             	pushl  -0x50(%ebp)
ps.asm: 1ad:	ff 75 ac             	pushl  -0x54(%ebp)
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm: 1c3:	83 45 e4 5c          	addl   $0x5c,-0x1c(%ebp)
ps.asm: 1c7:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
ps.asm: 1cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
ps.asm: 1ce:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm: 1da:	ff 75 d8             	pushl  -0x28(%ebp)
ps.asm: 219:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm: 23b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm:  return (uchar)*p - (uchar)*q;
ps.asm: 285:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ps.asm: 28e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
ps.asm: 292:	8b 55 fc             	mov    -0x4(%ebp),%edx
ps.asm: 2a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 2c9:	88 45 fc             	mov    %al,-0x4(%ebp)
ps.asm: 2d4:	3a 45 fc             	cmp    -0x4(%ebp),%al
ps.asm: 2f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ps.asm: 307:	8d 45 ef             	lea    -0x11(%ebp),%eax
ps.asm: 315:	89 45 f0             	mov    %eax,-0x10(%ebp)
ps.asm: 318:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ps.asm: 31e:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 324:	89 55 f4             	mov    %edx,-0xc(%ebp)
ps.asm: 32e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ps.asm: 334:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ps.asm: 33c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
ps.asm: 344:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 352:	8b 55 f4             	mov    -0xc(%ebp),%edx
ps.asm: 378:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm: 37b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ps.asm:    return -1;
ps.asm: 38e:	ff 75 f4             	pushl  -0xc(%ebp)
ps.asm: 399:	89 45 f0             	mov    %eax,-0x10(%ebp)
ps.asm: 39f:	ff 75 f4             	pushl  -0xc(%ebp)
ps.asm: 3aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm: 3b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ps.asm:  sign = (*s == '-') ? -1 : 1;
ps.asm: 3e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
ps.asm:  if (*s == '+'  || *s == '-')
ps.asm:    n = n*10 + *s++ - '0';
ps.asm: 3ff:	8b 55 fc             	mov    -0x4(%ebp),%edx
ps.asm: 421:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm:  sign = (*s == '-') ? -1 : 1;
ps.asm:  if (*s == '+'  || *s == '-')
ps.asm:    n = n*10 + *s++ - '0';
ps.asm: 438:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 43b:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ps.asm: 447:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
ps.asm:  sign = (*s == '-') ? -1 : 1;
ps.asm: 474:	89 45 f8             	mov    %eax,-0x8(%ebp)
ps.asm:  if (*s == '+'  || *s == '-')
ps.asm:    n = n*8 + *s++ - '0';
ps.asm: 491:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 4af:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm:  sign = (*s == '-') ? -1 : 1;
ps.asm:  if (*s == '+'  || *s == '-')
ps.asm:    n = n*8 + *s++ - '0';
ps.asm: 4c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 4c9:	0f af 45 fc          	imul   -0x4(%ebp),%eax
ps.asm: 4d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm: 4de:	89 45 f8             	mov    %eax,-0x8(%ebp)
ps.asm:  while(n-- > 0)
ps.asm: 4e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 4e9:	89 55 fc             	mov    %edx,-0x4(%ebp)
ps.asm: 4ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
ps.asm: 4f2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
ps.asm:  while(n-- > 0)
ps.asm: 4fd:	8d 50 ff             	lea    -0x1(%eax),%edx
ps.asm:# Added calls - Evghenii
ps.asm: 5fd:	88 45 f4             	mov    %al,-0xc(%ebp)
ps.asm: 605:	8d 45 f4             	lea    -0xc(%ebp),%eax
ps.asm: 61e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ps.asm: 631:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
ps.asm:    x = -xx;
ps.asm: 63d:	89 45 ec             	mov    %eax,-0x14(%ebp)
ps.asm: 645:	89 45 ec             	mov    %eax,-0x14(%ebp)
ps.asm: 648:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
ps.asm: 64f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
ps.asm: 655:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm: 65b:	8b 45 ec             	mov    -0x14(%ebp),%eax
ps.asm: 66e:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
ps.asm: 675:	8b 45 ec             	mov    -0x14(%ebp),%eax
ps.asm: 67f:	89 45 ec             	mov    %eax,-0x14(%ebp)
ps.asm: 682:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ps.asm: 688:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ps.asm:    buf[i++] = '-';
ps.asm: 68e:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 694:	89 55 f4             	mov    %edx,-0xc(%ebp)
ps.asm: 697:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
ps.asm:  while(--i >= 0)
ps.asm: 69e:	8d 55 dc             	lea    -0x24(%ebp),%edx
ps.asm: 6a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm:    buf[i++] = '-';
ps.asm:  while(--i >= 0)
ps.asm: 6bb:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
ps.asm: 6bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ps.asm: 6c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
ps.asm: 6d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ps.asm: 6de:	89 45 e8             	mov    %eax,-0x18(%ebp)
ps.asm: 6e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
ps.asm: 6f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm: 700:	89 45 e4             	mov    %eax,-0x1c(%ebp)
ps.asm: 703:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
ps.asm: 709:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ps.asm: 70f:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
ps.asm: 71b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 735:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
ps.asm: 73f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
ps.asm: 745:	8b 45 e8             	mov    -0x18(%ebp),%eax
ps.asm: 75a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ps.asm: 763:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
ps.asm: 769:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
ps.asm: 76f:	8b 45 e8             	mov    -0x18(%ebp),%eax
ps.asm: 784:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ps.asm: 78d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
ps.asm: 793:	8b 45 e8             	mov    -0x18(%ebp),%eax
ps.asm: 798:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm: 79b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ps.asm: 79f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ps.asm: 7a5:	c7 45 f4 0a 0b 00 00 	movl   $0xb0a,-0xc(%ebp)
ps.asm: 7ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 7c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
ps.asm: 7ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 7d6:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
ps.asm: 7dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
ps.asm: 7f3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
ps.asm: 7f9:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
ps.asm: 7ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 826:	8b 45 e4             	mov    -0x1c(%ebp),%eax
ps.asm: 83b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
ps.asm: 842:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
ps.asm: 849:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm:  bp = (Header*)ap - 1;
ps.asm: 868:	89 45 f8             	mov    %eax,-0x8(%ebp)
ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ps.asm: 870:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ps.asm: 875:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 87a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ps.asm: 87f:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 882:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ps.asm: 887:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 88c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ps.asm:  bp = (Header*)ap - 1;
ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ps.asm: 891:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 896:	89 45 fc             	mov    %eax,-0x4(%ebp)
ps.asm: 899:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 89c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
ps.asm: 8a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 8a6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ps.asm:  if(bp + bp->s.size == p->s.ptr){
ps.asm: 8ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 8b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 8bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm:    bp->s.size += p->s.ptr->s.size;
ps.asm: 8c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 8cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 8d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ps.asm: 8dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 8e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm:    bp->s.ptr = p->s.ptr;
ps.asm: 8ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 8ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm:  if(p + p->s.size == bp){
ps.asm: 8f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 901:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 906:	3b 45 f8             	cmp    -0x8(%ebp),%eax
ps.asm:    p->s.size += bp->s.size;
ps.asm: 90b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 911:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 919:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm:    p->s.ptr = bp->s.ptr;
ps.asm: 91f:	8b 45 f8             	mov    -0x8(%ebp),%eax
ps.asm: 924:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm:    p->s.ptr = bp;
ps.asm: 92b:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 92e:	8b 55 f8             	mov    -0x8(%ebp),%edx
ps.asm: 933:	8b 45 fc             	mov    -0x4(%ebp),%eax
ps.asm: 966:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm:  if(p == (char*)-1)
ps.asm: 969:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
ps.asm: 976:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 979:	89 45 f0             	mov    %eax,-0x10(%ebp)
ps.asm:  hp->s.size = nu;
ps.asm: 97c:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm: 985:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ps.asm: 9b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
ps.asm: 9b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
ps.asm: 9bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
ps.asm: 9c1:	c7 45 f0 9c 0d 00 00 	movl   $0xd9c,-0x10(%ebp)
ps.asm: 9c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ps.asm: 9e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm: 9e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm:    if(p->s.size >= nunits){
ps.asm: 9ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 9f2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ps.asm:      if(p->s.size == nunits)
ps.asm: 9f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: 9fd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
ps.asm:        prevp->s.ptr = p->s.ptr;
ps.asm: a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a07:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm:        p->s.size -= nunits;
ps.asm: a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a14:	2b 45 ec             	sub    -0x14(%ebp),%eax
ps.asm: a19:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm:        p += p->s.size;
ps.asm: a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a28:	01 45 f4             	add    %eax,-0xc(%ebp)
ps.asm:        p->s.size = nunits;
ps.asm: a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a2e:	8b 55 ec             	mov    -0x14(%ebp),%edx
ps.asm: a34:	8b 45 f0             	mov    -0x10(%ebp),%eax
ps.asm: a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a49:	39 45 f4             	cmp    %eax,-0xc(%ebp)
ps.asm: a51:	ff 75 ec             	pushl  -0x14(%ebp)
ps.asm: a5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.asm: a5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
ps.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ps.asm: a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
ps.asm: a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
ps.asm: a77:	89 45 f4             	mov    %eax,-0xc(%ebp)
ps.c:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.c:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.c:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.d:ps.o: ps.c /usr/include/stdc-predef.h RMME.h types.h user.h uproc.h
Binary file ps.o matches
Binary file _ps-test matches
README:xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
README:but is implemented for a modern x86-based multiprocessor using ANSI C.
README:to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
README:provides pointers to on-line resources for v6.
README:Silas Boyd-Wickizer, Peter Froehlich, Shivam Handa, Anders Kaseorg, Eddie
README:Copyright 2006-2014 Frans Kaashoek, Robert Morris, and Russ Cox.
README:On non-x86 or non-ELF machines (like OS X, even on x86), you will
README:need to install a cross-compiler gcc suite capable of producing x86 ELF
README:Then run "make TOOLPREFIX=i386-jos-elf-".
README-PSU:1a. The definition for ticks was made 32-bit aligned in trap.c.
README-PSU:// set alignment to 32-bit for ticks. See Intel 64 and IA-32 Architectures
README-PSU:  switch(tf->trapno){
README-PSU:    if(cpu->id == 0){
README-PSU:  switch(tf->trapno){
README-PSU:    if(cpu->id == 0){
Binary file _rm matches
rm.asm:_rm:     file format elf32-i386
rm.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
rm.asm:  30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
rm.asm:  39:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm:  5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm:  80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
rm.asm:  84:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm:  bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm:  e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm:  return (uchar)*p - (uchar)*q;
rm.asm: 12b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
rm.asm: 134:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
rm.asm: 138:	8b 55 fc             	mov    -0x4(%ebp),%edx
rm.asm: 147:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 16f:	88 45 fc             	mov    %al,-0x4(%ebp)
rm.asm: 17a:	3a 45 fc             	cmp    -0x4(%ebp),%al
rm.asm: 19f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
rm.asm: 1ad:	8d 45 ef             	lea    -0x11(%ebp),%eax
rm.asm: 1bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
rm.asm: 1be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
rm.asm: 1c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 1ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
rm.asm: 1d4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
rm.asm: 1da:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
rm.asm: 1e2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
rm.asm: 1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 1f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
rm.asm: 21e:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm: 221:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
rm.asm:    return -1;
rm.asm: 234:	ff 75 f4             	pushl  -0xc(%ebp)
rm.asm: 23f:	89 45 f0             	mov    %eax,-0x10(%ebp)
rm.asm: 245:	ff 75 f4             	pushl  -0xc(%ebp)
rm.asm: 250:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm: 25b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
rm.asm:  sign = (*s == '-') ? -1 : 1;
rm.asm: 288:	89 45 f8             	mov    %eax,-0x8(%ebp)
rm.asm:  if (*s == '+'  || *s == '-')
rm.asm:    n = n*10 + *s++ - '0';
rm.asm: 2a5:	8b 55 fc             	mov    -0x4(%ebp),%edx
rm.asm: 2c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm:  sign = (*s == '-') ? -1 : 1;
rm.asm:  if (*s == '+'  || *s == '-')
rm.asm:    n = n*10 + *s++ - '0';
rm.asm: 2de:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 2e1:	0f af 45 fc          	imul   -0x4(%ebp),%eax
rm.asm: 2ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
rm.asm:  sign = (*s == '-') ? -1 : 1;
rm.asm: 31a:	89 45 f8             	mov    %eax,-0x8(%ebp)
rm.asm:  if (*s == '+'  || *s == '-')
rm.asm:    n = n*8 + *s++ - '0';
rm.asm: 337:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 355:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm:  sign = (*s == '-') ? -1 : 1;
rm.asm:  if (*s == '+'  || *s == '-')
rm.asm:    n = n*8 + *s++ - '0';
rm.asm: 36c:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 36f:	0f af 45 fc          	imul   -0x4(%ebp),%eax
rm.asm: 37e:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm: 384:	89 45 f8             	mov    %eax,-0x8(%ebp)
rm.asm:  while(n-- > 0)
rm.asm: 389:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 38f:	89 55 fc             	mov    %edx,-0x4(%ebp)
rm.asm: 392:	8b 55 f8             	mov    -0x8(%ebp),%edx
rm.asm: 398:	89 4d f8             	mov    %ecx,-0x8(%ebp)
rm.asm:  while(n-- > 0)
rm.asm: 3a3:	8d 50 ff             	lea    -0x1(%eax),%edx
rm.asm:# Added calls - Evghenii
rm.asm: 4a3:	88 45 f4             	mov    %al,-0xc(%ebp)
rm.asm: 4ab:	8d 45 f4             	lea    -0xc(%ebp),%eax
rm.asm: 4c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
rm.asm: 4d7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
rm.asm:    x = -xx;
rm.asm: 4e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
rm.asm: 4eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
rm.asm: 4ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
rm.asm: 4f5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
rm.asm: 4fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm: 501:	8b 45 ec             	mov    -0x14(%ebp),%eax
rm.asm: 514:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
rm.asm: 51b:	8b 45 ec             	mov    -0x14(%ebp),%eax
rm.asm: 525:	89 45 ec             	mov    %eax,-0x14(%ebp)
rm.asm: 528:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
rm.asm: 52e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
rm.asm:    buf[i++] = '-';
rm.asm: 534:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 53a:	89 55 f4             	mov    %edx,-0xc(%ebp)
rm.asm: 53d:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
rm.asm:  while(--i >= 0)
rm.asm: 544:	8d 55 dc             	lea    -0x24(%ebp),%edx
rm.asm: 547:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm:    buf[i++] = '-';
rm.asm:  while(--i >= 0)
rm.asm: 561:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
rm.asm: 565:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
rm.asm: 56c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
rm.asm: 577:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
rm.asm: 584:	89 45 e8             	mov    %eax,-0x18(%ebp)
rm.asm: 587:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
rm.asm: 596:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm: 5a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
rm.asm: 5a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
rm.asm: 5af:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
rm.asm: 5b5:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
rm.asm: 5c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
rm.asm: 5db:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
rm.asm: 5e5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
rm.asm: 5eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
rm.asm: 600:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
rm.asm: 609:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
rm.asm: 60f:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
rm.asm: 615:	8b 45 e8             	mov    -0x18(%ebp),%eax
rm.asm: 62a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
rm.asm: 633:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
rm.asm: 639:	8b 45 e8             	mov    -0x18(%ebp),%eax
rm.asm: 63e:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm: 641:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
rm.asm: 645:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
rm.asm: 64b:	c7 45 f4 54 09 00 00 	movl   $0x954,-0xc(%ebp)
rm.asm: 654:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 66c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
rm.asm: 670:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 67c:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
rm.asm: 682:	8b 45 e8             	mov    -0x18(%ebp),%eax
rm.asm: 699:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
rm.asm: 69f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
rm.asm: 6a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
rm.asm: 6cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
rm.asm: 6e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
rm.asm: 6e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
rm.asm: 6ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm:  bp = (Header*)ap - 1;
rm.asm: 70e:	89 45 f8             	mov    %eax,-0x8(%ebp)
rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
rm.asm: 716:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
rm.asm: 71b:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 720:	3b 45 fc             	cmp    -0x4(%ebp),%eax
rm.asm: 725:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 728:	3b 45 fc             	cmp    -0x4(%ebp),%eax
rm.asm: 72d:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 732:	3b 45 f8             	cmp    -0x8(%ebp),%eax
rm.asm:  bp = (Header*)ap - 1;
rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
rm.asm: 737:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 73c:	89 45 fc             	mov    %eax,-0x4(%ebp)
rm.asm: 73f:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 742:	3b 45 fc             	cmp    -0x4(%ebp),%eax
rm.asm: 747:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 74c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
rm.asm:  if(bp + bp->s.size == p->s.ptr){
rm.asm: 751:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 763:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm:    bp->s.size += p->s.ptr->s.size;
rm.asm: 76c:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 772:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 77c:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
rm.asm: 782:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 789:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm:    bp->s.ptr = p->s.ptr;
rm.asm: 790:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 795:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm:  if(p + p->s.size == bp){
rm.asm: 79a:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 7a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 7ac:	3b 45 f8             	cmp    -0x8(%ebp),%eax
rm.asm:    p->s.size += bp->s.size;
rm.asm: 7b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 7b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 7bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm:    p->s.ptr = bp->s.ptr;
rm.asm: 7c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
rm.asm: 7ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm:    p->s.ptr = bp;
rm.asm: 7d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 7d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
rm.asm: 7d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
rm.asm: 80c:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm:  if(p == (char*)-1)
rm.asm: 80f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
rm.asm: 81c:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 81f:	89 45 f0             	mov    %eax,-0x10(%ebp)
rm.asm:  hp->s.size = nu;
rm.asm: 822:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm: 82b:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
rm.asm: 856:	89 45 ec             	mov    %eax,-0x14(%ebp)
rm.asm: 85e:	89 45 f0             	mov    %eax,-0x10(%ebp)
rm.asm: 861:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
rm.asm: 867:	c7 45 f0 dc 0b 00 00 	movl   $0xbdc,-0x10(%ebp)
rm.asm: 86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
rm.asm: 88a:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm: 88f:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm:    if(p->s.size >= nunits){
rm.asm: 892:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 898:	3b 45 ec             	cmp    -0x14(%ebp),%eax
rm.asm:      if(p->s.size == nunits)
rm.asm: 89d:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
rm.asm:        prevp->s.ptr = p->s.ptr;
rm.asm: 8a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm:        p->s.size -= nunits;
rm.asm: 8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8ba:	2b 45 ec             	sub    -0x14(%ebp),%eax
rm.asm: 8bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm:        p += p->s.size;
rm.asm: 8c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8ce:	01 45 f4             	add    %eax,-0xc(%ebp)
rm.asm:        p->s.size = nunits;
rm.asm: 8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
rm.asm: 8da:	8b 45 f0             	mov    -0x10(%ebp),%eax
rm.asm: 8e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 8ef:	39 45 f4             	cmp    %eax,-0xc(%ebp)
rm.asm: 8f7:	ff 75 ec             	pushl  -0x14(%ebp)
rm.asm: 902:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.asm: 905:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
rm.asm: 912:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 915:	89 45 f0             	mov    %eax,-0x10(%ebp)
rm.asm: 918:	8b 45 f4             	mov    -0xc(%ebp),%eax
rm.asm: 91d:	89 45 f4             	mov    %eax,-0xc(%ebp)
rm.d:rm.o: rm.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file rm.o matches
runoff:mkdir -p fmt
runoff:rm -f fmt/*
runoff:files=`grep -v '^#' runoff.list | awk '{print $1}'`
runoff:	./runoff1 -n $n $i >fmt/$i
runoff:	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
runoff:pr -e8 -t runoff.list | awk '
runoff:/^[a-zA-Z0-9]/ {
runoff:}' | pr -3 -t >>fmt/toc
runoff:perl -e '
runoff:			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
runoff:perl -e '
runoff:		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
runoff:		if (/^[0-9]+ extern/) {
runoff:		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
runoff:		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
runoff:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
runoff:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
runoff:		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
runoff:		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
runoff:		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
runoff:		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
runoff:perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
runoff:	egrep -v ' (STUB|usage|main|if|for)$' >>defs
runoff:#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
runoff:for i in `awk '{print $2}' defs | sort -f | uniq`
runoff:	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
runoff:	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
runoff:		echo $uses |fmt -29 | sed 's/^/    /'
runoff:	../pr.pl -h "table of contents" toc
runoff:	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
runoff:	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
runoff:	# pr.pl -h "definitions" -2 t.defs | pad
runoff:	# pr.pl -h "cross-references" -2 refs | pad 
runoff:		../pr.pl -h "xv6/$i" $i
runoff:) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
runoff:nicefont=LucidaSans-Typewriter83
runoff:if [ ! -f ../$nicefont ]
runoff:	if git cat-file blob font:$nicefont > ../$nicefont~; then
runoff:if [ -f ../$nicefont ]
runoff1:if($ARGV[0] eq "-v") {
runoff1:if($ARGV[0] eq "-n") {
runoff1:$n = int(($n+49)/50)*50 - 1;
runoff1:			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
runoff1:		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
runoff1:		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
runoff.list:# low-level hardware
runoff.list:# user-level
runoff.list:p5-test.c
runoff.list:p5-test.h
runoff.spec:# "left" and "right" specify which page of a two-page spread a file
runoff.spec:# goal is to have two action-packed 2-page spreads,
runoff.spec:# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
Binary file _sh matches
sh.asm:_sh:     file format elf32-i386
sh.asm:  switch(cmd->type){
sh.asm:      37:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    if(ecmd->argv[0] == 0)
sh.asm:      3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    exec(ecmd->argv[0], ecmd->argv);
sh.asm:      49:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:      4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    printf(2, "exec %s failed\n", ecmd->argv[0]);
sh.asm:      62:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:      83:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    close(rcmd->fd);
sh.asm:      86:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    if(open(rcmd->file, rcmd->mode) < 0){
sh.asm:      98:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:      9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:      printf(2, "open %s failed\n", rcmd->file);
sh.asm:      b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    runcmd(rcmd->cmd);
sh.asm:      d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:      ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:      runcmd(lcmd->left);
sh.asm:      f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:    runcmd(lcmd->right);
sh.asm:     110:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     12a:	89 45 e8             	mov    %eax,-0x18(%ebp)
sh.asm:     130:	8d 45 dc             	lea    -0x24(%ebp),%eax
sh.asm:     166:	8b 45 e0             	mov    -0x20(%ebp),%eax
sh.asm:     175:	8b 45 dc             	mov    -0x24(%ebp),%eax
sh.asm:     184:	8b 45 e0             	mov    -0x20(%ebp),%eax
sh.asm:      runcmd(pcmd->left);
sh.asm:     193:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:     1bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
sh.asm:     1ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
sh.asm:     1d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
sh.asm:      runcmd(pcmd->right);
sh.asm:     1e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:     1fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
sh.asm:     209:	8b 45 e0             	mov    -0x20(%ebp),%eax
sh.asm:     227:	89 45 e4             	mov    %eax,-0x1c(%ebp)
sh.asm:      runcmd(bcmd->cmd);
sh.asm:     233:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:    return -1;
sh.asm:      n--, p++, q++;
sh.asm:      n--, p++, q++;
sh.asm:    return (uchar)*p - (uchar)*q;
sh.asm:     2fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
sh.asm:    val = 10*val + (*p-'0');
sh.asm:     305:	8b 55 fc             	mov    -0x4(%ebp),%edx
sh.asm:     321:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:    val = 10*val + (*p-'0');
sh.asm:     33c:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:     3d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     3d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     442:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     445:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  return -1;
sh.asm:  return -1;
sh.asm:     536:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
sh.asm:     53f:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     557:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     575:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     58a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     593:	39 45 f4             	cmp    %eax,-0xc(%ebp)
sh.asm:     5a2:	ff 71 fc             	pushl  -0x4(%ecx)
sh.asm:     5ae:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
sh.asm:     5b7:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     5d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     5d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
sh.asm:// add support for built-ins here. cd is a built-in
sh.asm:      buf[strlen(buf)-1] = 0;  // chop \n
sh.asm:     6df:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:  if(pid == -1)
sh.asm:     6e2:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
sh.asm:     6f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     710:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     71a:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:  cmd->type = EXEC;
sh.asm:     725:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     72e:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     746:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     750:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:  cmd->type = REDIR;
sh.asm:     75b:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->cmd = subcmd;
sh.asm:     764:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->file = file;
sh.asm:     76d:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->efile = efile;
sh.asm:     776:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->mode = mode;
sh.asm:     77f:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->fd = fd;
sh.asm:     788:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     791:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     7a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     7b3:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:  cmd->type = PIPE;
sh.asm:     7be:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->left = left;
sh.asm:     7c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->right = right;
sh.asm:     7d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     7d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     7f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     7fb:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:  cmd->type = LIST;
sh.asm:     806:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->left = left;
sh.asm:     80f:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->right = right;
sh.asm:     818:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     821:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     839:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     843:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:  cmd->type = BACK;
sh.asm:     84e:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:  cmd->cmd = subcmd;
sh.asm:     857:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     860:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     870:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     875:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     879:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     881:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     8a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:     8ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     8b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:     8b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     8f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     8fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     8fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     908:	c7 45 f0 2b 00 00 00 	movl   $0x2b,-0x10(%ebp)
sh.asm:     90f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     915:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)
sh.asm:     91e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     922:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     92a:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     948:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     978:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:     97f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     983:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     98b:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     9ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:     9b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     9c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     9c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     9ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     9d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     9f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:     9f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     a47:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     a4d:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     a5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:     a67:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     a79:	3b 45 f4             	cmp    -0xc(%ebp),%eax
sh.asm:     aa7:	ff 75 f0             	pushl  -0x10(%ebp)
sh.asm:     ab2:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     ab5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
sh.asm:     ad1:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     aeb:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     af6:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     b54:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     b5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     b7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     bc2:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     bcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     bd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     bf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     bf5:	8d 45 ec             	lea    -0x14(%ebp),%eax
sh.asm:     bf9:	8d 45 f0             	lea    -0x10(%ebp),%eax
sh.asm:     c20:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     c34:	8b 55 ec             	mov    -0x14(%ebp),%edx
sh.asm:     c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     c53:	8b 55 ec             	mov    -0x14(%ebp),%edx
sh.asm:     c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     c75:	8b 55 ec             	mov    -0x14(%ebp),%edx
sh.asm:     c78:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     d0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    panic("syntax - missing )");
sh.asm:     d54:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:     d5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:     d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:     da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:     da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     da8:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:     dab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
sh.asm:     dbb:	ff 75 f0             	pushl  -0x10(%ebp)
sh.asm:     dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:     dce:	8d 45 e0             	lea    -0x20(%ebp),%eax
sh.asm:     dd2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
sh.asm:     de4:	89 45 e8             	mov    %eax,-0x18(%ebp)
sh.asm:     de7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
sh.asm:     df1:	83 7d e8 61          	cmpl   $0x61,-0x18(%ebp)
sh.asm:    cmd->argv[argc] = q;
sh.asm:     e07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
sh.asm:     e0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     e0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:    cmd->eargv[argc] = eq;
sh.asm:     e14:	8b 55 e0             	mov    -0x20(%ebp),%edx
sh.asm:     e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     e1a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
sh.asm:     e24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     e28:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
sh.asm:     e47:	ff 75 f0             	pushl  -0x10(%ebp)
sh.asm:     e52:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:  cmd->argv[argc] = 0;
sh.asm:     e76:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     e79:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:  cmd->eargv[argc] = 0;
sh.asm:     e84:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     e87:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:     e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:// NUL-terminate all the counted strings.
sh.asm:  switch(cmd->type){
sh.asm:     eca:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    for(i=0; ecmd->argv[i]; i++)
sh.asm:     ecd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
sh.asm:      *ecmd->eargv[i] = 0;
sh.asm:     ed6:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     ed9:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:  switch(cmd->type){
sh.asm:    for(i=0; ecmd->argv[i]; i++)
sh.asm:     ee6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:     eea:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:     eed:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:      *ecmd->eargv[i] = 0;
sh.asm:     f00:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:    nulterminate(rcmd->cmd);
sh.asm:     f03:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:    *rcmd->efile = 0;
sh.asm:     f15:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:     f23:	89 45 e8             	mov    %eax,-0x18(%ebp)
sh.asm:    nulterminate(pcmd->left);
sh.asm:     f26:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:    nulterminate(pcmd->right);
sh.asm:     f38:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:     f4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
sh.asm:    nulterminate(lcmd->left);
sh.asm:     f52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:    nulterminate(lcmd->right);
sh.asm:     f64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:     f7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
sh.asm:    nulterminate(bcmd->cmd);
sh.asm:     f7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
sh.asm:     fc5:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:     fe7:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:  return (uchar)*p - (uchar)*q;
sh.asm:    1031:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
sh.asm:    103a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
sh.asm:    103e:	8b 55 fc             	mov    -0x4(%ebp),%edx
sh.asm:    104d:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1075:	88 45 fc             	mov    %al,-0x4(%ebp)
sh.asm:    1080:	3a 45 fc             	cmp    -0x4(%ebp),%al
sh.asm:    10a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
sh.asm:    10b3:	8d 45 ef             	lea    -0x11(%ebp),%eax
sh.asm:    10c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    10c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
sh.asm:    10ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    10d0:	89 55 f4             	mov    %edx,-0xc(%ebp)
sh.asm:    10da:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
sh.asm:    10e0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
sh.asm:    10e8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
sh.asm:    10f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    10fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
sh.asm:    1124:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    1127:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
sh.asm:    return -1;
sh.asm:    113a:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:    1145:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    114b:	ff 75 f4             	pushl  -0xc(%ebp)
sh.asm:    1156:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    1161:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
sh.asm:  sign = (*s == '-') ? -1 : 1;
sh.asm:    118e:	89 45 f8             	mov    %eax,-0x8(%ebp)
sh.asm:  if (*s == '+'  || *s == '-')
sh.asm:    n = n*10 + *s++ - '0';
sh.asm:    11ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
sh.asm:    11cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:  sign = (*s == '-') ? -1 : 1;
sh.asm:  if (*s == '+'  || *s == '-')
sh.asm:    n = n*10 + *s++ - '0';
sh.asm:    11e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    11e7:	0f af 45 fc          	imul   -0x4(%ebp),%eax
sh.asm:    11f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
sh.asm:  sign = (*s == '-') ? -1 : 1;
sh.asm:    1220:	89 45 f8             	mov    %eax,-0x8(%ebp)
sh.asm:  if (*s == '+'  || *s == '-')
sh.asm:    n = n*8 + *s++ - '0';
sh.asm:    123d:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    125b:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:  sign = (*s == '-') ? -1 : 1;
sh.asm:  if (*s == '+'  || *s == '-')
sh.asm:    n = n*8 + *s++ - '0';
sh.asm:    1272:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    1275:	0f af 45 fc          	imul   -0x4(%ebp),%eax
sh.asm:    1284:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:    128a:	89 45 f8             	mov    %eax,-0x8(%ebp)
sh.asm:  while(n-- > 0)
sh.asm:    128f:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1295:	89 55 fc             	mov    %edx,-0x4(%ebp)
sh.asm:    1298:	8b 55 f8             	mov    -0x8(%ebp),%edx
sh.asm:    129e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
sh.asm:  while(n-- > 0)
sh.asm:    12a9:	8d 50 ff             	lea    -0x1(%eax),%edx
sh.asm:# Added calls - Evghenii
sh.asm:    13a9:	88 45 f4             	mov    %al,-0xc(%ebp)
sh.asm:    13b1:	8d 45 f4             	lea    -0xc(%ebp),%eax
sh.asm:    13ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
sh.asm:    13dd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
sh.asm:    x = -xx;
sh.asm:    13e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:    13f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:    13f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
sh.asm:    13fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
sh.asm:    1401:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    1407:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:    141a:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
sh.asm:    1421:	8b 45 ec             	mov    -0x14(%ebp),%eax
sh.asm:    142b:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:    142e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
sh.asm:    1434:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
sh.asm:    buf[i++] = '-';
sh.asm:    143a:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    1440:	89 55 f4             	mov    %edx,-0xc(%ebp)
sh.asm:    1443:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
sh.asm:  while(--i >= 0)
sh.asm:    144a:	8d 55 dc             	lea    -0x24(%ebp),%edx
sh.asm:    144d:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    buf[i++] = '-';
sh.asm:  while(--i >= 0)
sh.asm:    1467:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
sh.asm:    146b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
sh.asm:    1472:	8b 5d fc             	mov    -0x4(%ebp),%ebx
sh.asm:    147d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
sh.asm:    148a:	89 45 e8             	mov    %eax,-0x18(%ebp)
sh.asm:    148d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
sh.asm:    149c:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    14ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
sh.asm:    14af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
sh.asm:    14b5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
sh.asm:    14bb:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
sh.asm:    14c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:    14e1:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
sh.asm:    14eb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
sh.asm:    14f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:    1506:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
sh.asm:    150f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
sh.asm:    1515:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
sh.asm:    151b:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:    1530:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
sh.asm:    1539:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
sh.asm:    153f:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:    1544:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    1547:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
sh.asm:    154b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
sh.asm:    1551:	c7 45 f4 68 19 00 00 	movl   $0x1968,-0xc(%ebp)
sh.asm:    155a:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    1572:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
sh.asm:    1576:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    1582:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
sh.asm:    1588:	8b 45 e8             	mov    -0x18(%ebp),%eax
sh.asm:    159f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
sh.asm:    15a5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
sh.asm:    15ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:    15d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
sh.asm:    15e7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
sh.asm:    15ee:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
sh.asm:    15f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:  bp = (Header*)ap - 1;
sh.asm:    1614:	89 45 f8             	mov    %eax,-0x8(%ebp)
sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
sh.asm:    161c:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
sh.asm:    1621:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1626:	3b 45 fc             	cmp    -0x4(%ebp),%eax
sh.asm:    162b:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    162e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
sh.asm:    1633:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1638:	3b 45 f8             	cmp    -0x8(%ebp),%eax
sh.asm:  bp = (Header*)ap - 1;
sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
sh.asm:    163d:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1642:	89 45 fc             	mov    %eax,-0x4(%ebp)
sh.asm:    1645:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    1648:	3b 45 fc             	cmp    -0x4(%ebp),%eax
sh.asm:    164d:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1652:	3b 45 f8             	cmp    -0x8(%ebp),%eax
sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
sh.asm:  if(bp + bp->s.size == p->s.ptr){
sh.asm:    1657:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    1664:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    1669:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    bp->s.size += p->s.ptr->s.size;
sh.asm:    1672:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    1678:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1682:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
sh.asm:    1688:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    168f:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    bp->s.ptr = p->s.ptr;
sh.asm:    1696:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    169b:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:  if(p + p->s.size == bp){
sh.asm:    16a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    16ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    16b2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
sh.asm:    p->s.size += bp->s.size;
sh.asm:    16b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    16bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    16c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    p->s.ptr = bp->s.ptr;
sh.asm:    16cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
sh.asm:    16d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    p->s.ptr = bp;
sh.asm:    16d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    16da:	8b 55 f8             	mov    -0x8(%ebp),%edx
sh.asm:    16df:	8b 45 fc             	mov    -0x4(%ebp),%eax
sh.asm:    1712:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:  if(p == (char*)-1)
sh.asm:    1715:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
sh.asm:    1722:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    1725:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:  hp->s.size = nu;
sh.asm:    1728:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    1731:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
sh.asm:    175c:	89 45 ec             	mov    %eax,-0x14(%ebp)
sh.asm:    1764:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    1767:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
sh.asm:    176d:	c7 45 f0 64 1f 00 00 	movl   $0x1f64,-0x10(%ebp)
sh.asm:    1774:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
sh.asm:    1790:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    1795:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    if(p->s.size >= nunits){
sh.asm:    1798:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    179e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
sh.asm:      if(p->s.size == nunits)
sh.asm:    17a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17a9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
sh.asm:        prevp->s.ptr = p->s.ptr;
sh.asm:    17ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:        p->s.size -= nunits;
sh.asm:    17ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17c0:	2b 45 ec             	sub    -0x14(%ebp),%eax
sh.asm:    17c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:        p += p->s.size;
sh.asm:    17cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17d4:	01 45 f4             	add    %eax,-0xc(%ebp)
sh.asm:        p->s.size = nunits;
sh.asm:    17d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17da:	8b 55 ec             	mov    -0x14(%ebp),%edx
sh.asm:    17e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
sh.asm:    17e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    17f5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
sh.asm:    17fd:	ff 75 ec             	pushl  -0x14(%ebp)
sh.asm:    1808:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.asm:    180b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
sh.asm:    1818:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    181b:	89 45 f0             	mov    %eax,-0x10(%ebp)
sh.asm:    181e:	8b 45 f4             	mov    -0xc(%ebp),%eax
sh.asm:    1823:	89 45 f4             	mov    %eax,-0xc(%ebp)
sh.c:// 2015-12-21. Added very simple processing for builtin commands
sh.c:  switch(cmd->type){
sh.c:    if(ecmd->argv[0] == 0)
sh.c:    exec(ecmd->argv[0], ecmd->argv);
sh.c:    printf(2, "exec %s failed\n", ecmd->argv[0]);
sh.c:    close(rcmd->fd);
sh.c:    if(open(rcmd->file, rcmd->mode) < 0){
sh.c:      printf(2, "open %s failed\n", rcmd->file);
sh.c:    runcmd(rcmd->cmd);
sh.c:      runcmd(lcmd->left);
sh.c:    runcmd(lcmd->right);
sh.c:      runcmd(pcmd->left);
sh.c:      runcmd(pcmd->right);
sh.c:      runcmd(bcmd->cmd);
sh.c:    return -1;
sh.c:      n--, p++, q++;
sh.c:    return (uchar)*p - (uchar)*q;
sh.c:    val = 10*val + (*p-'0');
sh.c:  return -1;
sh.c:  return -1;
sh.c:// add support for built-ins here. cd is a built-in
sh.c:      buf[strlen(buf)-1] = 0;  // chop \n
sh.c:  if(pid == -1)
sh.c:  cmd->type = EXEC;
sh.c:  cmd->type = REDIR;
sh.c:  cmd->cmd = subcmd;
sh.c:  cmd->file = file;
sh.c:  cmd->efile = efile;
sh.c:  cmd->mode = mode;
sh.c:  cmd->fd = fd;
sh.c:  cmd->type = PIPE;
sh.c:  cmd->left = left;
sh.c:  cmd->right = right;
sh.c:  cmd->type = LIST;
sh.c:  cmd->left = left;
sh.c:  cmd->right = right;
sh.c:  cmd->type = BACK;
sh.c:  cmd->cmd = subcmd;
sh.c:    panic("syntax - missing )");
sh.c:    cmd->argv[argc] = q;
sh.c:    cmd->eargv[argc] = eq;
sh.c:  cmd->argv[argc] = 0;
sh.c:  cmd->eargv[argc] = 0;
sh.c:// NUL-terminate all the counted strings.
sh.c:  switch(cmd->type){
sh.c:    for(i=0; ecmd->argv[i]; i++)
sh.c:      *ecmd->eargv[i] = 0;
sh.c:    nulterminate(rcmd->cmd);
sh.c:    *rcmd->efile = 0;
sh.c:    nulterminate(pcmd->left);
sh.c:    nulterminate(pcmd->right);
sh.c:    nulterminate(lcmd->left);
sh.c:    nulterminate(lcmd->right);
sh.c:    nulterminate(bcmd->cmd);
sh.d:sh.o: sh.c /usr/include/stdc-predef.h RMME.h types.h user.h fcntl.h
Binary file sh.o matches
show1:# runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
show1:runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2  -L60 >x.ps; gv --swap x.ps
sign.pl:$buf .= "\0" x (510-$n);
sleep1.p:then a deadlock can happen, because the non-atomic
sleep1.p:increment of value conflicts with the non-atomic 
sleep1.p:	:: cond ->
sleep1.p:	:: else ->
sleep1.p:	:: w < N ->
sleep1.p:	:: else ->
sleep1.p:	:: i < ITER ->
sleep1.p:		x = value; value = x - 1; x = 0;
sleep1.p:	:: else ->
sleep1.p:	:: i < ITER ->
sleep1.p:	:: else ->
spinlock.c:  lk->name = name;
spinlock.c:  lk->locked = 0;
spinlock.c:  lk->cpu = 0;
spinlock.c:  while(xchg(&lk->locked, 1) != 0)
spinlock.c:  lk->cpu = cpu;
spinlock.c:  getcallerpcs(&lk, lk->pcs);
spinlock.c:  lk->pcs[0] = 0;
spinlock.c:  lk->cpu = 0;
spinlock.c:  // Paper says that Intel 64 and IA-32 will not move a load
spinlock.c:  // after a store. So lock->locked = 0 would work here.
spinlock.c:  xchg(&lk->locked, 0);
spinlock.c:  ebp = (uint*)v - 2;
spinlock.c:  return lock->locked && lock->cpu == cpu;
spinlock.c:  if(cpu->ncli++ == 0)
spinlock.c:    cpu->intena = eflags & FL_IF;
spinlock.c:    panic("popcli - interruptible");
spinlock.c:  if(--cpu->ncli < 0)
spinlock.c:  if(cpu->ncli == 0 && cpu->intena)
spinlock.d:spinlock.o: spinlock.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file spinlock.o matches
spinp:if [ $# != 1 ] || [ ! -f "$1" ]; then
spinp:rm -f $1.trail
spinp:spin -a $1 || exit 1
spinp:cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
spinp:pan -i
spinp:if [ -f $1.trail ]; then
spinp:	spin -t -p $1
Binary file _stressfs matches
stressfs.asm:_stressfs:     file format elf32-i386
stressfs.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
stressfs.asm:  14:	c7 45 e6 73 74 72 65 	movl   $0x65727473,-0x1a(%ebp)
stressfs.asm:  1b:	c7 45 ea 73 73 66 73 	movl   $0x73667373,-0x16(%ebp)
stressfs.asm:  22:	66 c7 45 ee 30 00    	movw   $0x30,-0x12(%ebp)
stressfs.asm:  44:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
stressfs.asm:  53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
stressfs.asm:  65:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
stressfs.asm:  69:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
stressfs.asm:  75:	ff 75 f4             	pushl  -0xc(%ebp)
stressfs.asm:  87:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
stressfs.asm:  8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm:  92:	88 45 ee             	mov    %al,-0x12(%ebp)
stressfs.asm:  9d:	8d 45 e6             	lea    -0x1a(%ebp),%eax
stressfs.asm:  a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm:  ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
stressfs.asm:  bd:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
stressfs.asm:  c4:	ff 75 f0             	pushl  -0x10(%ebp)
stressfs.asm:  cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
stressfs.asm:  d3:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
stressfs.asm:  dc:	ff 75 f0             	pushl  -0x10(%ebp)
stressfs.asm:  fe:	8d 45 e6             	lea    -0x1a(%ebp),%eax
stressfs.asm: 10a:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm: 10d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
stressfs.asm: 11e:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
stressfs.asm: 125:	ff 75 f0             	pushl  -0x10(%ebp)
stressfs.asm: 130:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
stressfs.asm: 134:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
stressfs.asm: 13d:	ff 75 f0             	pushl  -0x10(%ebp)
stressfs.asm: 181:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm: 1a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm:  return (uchar)*p - (uchar)*q;
stressfs.asm: 1ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
stressfs.asm: 1f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
stressfs.asm: 1fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
stressfs.asm: 209:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 231:	88 45 fc             	mov    %al,-0x4(%ebp)
stressfs.asm: 23c:	3a 45 fc             	cmp    -0x4(%ebp),%al
stressfs.asm: 261:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
stressfs.asm: 26f:	8d 45 ef             	lea    -0x11(%ebp),%eax
stressfs.asm: 27d:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm: 280:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
stressfs.asm: 286:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 28c:	89 55 f4             	mov    %edx,-0xc(%ebp)
stressfs.asm: 296:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
stressfs.asm: 29c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
stressfs.asm: 2a4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
stressfs.asm: 2ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 2ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
stressfs.asm: 2e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm: 2e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
stressfs.asm:    return -1;
stressfs.asm: 2f6:	ff 75 f4             	pushl  -0xc(%ebp)
stressfs.asm: 301:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm: 307:	ff 75 f4             	pushl  -0xc(%ebp)
stressfs.asm: 312:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm: 31d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
stressfs.asm:  sign = (*s == '-') ? -1 : 1;
stressfs.asm: 34a:	89 45 f8             	mov    %eax,-0x8(%ebp)
stressfs.asm:  if (*s == '+'  || *s == '-')
stressfs.asm:    n = n*10 + *s++ - '0';
stressfs.asm: 367:	8b 55 fc             	mov    -0x4(%ebp),%edx
stressfs.asm: 389:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm:  sign = (*s == '-') ? -1 : 1;
stressfs.asm:  if (*s == '+'  || *s == '-')
stressfs.asm:    n = n*10 + *s++ - '0';
stressfs.asm: 3a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 3a3:	0f af 45 fc          	imul   -0x4(%ebp),%eax
stressfs.asm: 3af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
stressfs.asm:  sign = (*s == '-') ? -1 : 1;
stressfs.asm: 3dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
stressfs.asm:  if (*s == '+'  || *s == '-')
stressfs.asm:    n = n*8 + *s++ - '0';
stressfs.asm: 3f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 417:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm:  sign = (*s == '-') ? -1 : 1;
stressfs.asm:  if (*s == '+'  || *s == '-')
stressfs.asm:    n = n*8 + *s++ - '0';
stressfs.asm: 42e:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 431:	0f af 45 fc          	imul   -0x4(%ebp),%eax
stressfs.asm: 440:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm: 446:	89 45 f8             	mov    %eax,-0x8(%ebp)
stressfs.asm:  while(n-- > 0)
stressfs.asm: 44b:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 451:	89 55 fc             	mov    %edx,-0x4(%ebp)
stressfs.asm: 454:	8b 55 f8             	mov    -0x8(%ebp),%edx
stressfs.asm: 45a:	89 4d f8             	mov    %ecx,-0x8(%ebp)
stressfs.asm:  while(n-- > 0)
stressfs.asm: 465:	8d 50 ff             	lea    -0x1(%eax),%edx
stressfs.asm:# Added calls - Evghenii
stressfs.asm: 565:	88 45 f4             	mov    %al,-0xc(%ebp)
stressfs.asm: 56d:	8d 45 f4             	lea    -0xc(%ebp),%eax
stressfs.asm: 586:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
stressfs.asm: 599:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
stressfs.asm:    x = -xx;
stressfs.asm: 5a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
stressfs.asm: 5ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
stressfs.asm: 5b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
stressfs.asm: 5b7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
stressfs.asm: 5bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm: 5c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
stressfs.asm: 5d6:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
stressfs.asm: 5dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
stressfs.asm: 5e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
stressfs.asm: 5ea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
stressfs.asm: 5f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
stressfs.asm:    buf[i++] = '-';
stressfs.asm: 5f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 5fc:	89 55 f4             	mov    %edx,-0xc(%ebp)
stressfs.asm: 5ff:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
stressfs.asm:  while(--i >= 0)
stressfs.asm: 606:	8d 55 dc             	lea    -0x24(%ebp),%edx
stressfs.asm: 609:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm:    buf[i++] = '-';
stressfs.asm:  while(--i >= 0)
stressfs.asm: 623:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
stressfs.asm: 627:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
stressfs.asm: 62e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
stressfs.asm: 639:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
stressfs.asm: 646:	89 45 e8             	mov    %eax,-0x18(%ebp)
stressfs.asm: 649:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
stressfs.asm: 658:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm: 668:	89 45 e4             	mov    %eax,-0x1c(%ebp)
stressfs.asm: 66b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
stressfs.asm: 671:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
stressfs.asm: 677:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
stressfs.asm: 683:	8b 45 e4             	mov    -0x1c(%ebp),%eax
stressfs.asm: 69d:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
stressfs.asm: 6a7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
stressfs.asm: 6ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
stressfs.asm: 6c2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
stressfs.asm: 6cb:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
stressfs.asm: 6d1:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
stressfs.asm: 6d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
stressfs.asm: 6ec:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
stressfs.asm: 6f5:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
stressfs.asm: 6fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
stressfs.asm: 700:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm: 703:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
stressfs.asm: 707:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
stressfs.asm: 70d:	c7 45 f4 0c 0a 00 00 	movl   $0xa0c,-0xc(%ebp)
stressfs.asm: 716:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 72e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
stressfs.asm: 732:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 73e:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
stressfs.asm: 744:	8b 45 e8             	mov    -0x18(%ebp),%eax
stressfs.asm: 75b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
stressfs.asm: 761:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
stressfs.asm: 767:	8b 45 e4             	mov    -0x1c(%ebp),%eax
stressfs.asm: 78e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
stressfs.asm: 7a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
stressfs.asm: 7aa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
stressfs.asm: 7b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm:  bp = (Header*)ap - 1;
stressfs.asm: 7d0:	89 45 f8             	mov    %eax,-0x8(%ebp)
stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
stressfs.asm: 7d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
stressfs.asm: 7dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 7e2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
stressfs.asm: 7e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 7ea:	3b 45 fc             	cmp    -0x4(%ebp),%eax
stressfs.asm: 7ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 7f4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
stressfs.asm:  bp = (Header*)ap - 1;
stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
stressfs.asm: 7f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 7fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
stressfs.asm: 801:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 804:	3b 45 fc             	cmp    -0x4(%ebp),%eax
stressfs.asm: 809:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 80e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
stressfs.asm: 813:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 820:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 825:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm:    bp->s.size += p->s.ptr->s.size;
stressfs.asm: 82e:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 834:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 83e:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
stressfs.asm: 844:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 84b:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm:    bp->s.ptr = p->s.ptr;
stressfs.asm: 852:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 857:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm:  if(p + p->s.size == bp){
stressfs.asm: 85c:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 869:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 86e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
stressfs.asm:    p->s.size += bp->s.size;
stressfs.asm: 873:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 879:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 881:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm:    p->s.ptr = bp->s.ptr;
stressfs.asm: 887:	8b 45 f8             	mov    -0x8(%ebp),%eax
stressfs.asm: 88c:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm:    p->s.ptr = bp;
stressfs.asm: 893:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 896:	8b 55 f8             	mov    -0x8(%ebp),%edx
stressfs.asm: 89b:	8b 45 fc             	mov    -0x4(%ebp),%eax
stressfs.asm: 8ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm:  if(p == (char*)-1)
stressfs.asm: 8d1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
stressfs.asm: 8de:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 8e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm:  hp->s.size = nu;
stressfs.asm: 8e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm: 8ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
stressfs.asm: 918:	89 45 ec             	mov    %eax,-0x14(%ebp)
stressfs.asm: 920:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm: 923:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
stressfs.asm: 929:	c7 45 f0 90 0c 00 00 	movl   $0xc90,-0x10(%ebp)
stressfs.asm: 930:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
stressfs.asm: 94c:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm: 951:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm:    if(p->s.size >= nunits){
stressfs.asm: 954:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 95a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
stressfs.asm:      if(p->s.size == nunits)
stressfs.asm: 95f:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 965:	3b 45 ec             	cmp    -0x14(%ebp),%eax
stressfs.asm:        prevp->s.ptr = p->s.ptr;
stressfs.asm: 96a:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm:        p->s.size -= nunits;
stressfs.asm: 976:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 97c:	2b 45 ec             	sub    -0x14(%ebp),%eax
stressfs.asm: 981:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm:        p += p->s.size;
stressfs.asm: 987:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 990:	01 45 f4             	add    %eax,-0xc(%ebp)
stressfs.asm:        p->s.size = nunits;
stressfs.asm: 993:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 996:	8b 55 ec             	mov    -0x14(%ebp),%edx
stressfs.asm: 99c:	8b 45 f0             	mov    -0x10(%ebp),%eax
stressfs.asm: 9a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 9b1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
stressfs.asm: 9b9:	ff 75 ec             	pushl  -0x14(%ebp)
stressfs.asm: 9c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.asm: 9c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
stressfs.asm: 9d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 9d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
stressfs.asm: 9da:	8b 45 f4             	mov    -0xc(%ebp),%eax
stressfs.asm: 9df:	89 45 f4             	mov    %eax,-0xc(%ebp)
stressfs.d:stressfs.o: stressfs.c /usr/include/stdc-predef.h RMME.h types.h stat.h \
Binary file stressfs.o matches
string.c:  while(n-- > 0){
string.c:      return *s1 - *s2;
string.c:    while(n-- > 0)
string.c:      *--d = *--s;
string.c:    while(n-- > 0)
string.c:    n--, p++, q++;
string.c:  return (uchar)*p - (uchar)*q;
string.c:  while(n-- > 0 && (*s++ = *t++) != 0)
string.c:  while(n-- > 0)
string.c:// Like strncpy but guaranteed to NUL-terminate.
string.c:  while(--n > 0 && (*s++ = *t++) != 0)
string.d:string.o: string.c /usr/include/stdc-predef.h RMME.h types.h x86.h
Binary file string.o matches
swtch.S:  # Save old callee-save registers
swtch.S:  # Load new callee-save registers
symlink.patch:diff -r f8a4e40ab1d6 fs.c
symlink.patch:--- a/fs.c	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/fs.c	Thu Aug 30 14:29:02 2007 -0400
symlink.patch:@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
symlink.patch:-_namei(char *path, int parent, char *name)
symlink.patch:     ip = idup(cp->cwd);
symlink.patch:@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
symlink.patch:-    iunlockput(ip);
symlink.patch:+    if(next->type == T_SYMLINK){
symlink.patch:+      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
symlink.patch:+      buf[next->size] = 0;
symlink.patch:@@ -615,11 +635,11 @@ namei(char *path)
symlink.patch:-  return _namei(path, 0, name);
symlink.patch:-  return _namei(path, 1, name);
symlink.patch:-}
symlink.patch:diff -r f8a4e40ab1d6 fs.h
symlink.patch:--- a/fs.h	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400
symlink.patch:@@ -33,6 +33,7 @@ struct dinode {
symlink.patch:diff -r f8a4e40ab1d6 syscall.c
symlink.patch:--- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/syscall.c	Thu Aug 30 13:05:29 2007 -0400
symlink.patch:@@ -96,6 +96,7 @@ extern int sys_unlink(void);
symlink.patch:@@ -118,6 +119,7 @@ static int (*syscalls[])(void) = {
symlink.patch:diff -r f8a4e40ab1d6 syscall.h
symlink.patch:--- a/syscall.h	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/syscall.h	Thu Aug 30 13:02:48 2007 -0400
symlink.patch:@@ -19,3 +19,4 @@
symlink.patch:diff -r f8a4e40ab1d6 sysfile.c
symlink.patch:--- a/sysfile.c	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/sysfile.c	Thu Aug 30 13:10:31 2007 -0400
symlink.patch:@@ -257,6 +257,21 @@ create(char *path, int canexist, short t
symlink.patch:+    return -1;
symlink.patch:+    return -1;
symlink.patch:@@ -393,3 +408,4 @@ sys_pipe(void)
symlink.patch:diff -r f8a4e40ab1d6 user.h
symlink.patch:--- a/user.h	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/user.h	Thu Aug 30 13:02:34 2007 -0400
symlink.patch:@@ -21,6 +21,7 @@ int getpid();
symlink.patch:diff -r f8a4e40ab1d6 usys.S
symlink.patch:--- a/usys.S	Thu Aug 30 14:32:06 2007 -0400
symlink.patch:+++ b/usys.S	Thu Aug 30 13:05:54 2007 -0400
symlink.patch:@@ -28,3 +28,4 @@ STUB(getpid)
syscall.c:  if(addr >= proc->sz || addr+4 > proc->sz)
syscall.c:    return -1;
syscall.c:// Fetch the nul-terminated string at addr from the current process.
syscall.c:// Doesn't actually copy the string - just sets *pp to point at it.
syscall.c:  if(addr >= proc->sz)
syscall.c:    return -1;
syscall.c:  ep = (char*)proc->sz;
syscall.c:      return s - *pp;
syscall.c:  return -1;
syscall.c:// Fetch the nth 32-bit system call argument.
syscall.c:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
syscall.c:// Fetch the nth word-sized system call argument as a pointer
syscall.c:    return -1;
syscall.c:  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
syscall.c:    return -1;
syscall.c:// Fetch the nth word-sized system call argument as a string pointer.
syscall.c:// Check that the pointer is valid and the string is nul-terminated.
syscall.c:    return -1;
syscall.c:// Added entry points - Evghenii
syscall.c:  num = proc->tf->eax;
syscall.c:    proc->tf->eax = syscalls[num]();
syscall.c:    cprintf("%s -> %d \n", syscallnames[num], proc->tf->eax);
syscall.c:            proc->pid, proc->name, num);
syscall.c:    proc->tf->eax = -1;
syscall.d:syscall.o: syscall.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file syscall.o matches
sysfile.c:// File-system system calls.
sysfile.c:// Fetch the nth word-sized system call argument as a file descriptor
sysfile.c:    return -1;
sysfile.c:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
sysfile.c:    return -1;
sysfile.c:    if(proc->ofile[fd] == 0){
sysfile.c:      proc->ofile[fd] = f;
sysfile.c:  return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:  proc->ofile[fd] = 0;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:  if(ip->type == T_DIR){
sysfile.c:    return -1;
sysfile.c:  ip->nlink++;
sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
sysfile.c:  ip->nlink--;
sysfile.c:  return -1;
sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:  if(ip->nlink < 1)
sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
sysfile.c:  if(ip->type == T_DIR){
sysfile.c:    dp->nlink--;
sysfile.c:  ip->nlink--;
sysfile.c:  return -1;
sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
sysfile.c:  ip->major = major;
sysfile.c:  ip->minor = minor;
sysfile.c:  ip->nlink = 1;
sysfile.c:    dp->nlink++;  // for ".."
sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
sysfile.c:    return -1;
sysfile.c:      return -1;
sysfile.c:      return -1;
sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
sysfile.c:      return -1;
sysfile.c:    return -1;
sysfile.c:  f->type = FD_INODE;
sysfile.c:  f->ip = ip;
sysfile.c:  f->off = 0;
sysfile.c:  f->readable = !(omode & O_WRONLY);
sysfile.c:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:  if(ip->type != T_DIR){
sysfile.c:    return -1;
sysfile.c:  iput(proc->cwd);
sysfile.c:  proc->cwd = ip;
sysfile.c:    return -1;
sysfile.c:      return -1;
sysfile.c:      return -1;
sysfile.c:      return -1;
sysfile.c:    return -1;
sysfile.c:    return -1;
sysfile.c:  fd0 = -1;
sysfile.c:      proc->ofile[fd0] = 0;
sysfile.c:    return -1;
sysfile.d:sysfile.o: sysfile.c /usr/include/stdc-predef.h RMME.h types.h defs.h \
Binary file sysfile.o matches
sysproc.c:    return -1;
sysproc.c:  return proc->pid;
sysproc.c:    return -1;
sysproc.c:  addr = proc->sz;
sysproc.c:    return -1;
sysproc.c:    return -1;
sysproc.c:  while(ticks - ticks0 < n){
sysproc.c:    if(proc->killed){
sysproc.c:      return -1;
sysproc.c:// Added functions - Evghenii
sysproc.c:    return -1;
sysproc.c:    return -1;
sysproc.c:    return -1;
sysproc.c:  proc->uid = (uint)uid;
sysproc.c:    return -1;
sysproc.c:    return -1;
sysproc.c:  proc->gid = (uint)gid;
sysproc.c:  return proc->uid;
sysproc.c:  return proc->gid;
sysproc.c:  if(proc->pid == 1) {
sysproc.c:  return proc->parent->pid;
sysproc.c:    return -1;
sysproc.c:    return -1;
sysproc.d:sysproc.o: sysproc.c /usr/include/stdc-predef.h RMME.h types.h x86.h \
Binary file sysproc.o matches
Binary file _time matches
time.asm:_time:     file format elf32-i386
time.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
time.asm:  13:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
time.asm:  1c:	8d 50 ff             	lea    -0x1(%eax),%edx
time.asm:  1f:	89 55 dc             	mov    %edx,-0x24(%ebp)
time.asm:  4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
time.asm:  51:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm:    for(int i = 0; i < argc-1; i++) {
time.asm:  63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
time.asm:  6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
time.asm:  80:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm:  83:	8b 55 e0             	mov    -0x20(%ebp),%edx
time.asm:    for(int i = 0; i < argc-1; i++) {
time.asm:  89:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
time.asm:  92:	3b 45 e0             	cmp    -0x20(%ebp),%eax
time.asm:  97:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm:  a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
time.asm:  b0:	89 45 d0             	mov    %eax,-0x30(%ebp)
time.asm:  b3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
time.asm:  d4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
time.asm:  da:	8b 55 d8             	mov    -0x28(%ebp),%edx
time.asm:  dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm:  ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm:      total_time = uptime() - time_start;
time.asm: 116:	2b 45 d4             	sub    -0x2c(%ebp),%eax
time.asm: 119:	89 45 e4             	mov    %eax,-0x1c(%ebp)
time.asm: 11c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
time.asm: 156:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
time.asm: 190:	8b 75 e4             	mov    -0x1c(%ebp),%esi
time.asm: 1a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
time.asm: 1f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm: 217:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm:  return (uchar)*p - (uchar)*q;
time.asm: 261:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
time.asm: 26a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
time.asm: 26e:	8b 55 fc             	mov    -0x4(%ebp),%edx
time.asm: 27d:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 2a5:	88 45 fc             	mov    %al,-0x4(%ebp)
time.asm: 2b0:	3a 45 fc             	cmp    -0x4(%ebp),%al
time.asm: 2d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
time.asm: 2e3:	8d 45 ef             	lea    -0x11(%ebp),%eax
time.asm: 2f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
time.asm: 2f4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
time.asm: 2fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 300:	89 55 f4             	mov    %edx,-0xc(%ebp)
time.asm: 30a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
time.asm: 310:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
time.asm: 318:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
time.asm: 320:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 32e:	8b 55 f4             	mov    -0xc(%ebp),%edx
time.asm: 354:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm: 357:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
time.asm:    return -1;
time.asm: 36a:	ff 75 f4             	pushl  -0xc(%ebp)
time.asm: 375:	89 45 f0             	mov    %eax,-0x10(%ebp)
time.asm: 37b:	ff 75 f4             	pushl  -0xc(%ebp)
time.asm: 386:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm: 391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
time.asm:  sign = (*s == '-') ? -1 : 1;
time.asm: 3be:	89 45 f8             	mov    %eax,-0x8(%ebp)
time.asm:  if (*s == '+'  || *s == '-')
time.asm:    n = n*10 + *s++ - '0';
time.asm: 3db:	8b 55 fc             	mov    -0x4(%ebp),%edx
time.asm: 3fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm:  sign = (*s == '-') ? -1 : 1;
time.asm:  if (*s == '+'  || *s == '-')
time.asm:    n = n*10 + *s++ - '0';
time.asm: 414:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 417:	0f af 45 fc          	imul   -0x4(%ebp),%eax
time.asm: 423:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
time.asm:  sign = (*s == '-') ? -1 : 1;
time.asm: 450:	89 45 f8             	mov    %eax,-0x8(%ebp)
time.asm:  if (*s == '+'  || *s == '-')
time.asm:    n = n*8 + *s++ - '0';
time.asm: 46d:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 48b:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm:  sign = (*s == '-') ? -1 : 1;
time.asm:  if (*s == '+'  || *s == '-')
time.asm:    n = n*8 + *s++ - '0';
time.asm: 4a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 4a5:	0f af 45 fc          	imul   -0x4(%ebp),%eax
time.asm: 4b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm: 4ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
time.asm:  while(n-- > 0)
time.asm: 4bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 4c5:	89 55 fc             	mov    %edx,-0x4(%ebp)
time.asm: 4c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
time.asm: 4ce:	89 4d f8             	mov    %ecx,-0x8(%ebp)
time.asm:  while(n-- > 0)
time.asm: 4d9:	8d 50 ff             	lea    -0x1(%eax),%edx
time.asm:# Added calls - Evghenii
time.asm: 5d9:	88 45 f4             	mov    %al,-0xc(%ebp)
time.asm: 5e1:	8d 45 f4             	lea    -0xc(%ebp),%eax
time.asm: 5fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
time.asm: 60d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
time.asm:    x = -xx;
time.asm: 619:	89 45 ec             	mov    %eax,-0x14(%ebp)
time.asm: 621:	89 45 ec             	mov    %eax,-0x14(%ebp)
time.asm: 624:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
time.asm: 62b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
time.asm: 631:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm: 637:	8b 45 ec             	mov    -0x14(%ebp),%eax
time.asm: 64a:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
time.asm: 651:	8b 45 ec             	mov    -0x14(%ebp),%eax
time.asm: 65b:	89 45 ec             	mov    %eax,-0x14(%ebp)
time.asm: 65e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
time.asm: 664:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
time.asm:    buf[i++] = '-';
time.asm: 66a:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 670:	89 55 f4             	mov    %edx,-0xc(%ebp)
time.asm: 673:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
time.asm:  while(--i >= 0)
time.asm: 67a:	8d 55 dc             	lea    -0x24(%ebp),%edx
time.asm: 67d:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm:    buf[i++] = '-';
time.asm:  while(--i >= 0)
time.asm: 697:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
time.asm: 69b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
time.asm: 6a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
time.asm: 6ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
time.asm: 6ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
time.asm: 6bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
time.asm: 6cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm: 6dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
time.asm: 6df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
time.asm: 6e5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
time.asm: 6eb:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
time.asm: 6f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
time.asm: 711:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
time.asm: 71b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
time.asm: 721:	8b 45 e8             	mov    -0x18(%ebp),%eax
time.asm: 736:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
time.asm: 73f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
time.asm: 745:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
time.asm: 74b:	8b 45 e8             	mov    -0x18(%ebp),%eax
time.asm: 760:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
time.asm: 769:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
time.asm: 76f:	8b 45 e8             	mov    -0x18(%ebp),%eax
time.asm: 774:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm: 777:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
time.asm: 77b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
time.asm: 781:	c7 45 f4 d0 0a 00 00 	movl   $0xad0,-0xc(%ebp)
time.asm: 78a:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 7a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
time.asm: 7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 7b2:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
time.asm: 7b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
time.asm: 7cf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
time.asm: 7d5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
time.asm: 7db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
time.asm: 802:	8b 45 e4             	mov    -0x1c(%ebp),%eax
time.asm: 817:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
time.asm: 81e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
time.asm: 825:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm:  bp = (Header*)ap - 1;
time.asm: 844:	89 45 f8             	mov    %eax,-0x8(%ebp)
time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
time.asm: 84c:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
time.asm: 851:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 856:	3b 45 fc             	cmp    -0x4(%ebp),%eax
time.asm: 85b:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 85e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
time.asm: 863:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 868:	3b 45 f8             	cmp    -0x8(%ebp),%eax
time.asm:  bp = (Header*)ap - 1;
time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
time.asm: 86d:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 872:	89 45 fc             	mov    %eax,-0x4(%ebp)
time.asm: 875:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 878:	3b 45 fc             	cmp    -0x4(%ebp),%eax
time.asm: 87d:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 882:	3b 45 f8             	cmp    -0x8(%ebp),%eax
time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
time.asm:  if(bp + bp->s.size == p->s.ptr){
time.asm: 887:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 894:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 899:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm:    bp->s.size += p->s.ptr->s.size;
time.asm: 8a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 8a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm:    bp->s.ptr = p->s.ptr->s.ptr;
time.asm: 8b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm:    bp->s.ptr = p->s.ptr;
time.asm: 8c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm:  if(p + p->s.size == bp){
time.asm: 8d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8e2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
time.asm:    p->s.size += bp->s.size;
time.asm: 8e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 8ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 8f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm:    p->s.ptr = bp->s.ptr;
time.asm: 8fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
time.asm: 900:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm:    p->s.ptr = bp;
time.asm: 907:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 90a:	8b 55 f8             	mov    -0x8(%ebp),%edx
time.asm: 90f:	8b 45 fc             	mov    -0x4(%ebp),%eax
time.asm: 942:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm:  if(p == (char*)-1)
time.asm: 945:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
time.asm: 952:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 955:	89 45 f0             	mov    %eax,-0x10(%ebp)
time.asm:  hp->s.size = nu;
time.asm: 958:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm: 961:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
time.asm: 98c:	89 45 ec             	mov    %eax,-0x14(%ebp)
time.asm: 994:	89 45 f0             	mov    %eax,-0x10(%ebp)
time.asm: 997:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
time.asm: 99d:	c7 45 f0 5c 0d 00 00 	movl   $0xd5c,-0x10(%ebp)
time.asm: 9a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
time.asm: 9c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm: 9c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm:    if(p->s.size >= nunits){
time.asm: 9c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 9ce:	3b 45 ec             	cmp    -0x14(%ebp),%eax
time.asm:      if(p->s.size == nunits)
time.asm: 9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 9d9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
time.asm:        prevp->s.ptr = p->s.ptr;
time.asm: 9de:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 9e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm:        p->s.size -= nunits;
time.asm: 9ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: 9f0:	2b 45 ec             	sub    -0x14(%ebp),%eax
time.asm: 9f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm:        p += p->s.size;
time.asm: 9fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: a04:	01 45 f4             	add    %eax,-0xc(%ebp)
time.asm:        p->s.size = nunits;
time.asm: a07:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: a0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
time.asm: a10:	8b 45 f0             	mov    -0x10(%ebp),%eax
time.asm: a18:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: a25:	39 45 f4             	cmp    %eax,-0xc(%ebp)
time.asm: a2d:	ff 75 ec             	pushl  -0x14(%ebp)
time.asm: a38:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.asm: a3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
time.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
time.asm: a48:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: a4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
time.asm: a4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
time.asm: a53:	89 45 f4             	mov    %eax,-0xc(%ebp)
time.c:    for(int i = 0; i < argc-1; i++) {
time.c:      total_time = uptime() - time_start;
time.d:time.o: time.c /usr/include/stdc-predef.h RMME.h types.h user.h
Binary file time.o matches
timer.c:// Frequency of all three count-down timers;
timer.d:timer.o: timer.c /usr/include/stdc-predef.h RMME.h types.h defs.h traps.h \
Binary file timer.o matches
toc.ftr:The source listing is preceded by a cross-reference that lists every defined 
Binary file trapasm.o matches
trapasm.S:  # Set up data and per-cpu segments.
trap.c:// set alignment to 32-bit for ticks. See Intel 64 and IA-32 Architectures
trap.c:  if(tf->trapno == T_SYSCALL){
trap.c:    if(proc->killed)
trap.c:    proc->tf = tf;
trap.c:    if(proc->killed)
trap.c:  switch(tf->trapno){
trap.c:   if(cpu->id == 0){
trap.c:            cpu->id, tf->cs, tf->eip);
trap.c:    if(proc == 0 || (tf->cs&3) == 0){
trap.c:              tf->trapno, cpu->id, tf->eip, rcr2());
trap.c:            "eip 0x%x addr 0x%x--kill proc\n",
trap.c:            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
trap.c:    proc->killed = 1;
trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
trap.c:  if(proc && proc->state == RUNNING &&
trap.c:	  tf->trapno == T_IRQ0+IRQ_TIMER && ticks%SCHED_INTERVAL==0)
trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
trap.d:trap.o: trap.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file trap.o matches
traps.h:// Processor-defined:
traps.h:#define T_NMI            2      // non-maskable interrupt
TRICKS:---
TRICKS:at that point, cp->tf is set to point to a trap frame
TRICKS:---
TRICKS:---
TRICKS:	if(c->ncli++ == 0)
TRICKS:		c->intena = eflags & FL_IF;
TRICKS:Consider a bottom-level pushcli.  
TRICKS:	c->intena = 1;
TRICKS:---
TRICKS:The x86's processor-ordering memory model 
TRICKS:  - all reads in B see the effects of writes in A.
TRICKS:  - all reads in A do *not* see the effects of writes in B.
TRICKS:to memory before the write of lk->locked = 0 in 
TRICKS:will observe CPU0's write of lk->locked = 0 only
TRICKS:---
TRICKS:The code in fork needs to read np->pid before
TRICKS:setting np->state to RUNNABLE.  The following
TRICKS:	  np->state = RUNNABLE;
TRICKS:	  return np->pid; // oops
TRICKS:After setting np->state to RUNNABLE, some other CPU
TRICKS:"return np->pid". Even saving a copy of np->pid before
TRICKS:setting np->state isn't safe, since the compiler is
TRICKS:allowed to re-order statements.
TRICKS:The real code saves a copy of np->pid, then acquires a lock
TRICKS:around the write to np->state. The acquire() prevents the
TRICKS:compiler from re-ordering.
uart.c:  // Acknowledge pre-existing interrupt conditions;
uart.c:    return -1;
uart.c:    return -1;
uart.d:uart.o: uart.c /usr/include/stdc-predef.h RMME.h types.h defs.h param.h \
Binary file uart.o matches
uidgidtest.c:  check_setuid(-1);
ulib.c:  return (uchar)*p - (uchar)*q;
ulib.c:    return -1;
ulib.c:  sign = (*s == '-') ? -1 : 1;
ulib.c:  if (*s == '+'  || *s == '-')
ulib.c:    n = n*10 + *s++ - '0';
ulib.c:  sign = (*s == '-') ? -1 : 1;
ulib.c:  if (*s == '+'  || *s == '-')
ulib.c:    n = n*8 + *s++ - '0';
ulib.c:  while(n-- > 0)
ulib.d:ulib.o: ulib.c /usr/include/stdc-predef.h RMME.h types.h stat.h fcntl.h \
Binary file ulib.o matches
umalloc.c:  bp = (Header*)ap - 1;
umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
umalloc.c:  if(bp + bp->s.size == p->s.ptr){
umalloc.c:    bp->s.size += p->s.ptr->s.size;
umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
umalloc.c:    bp->s.ptr = p->s.ptr;
umalloc.c:  if(p + p->s.size == bp){
umalloc.c:    p->s.size += bp->s.size;
umalloc.c:    p->s.ptr = bp->s.ptr;
umalloc.c:    p->s.ptr = bp;
umalloc.c:  if(p == (char*)-1)
umalloc.c:  hp->s.size = nu;
umalloc.c:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
umalloc.c:    if(p->s.size >= nunits){
umalloc.c:      if(p->s.size == nunits)
umalloc.c:        prevp->s.ptr = p->s.ptr;
umalloc.c:        p->s.size -= nunits;
umalloc.c:        p += p->s.size;
umalloc.c:        p->s.size = nunits;
umalloc.d:umalloc.o: umalloc.c /usr/include/stdc-predef.h RMME.h types.h stat.h \
Binary file umalloc.o matches
user.h:// Added prototypes - Evghenii
Binary file _usertests matches
usertests.asm:_usertests:     file format elf32-i386
usertests.asm:// does chdir() call iput(p->cwd) in a transaction?
usertests.asm:// does exit() call iput(p->cwd) in a transaction?
usertests.asm:     112:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     115:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     136:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     240:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     243:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     264:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     27c:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     27f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     32d:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     330:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     354:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     371:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     374:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     3df:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     3e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     3fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     42f:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     447:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     467:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     47f:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     495:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     499:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
usertests.asm:     4b8:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     4d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     4d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     501:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     50c:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     50f:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
usertests.asm:     54e:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     5ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:     5f2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:     613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     621:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     633:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:     64d:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     663:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     667:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     674:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:     691:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:     694:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:     6b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:     6c9:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:     6d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     6d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:      if(n == MAXFILE - 1){
usertests.asm:     6dd:	81 7d f0 8b 00 00 00 	cmpl   $0x8b,-0x10(%ebp)
usertests.asm:     6ee:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     704:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
usertests.asm:     715:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     732:	3b 45 f0             	cmp    -0x10(%ebp),%eax
usertests.asm:     744:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     75a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:      if(n == MAXFILE - 1){
usertests.asm:     767:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:     7e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     80d:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     813:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     81e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     822:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
usertests.asm:     836:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     83f:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     85a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     85e:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
usertests.asm:     9ca:	8d 45 d8             	lea    -0x28(%ebp),%eax
usertests.asm:     9f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:     9f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     a00:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
usertests.asm:     a0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
usertests.asm:     a19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:     a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:     a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     a31:	89 55 f4             	mov    %edx,-0xc(%ebp)
usertests.asm:     a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:     a40:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:     a44:	81 7d f0 08 04 00 00 	cmpl   $0x408,-0x10(%ebp)
usertests.asm:     a4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
usertests.asm:     a84:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
usertests.asm:     a88:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
usertests.asm:     a93:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
usertests.asm:     a9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
usertests.asm:     aac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
usertests.asm:     ab3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
usertests.asm:     abc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:     ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:     ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     ad9:	89 55 f4             	mov    %edx,-0xc(%ebp)
usertests.asm:     afc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:     b00:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:     b03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
usertests.asm:     b08:	8b 45 ec             	mov    -0x14(%ebp),%eax
usertests.asm:     b0b:	01 45 e4             	add    %eax,-0x1c(%ebp)
usertests.asm:     b0e:	d1 65 e8             	shll   -0x18(%ebp)
usertests.asm:     b11:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     b1b:	c7 45 e8 00 20 00 00 	movl   $0x2000,-0x18(%ebp)
usertests.asm:     b22:	8b 45 d8             	mov    -0x28(%ebp),%eax
usertests.asm:     b28:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:     b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:     b3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:     b46:	81 7d e4 2d 14 00 00 	cmpl   $0x142d,-0x1c(%ebp)
usertests.asm:     b52:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:     b69:	8b 45 d8             	mov    -0x28(%ebp),%eax
usertests.asm:     bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     bca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     bd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     bda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     be5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
usertests.asm:     bf6:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:     bf9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:     bff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:     c0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     c3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     c4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     c5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:     c8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:     cb1:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     cbf:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     ccd:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:     d13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     d21:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     d24:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     d3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:     d49:	3b 45 f0             	cmp    -0x10(%ebp),%eax
usertests.asm:     d67:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     d6b:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
usertests.asm:     da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     daa:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:     dad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:     db7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     dc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     dc3:	8b 55 f4             	mov    -0xc(%ebp),%edx
usertests.asm:     dc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     dcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     dde:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:     de1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:     de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     dee:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:     df4:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     dff:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:     e02:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     e05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     e1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:     e1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:     e39:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:     e4c:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:     eb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:     eb6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:     ed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:     edb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:     ef3:	8d 45 d6             	lea    -0x2a(%ebp),%eax
usertests.asm:     eff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     f0d:	8d 45 d6             	lea    -0x2a(%ebp),%eax
usertests.asm:     f11:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:     f35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     f39:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
usertests.asm:     f42:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:     f55:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:     f72:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:     f75:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:     f92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:     f99:	8b 45 ec             	mov    -0x14(%ebp),%eax
usertests.asm:     f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:     fa1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:     faa:	8d 55 d6             	lea    -0x2a(%ebp),%edx
usertests.asm:     fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     fb9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:     fbd:	8d 55 d6             	lea    -0x2a(%ebp),%edx
usertests.asm:     fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     fcc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
usertests.asm:     fd0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:     fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:     fe1:	8d 45 d6             	lea    -0x2a(%ebp),%eax
usertests.asm:     fe5:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:     ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:     ff3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
usertests.asm:     ffc:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    1017:	81 7d f0 10 27 00 00 	cmpl   $0x2710,-0x10(%ebp)
usertests.asm:    1020:	81 7d ec 10 27 00 00 	cmpl   $0x2710,-0x14(%ebp)
usertests.asm:    103d:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    1040:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    105f:	c7 45 c8 15 50 00 00 	movl   $0x5015,-0x38(%ebp)
usertests.asm:    1066:	c7 45 cc 18 50 00 00 	movl   $0x5018,-0x34(%ebp)
usertests.asm:    106d:	c7 45 d0 1b 50 00 00 	movl   $0x501b,-0x30(%ebp)
usertests.asm:    1074:	c7 45 d4 1e 50 00 00 	movl   $0x501e,-0x2c(%ebp)
usertests.asm:    108d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
usertests.asm:    1099:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    109c:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
usertests.asm:    10a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    10a6:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:    10b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    10b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
usertests.asm:    10d6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
usertests.asm:    10e8:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:    10f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
usertests.asm:    10f6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
usertests.asm:    1113:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    112f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1145:	ff 75 dc             	pushl  -0x24(%ebp)
usertests.asm:    1150:	89 45 d8             	mov    %eax,-0x28(%ebp)
usertests.asm:    1153:	81 7d d8 f4 01 00 00 	cmpl   $0x1f4,-0x28(%ebp)
usertests.asm:    115f:	ff 75 d8             	pushl  -0x28(%ebp)
usertests.asm:    1176:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    117a:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
usertests.asm:    1185:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
usertests.asm:    1189:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
usertests.asm:    1193:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
usertests.asm:    11a1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
usertests.asm:    11a5:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
usertests.asm:    11ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    11b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    11ba:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
usertests.asm:    11be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    11c6:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:    11d1:	89 45 dc             	mov    %eax,-0x24(%ebp)
usertests.asm:    11d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:    11dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    11e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    11f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
usertests.asm:    1215:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    1219:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    121c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
usertests.asm:    1221:	8b 45 d8             	mov    -0x28(%ebp),%eax
usertests.asm:    1224:	01 45 ec             	add    %eax,-0x14(%ebp)
usertests.asm:    1234:	ff 75 dc             	pushl  -0x24(%ebp)
usertests.asm:    123f:	89 45 d8             	mov    %eax,-0x28(%ebp)
usertests.asm:    1242:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
usertests.asm:    124b:	ff 75 dc             	pushl  -0x24(%ebp)
usertests.asm:    1256:	81 7d ec 70 17 00 00 	cmpl   $0x1770,-0x14(%ebp)
usertests.asm:    1262:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    127c:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:    1287:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    128b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
usertests.asm:    12c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    12d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    12d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    12f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    12fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    1303:	88 45 c8             	mov    %al,-0x38(%ebp)
usertests.asm:    1306:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
usertests.asm:    130a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1316:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    131c:	88 45 c9             	mov    %al,-0x37(%ebp)
usertests.asm:    1327:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    1333:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    1336:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    1356:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    1361:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1367:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1371:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1380:	88 45 c9             	mov    %al,-0x37(%ebp)
usertests.asm:    1386:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    13ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    13b1:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
usertests.asm:    13c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    13c4:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
usertests.asm:    13ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    13dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    13e0:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
usertests.asm:    13e6:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
usertests.asm:    13ea:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
usertests.asm:    13ee:	88 45 c9             	mov    %al,-0x37(%ebp)
usertests.asm:    13f1:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
usertests.asm:    13f5:	88 45 c8             	mov    %al,-0x38(%ebp)
usertests.asm:    13f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1404:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    1410:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    1416:	88 45 c8             	mov    %al,-0x38(%ebp)
usertests.asm:    1419:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    141f:	88 45 c9             	mov    %al,-0x37(%ebp)
usertests.asm:    1427:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    1433:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    1436:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    143c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
usertests.asm:    1442:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    144b:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    1463:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1469:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
usertests.asm:    146f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    1478:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    1490:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    1499:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    14a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    14a8:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
usertests.asm:    14b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    14b6:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
usertests.asm:    14c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    14c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    14d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    14d8:	88 45 c8             	mov    %al,-0x38(%ebp)
usertests.asm:    14db:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    14e1:	88 45 c9             	mov    %al,-0x37(%ebp)
usertests.asm:    14e7:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    14f3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    14f7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
usertests.asm:    14fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1501:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
usertests.asm:    1549:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    154c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1573:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    1581:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    159e:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    15a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    15fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    160b:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    1619:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    1631:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    1684:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    16ae:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    172b:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    172e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1755:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    177f:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    1809:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    180c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1836:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    1860:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    printf(1, "link non-existant succeeded! oops\n");
usertests.asm:    1938:	c6 45 e5 43          	movb   $0x43,-0x1b(%ebp)
usertests.asm:    193c:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
usertests.asm:    1940:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    194c:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1952:	88 45 e6             	mov    %al,-0x1a(%ebp)
usertests.asm:    1958:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1969:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    196c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1972:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    1997:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    19ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    19b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    19db:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    19f6:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1a02:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    1a05:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    1a0e:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1a29:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    1a34:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1a44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1a48:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
usertests.asm:    1a59:	8d 45 bd             	lea    -0x43(%ebp),%eax
usertests.asm:    1a77:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    1a7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    1a86:	0f b7 45 ac          	movzwl -0x54(%ebp),%eax
usertests.asm:    1a94:	0f b6 45 ae          	movzbl -0x52(%ebp),%eax
usertests.asm:    1a9c:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
usertests.asm:      i = de.name[1] - '0';
usertests.asm:    1aa4:	0f b6 45 af          	movzbl -0x51(%ebp),%eax
usertests.asm:    1aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    1ab1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    1ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1ac2:	8d 45 ac             	lea    -0x54(%ebp),%eax
usertests.asm:    1add:	8d 55 bd             	lea    -0x43(%ebp),%edx
usertests.asm:    1ae0:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1aef:	8d 45 ac             	lea    -0x54(%ebp),%eax
usertests.asm:    1b0a:	8d 55 bd             	lea    -0x43(%ebp),%edx
usertests.asm:    1b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1b15:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    1b1e:	8d 45 ac             	lea    -0x54(%ebp),%eax
usertests.asm:    1b22:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    1b38:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    1b43:	83 7d f0 28          	cmpl   $0x28,-0x10(%ebp)
usertests.asm:    1b60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1b72:	88 45 e6             	mov    %al,-0x1a(%ebp)
usertests.asm:    1b7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    1b7d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1b9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    1bbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1bc3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    1be5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1bf0:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c0d:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c2a:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c47:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c64:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c73:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c82:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c91:	8d 45 e5             	lea    -0x1b(%ebp),%eax
usertests.asm:    1c9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1cad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1cb1:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
usertests.asm:    1cfd:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    1d00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1d1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1d2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    1d32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    1d4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    1d4f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
usertests.asm:    1d90:	8b 4d f0             	mov    -0x10(%ebp),%ecx
usertests.asm:    1dd4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1dd8:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
usertests.asm:    1de2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    1e46:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    1e49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    1e69:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    1e74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1e7d:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
usertests.asm:    1e81:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1e92:	88 45 e7             	mov    %al,-0x19(%ebp)
usertests.asm:    1e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1ea6:	88 45 e8             	mov    %al,-0x18(%ebp)
usertests.asm:    1ea9:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
usertests.asm:    1eb0:	8d 45 e6             	lea    -0x1a(%ebp),%eax
usertests.asm:    1edc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1ee0:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
usertests.asm:    1ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    1f02:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
usertests.asm:    1f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1f17:	88 45 e7             	mov    %al,-0x19(%ebp)
usertests.asm:    1f1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    1f2b:	88 45 e8             	mov    %al,-0x18(%ebp)
usertests.asm:    1f2e:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
usertests.asm:    1f35:	8d 45 e6             	lea    -0x1a(%ebp),%eax
usertests.asm:    1f5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    1f60:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
usertests.asm:    1fe6:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    1fe9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2010:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    201e:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    printf(1, "unlink dd (non-empty dir) succeeded!\n");
usertests.asm:    2094:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2097:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    20be:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    20cc:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    20e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    20ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2116:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2121:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    2124:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
usertests.asm:    214f:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    22a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    22a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    22cd:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    22f7:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    printf(1, "unlink non-empty dd succeeded!\n");
usertests.asm:    26ea:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%ebp)
usertests.asm:    270b:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    270e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    272b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    2737:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    273f:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    274a:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    274d:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    2750:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    2755:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    2758:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    276f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    2773:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
usertests.asm:    277c:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    2797:	81 45 f4 d7 01 00 00 	addl   $0x1d7,-0xc(%ebp)
usertests.asm:    279e:	81 7d f4 ff 17 00 00 	cmpl   $0x17ff,-0xc(%ebp)
usertests.asm:    27fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    2800:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    281d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    282e:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    284b:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    2874:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    2878:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
usertests.asm:    2881:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    289e:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    28a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    28be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    28c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    28d9:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    28e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    28e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    2904:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    290a:	81 7d e8 2c 01 00 00 	cmpl   $0x12c,-0x18(%ebp)
usertests.asm:    2934:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    294e:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    2975:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    2978:	01 45 f0             	add    %eax,-0x10(%ebp)
usertests.asm:    297b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    2988:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    2993:	81 7d f0 e0 2e 00 00 	cmpl   $0x2ee0,-0x10(%ebp)
usertests.asm:    2a5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2a5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2a7e:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2a9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2a9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2abe:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2ce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2ce9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2d09:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2d51:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2d54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2d86:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2d89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2e69:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2e6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    2e9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    2ea8:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2ed1:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    2f09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    2fa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    2fa8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    2fb1:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    2fd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    2fd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    2fdd:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    2ff8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    2ffc:	83 7d f4 32          	cmpl   $0x32,-0xc(%ebp)
usertests.asm:    3043:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    3051:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    3054:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    305a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    3065:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    3069:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
usertests.asm:    3075:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
usertests.asm:  for(; n > 0; n--){
usertests.asm:  for(; n > 0; n--){
usertests.asm:    30b5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
usertests.asm:    30b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:  if(wait() != -1){
usertests.asm:    311f:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    312f:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3132:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    3148:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    314b:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    314e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    315b:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    315e:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3161:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    3177:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    317d:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    3183:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3186:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    318a:	81 7d f0 87 13 00 00 	cmpl   $0x1387,-0x10(%ebp)
usertests.asm:    3198:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    319b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:    31c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    31d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    31dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    31e2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
usertests.asm:    printf(stdout, "sbrk test failed post-fork\n");
usertests.asm:    3202:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:    321f:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:  amt = (BIG) - (uint)a;
usertests.asm:    3222:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    322e:	89 45 dc             	mov    %eax,-0x24(%ebp)
usertests.asm:    3231:	8b 45 dc             	mov    -0x24(%ebp),%eax
usertests.asm:    3240:	89 45 d8             	mov    %eax,-0x28(%ebp)
usertests.asm:    3243:	8b 45 d8             	mov    -0x28(%ebp),%eax
usertests.asm:    3246:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:  lastaddr = (char*) (BIG-1);
usertests.asm:    3266:	c7 45 d4 ff ff 3f 06 	movl   $0x63fffff,-0x2c(%ebp)
usertests.asm:    326d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
usertests.asm:  // can one de-allocate?
usertests.asm:    3280:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:  c = sbrk(-4096);
usertests.asm:    3293:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    3296:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
usertests.asm:    32c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:  if(c != a - 4096){
usertests.asm:    32c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    32cf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
usertests.asm:    32d9:	ff 75 e0             	pushl  -0x20(%ebp)
usertests.asm:    32dc:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:  // can one re-allocate that page?
usertests.asm:    32ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3312:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    3315:	8b 45 e0             	mov    -0x20(%ebp),%eax
usertests.asm:    3318:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    332c:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
usertests.asm:    333d:	ff 75 e0             	pushl  -0x20(%ebp)
usertests.asm:    3340:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3356:	8b 45 d4             	mov    -0x2c(%ebp),%eax
usertests.asm:    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
usertests.asm:    3388:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:  c = sbrk(-(sbrk(0) - oldbrk));
usertests.asm:    338b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
usertests.asm:    33ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    33ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
usertests.asm:    33b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    33bb:	ff 75 e0             	pushl  -0x20(%ebp)
usertests.asm:    33be:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    33d4:	c7 45 f4 00 00 00 80 	movl   $0x80000000,-0xc(%ebp)
usertests.asm:    33e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
usertests.asm:    33ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    33ed:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:    340e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
usertests.asm:    3414:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    3423:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3437:	ff 75 d0             	pushl  -0x30(%ebp)
usertests.asm:    344c:	81 45 f4 50 c3 00 00 	addl   $0xc350,-0xc(%ebp)
usertests.asm:    3453:	81 7d f4 7f 84 1e 80 	cmpl   $0x801e847f,-0xc(%ebp)
usertests.asm:    345f:	8d 45 c8             	lea    -0x38(%ebp),%eax
usertests.asm:    3486:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    3499:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    349c:	89 54 85 a0          	mov    %edx,-0x60(%ebp,%eax,4)
usertests.asm:    34a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    34a3:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
usertests.asm:      sbrk(BIG - (uint)sbrk(0));
usertests.asm:    34cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
usertests.asm:    if(pids[i] != -1)
usertests.asm:    34f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    34f8:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
usertests.asm:    3501:	8b 45 c8             	mov    -0x38(%ebp),%eax
usertests.asm:    3509:	8d 55 9f             	lea    -0x61(%ebp),%edx
usertests.asm:    3516:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    351a:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    if(pids[i] != -1)
usertests.asm:    3536:	89 45 e0             	mov    %eax,-0x20(%ebp)
usertests.asm:    3539:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    if(pids[i] == -1)
usertests.asm:    3542:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    3545:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
usertests.asm:    354e:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    3551:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
usertests.asm:    if(pids[i] == -1)
usertests.asm:    3569:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    356d:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    if(pids[i] == -1)
usertests.asm:    3575:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
usertests.asm:    35a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
usertests.asm:    sbrk(-(sbrk(0) - oldbrk));
usertests.asm:    35a8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
usertests.asm:    35df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
usertests.asm:    35fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
usertests.asm:    3623:	c7 45 f0 00 30 11 00 	movl   $0x113000,-0x10(%ebp)
usertests.asm:    362a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    363b:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    363e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3644:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    3675:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    if(link("nosuchfile", (char*)p) != -1){
usertests.asm:    3685:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    36b9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
usertests.asm:    36c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    36c3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
usertests.asm:    3701:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    370a:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    3734:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    3738:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:  unlink("bigarg-ok");
usertests.asm:    3776:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    3779:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    for(i = 0; i < MAXARG-1; i++)
usertests.asm:    3783:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    378c:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:  unlink("bigarg-ok");
usertests.asm:    for(i = 0; i < MAXARG-1; i++)
usertests.asm:    379a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    379e:	83 7d f4 1e          	cmpl   $0x1e,-0xc(%ebp)
usertests.asm:    args[MAXARG-1] = 0;
usertests.asm:    fd = open("bigarg-ok", O_CREATE);
usertests.asm:    3804:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    380a:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    381a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:  fd = open("bigarg-ok", 0);
usertests.asm:    3852:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    3855:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3879:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:  unlink("bigarg-ok");
usertests.asm:    389e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    38b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    38be:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
usertests.asm:    38c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    38dd:	88 45 a5             	mov    %al,-0x5b(%ebp)
usertests.asm:    38e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
usertests.asm:    391a:	88 45 a6             	mov    %al,-0x5a(%ebp)
usertests.asm:    391d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
usertests.asm:    3954:	88 45 a7             	mov    %al,-0x59(%ebp)
usertests.asm:    3957:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    397f:	88 45 a8             	mov    %al,-0x58(%ebp)
usertests.asm:    3982:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
usertests.asm:    3989:	8d 45 a4             	lea    -0x5c(%ebp),%eax
usertests.asm:    39a4:	8d 45 a4             	lea    -0x5c(%ebp),%eax
usertests.asm:    39b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    39b3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    39bc:	8d 45 a4             	lea    -0x5c(%ebp),%eax
usertests.asm:    39d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:    39e5:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    39f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    39f3:	81 7d e4 ff 01 00 00 	cmpl   $0x1ff,-0x1c(%ebp)
usertests.asm:    39fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:    39ff:	01 45 ec             	add    %eax,-0x14(%ebp)
usertests.asm:    3a02:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    3a0c:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    3a21:	ff 75 e8             	pushl  -0x18(%ebp)
usertests.asm:    3a2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3a32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    3a41:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
usertests.asm:    3a45:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    3a60:	88 45 a5             	mov    %al,-0x5b(%ebp)
usertests.asm:    3a63:	8b 5d f4             	mov    -0xc(%ebp),%ebx
usertests.asm:    3a9d:	88 45 a6             	mov    %al,-0x5a(%ebp)
usertests.asm:    3aa0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
usertests.asm:    3ad7:	88 45 a7             	mov    %al,-0x59(%ebp)
usertests.asm:    3ada:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    3b02:	88 45 a8             	mov    %al,-0x58(%ebp)
usertests.asm:    3b05:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
usertests.asm:    3b0c:	8d 45 a4             	lea    -0x5c(%ebp),%eax
usertests.asm:    nfiles--;
usertests.asm:    3b18:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
usertests.asm:    3b1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    nfiles--;
usertests.asm:    3b39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
usertests.asm:    3b63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    3b6a:	c7 45 f0 ff 7f 00 00 	movl   $0x7fff,-0x10(%ebp)
usertests.asm:    3b95:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    3b9b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    3ba3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
usertests.asm:    3ba8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3bda:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3bf7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:  printf(1, "getuid (expected %d)-> ", lastuid);
usertests.asm:    3c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3c38:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3c4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    3c84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    3c8b:	c7 45 f0 ff 7f 00 00 	movl   $0x7fff,-0x10(%ebp)
usertests.asm:    3cb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    3cbc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    3cc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
usertests.asm:    3cc9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3cfb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    3d18:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:  printf(1, "getgid (expected %d)-> ", lastgid);
usertests.asm:    3d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3d59:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    3daa:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    3db2:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    3dba:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    3dc0:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3dd5:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    3dea:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    3e13:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    3e16:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    3e33:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
usertests.asm:    printf(1, "[child] getppid (expected %d)->", parent_pid);
usertests.asm:    3e58:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    3e6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    3e75:	ff 75 e4             	pushl  -0x1c(%ebp)
usertests.asm:    3e87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:    3e8a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
usertests.asm:    3eca:	ff 75 f0             	pushl  -0x10(%ebp)
usertests.asm:    3eea:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    3f09:	ff 71 fc             	pushl  -0x4(%ecx)
usertests.asm:    printf(1, "already ran user tests -- rebuild fs.img\n");
usertests.asm:  check_setuid(-1);
usertests.asm:  check_setgid(-1);
usertests.asm:    4191:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:    41b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:  return (uchar)*p - (uchar)*q;
usertests.asm:    41fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
usertests.asm:    4206:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
usertests.asm:    420a:	8b 55 fc             	mov    -0x4(%ebp),%edx
usertests.asm:    4219:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4241:	88 45 fc             	mov    %al,-0x4(%ebp)
usertests.asm:    424c:	3a 45 fc             	cmp    -0x4(%ebp),%al
usertests.asm:    4271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    427f:	8d 45 ef             	lea    -0x11(%ebp),%eax
usertests.asm:    428d:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    4290:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    4296:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    429c:	89 55 f4             	mov    %edx,-0xc(%ebp)
usertests.asm:    42a6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
usertests.asm:    42ac:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
usertests.asm:    42b4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
usertests.asm:    42bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    42ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
usertests.asm:    42f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    42f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    return -1;
usertests.asm:    4306:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    4311:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    4317:	ff 75 f4             	pushl  -0xc(%ebp)
usertests.asm:    4322:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    432d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
usertests.asm:  sign = (*s == '-') ? -1 : 1;
usertests.asm:    435a:	89 45 f8             	mov    %eax,-0x8(%ebp)
usertests.asm:  if (*s == '+'  || *s == '-')
usertests.asm:    n = n*10 + *s++ - '0';
usertests.asm:    4377:	8b 55 fc             	mov    -0x4(%ebp),%edx
usertests.asm:    4399:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:  sign = (*s == '-') ? -1 : 1;
usertests.asm:  if (*s == '+'  || *s == '-')
usertests.asm:    n = n*10 + *s++ - '0';
usertests.asm:    43b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    43b3:	0f af 45 fc          	imul   -0x4(%ebp),%eax
usertests.asm:    43bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
usertests.asm:  sign = (*s == '-') ? -1 : 1;
usertests.asm:    43ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
usertests.asm:  if (*s == '+'  || *s == '-')
usertests.asm:    n = n*8 + *s++ - '0';
usertests.asm:    4409:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4427:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:  sign = (*s == '-') ? -1 : 1;
usertests.asm:  if (*s == '+'  || *s == '-')
usertests.asm:    n = n*8 + *s++ - '0';
usertests.asm:    443e:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4441:	0f af 45 fc          	imul   -0x4(%ebp),%eax
usertests.asm:    4450:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:    4456:	89 45 f8             	mov    %eax,-0x8(%ebp)
usertests.asm:  while(n-- > 0)
usertests.asm:    445b:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4461:	89 55 fc             	mov    %edx,-0x4(%ebp)
usertests.asm:    4464:	8b 55 f8             	mov    -0x8(%ebp),%edx
usertests.asm:    446a:	89 4d f8             	mov    %ecx,-0x8(%ebp)
usertests.asm:  while(n-- > 0)
usertests.asm:    4475:	8d 50 ff             	lea    -0x1(%eax),%edx
usertests.asm:# Added calls - Evghenii
usertests.asm:    4575:	88 45 f4             	mov    %al,-0xc(%ebp)
usertests.asm:    457d:	8d 45 f4             	lea    -0xc(%ebp),%eax
usertests.asm:    4596:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    45a9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
usertests.asm:    x = -xx;
usertests.asm:    45b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    45bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    45c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
usertests.asm:    45c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
usertests.asm:    45cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    45d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
usertests.asm:    45e6:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
usertests.asm:    45ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
usertests.asm:    45f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    45fa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    4600:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    buf[i++] = '-';
usertests.asm:    4606:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    460c:	89 55 f4             	mov    %edx,-0xc(%ebp)
usertests.asm:    460f:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
usertests.asm:  while(--i >= 0)
usertests.asm:    4616:	8d 55 dc             	lea    -0x24(%ebp),%edx
usertests.asm:    4619:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    buf[i++] = '-';
usertests.asm:  while(--i >= 0)
usertests.asm:    4633:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
usertests.asm:    4637:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    463e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
usertests.asm:    4649:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:    4656:	89 45 e8             	mov    %eax,-0x18(%ebp)
usertests.asm:    4659:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
usertests.asm:    4668:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    4678:	89 45 e4             	mov    %eax,-0x1c(%ebp)
usertests.asm:    467b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
usertests.asm:    4681:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
usertests.asm:    4687:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
usertests.asm:    4693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:    46ad:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
usertests.asm:    46b7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
usertests.asm:    46bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    46d2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
usertests.asm:    46db:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
usertests.asm:    46e1:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
usertests.asm:    46e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    46fc:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
usertests.asm:    4705:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
usertests.asm:    470b:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    4710:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    4713:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
usertests.asm:    4717:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:    471d:	c7 45 f4 21 63 00 00 	movl   $0x6321,-0xc(%ebp)
usertests.asm:    4726:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    473e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
usertests.asm:    4742:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    474e:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
usertests.asm:    4754:	8b 45 e8             	mov    -0x18(%ebp),%eax
usertests.asm:    476b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
usertests.asm:    4771:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
usertests.asm:    4777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:    479e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
usertests.asm:    47b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
usertests.asm:    47ba:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
usertests.asm:    47c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:  bp = (Header*)ap - 1;
usertests.asm:    47e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
usertests.asm:    47e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
usertests.asm:    47ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    47f2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
usertests.asm:    47f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    47fa:	3b 45 fc             	cmp    -0x4(%ebp),%eax
usertests.asm:    47ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4804:	3b 45 f8             	cmp    -0x8(%ebp),%eax
usertests.asm:  bp = (Header*)ap - 1;
usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
usertests.asm:    4809:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    480e:	89 45 fc             	mov    %eax,-0x4(%ebp)
usertests.asm:    4811:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4814:	3b 45 fc             	cmp    -0x4(%ebp),%eax
usertests.asm:    4819:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    481e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
usertests.asm:  if(bp + bp->s.size == p->s.ptr){
usertests.asm:    4823:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4830:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4835:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    bp->s.size += p->s.ptr->s.size;
usertests.asm:    483e:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4844:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    484e:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    bp->s.ptr = p->s.ptr->s.ptr;
usertests.asm:    4854:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    485b:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    bp->s.ptr = p->s.ptr;
usertests.asm:    4862:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4867:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:  if(p + p->s.size == bp){
usertests.asm:    486c:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4879:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    487e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
usertests.asm:    p->s.size += bp->s.size;
usertests.asm:    4883:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    4889:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    4891:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    p->s.ptr = bp->s.ptr;
usertests.asm:    4897:	8b 45 f8             	mov    -0x8(%ebp),%eax
usertests.asm:    489c:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    p->s.ptr = bp;
usertests.asm:    48a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    48a6:	8b 55 f8             	mov    -0x8(%ebp),%edx
usertests.asm:    48ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
usertests.asm:    48de:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:  if(p == (char*)-1)
usertests.asm:    48e1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
usertests.asm:    48ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    48f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:  hp->s.size = nu;
usertests.asm:    48f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    48fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
usertests.asm:    4928:	89 45 ec             	mov    %eax,-0x14(%ebp)
usertests.asm:    4930:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    4933:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
usertests.asm:    4939:	c7 45 f0 80 6b 00 00 	movl   $0x6b80,-0x10(%ebp)
usertests.asm:    4940:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
usertests.asm:    495c:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    4961:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    if(p->s.size >= nunits){
usertests.asm:    4964:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    496a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
usertests.asm:      if(p->s.size == nunits)
usertests.asm:    496f:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    4975:	3b 45 ec             	cmp    -0x14(%ebp),%eax
usertests.asm:        prevp->s.ptr = p->s.ptr;
usertests.asm:    497a:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    497f:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:        p->s.size -= nunits;
usertests.asm:    4986:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    498c:	2b 45 ec             	sub    -0x14(%ebp),%eax
usertests.asm:    4991:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:        p += p->s.size;
usertests.asm:    4997:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    49a0:	01 45 f4             	add    %eax,-0xc(%ebp)
usertests.asm:        p->s.size = nunits;
usertests.asm:    49a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    49a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
usertests.asm:    49ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
usertests.asm:    49b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    49c1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
usertests.asm:    49c9:	ff 75 ec             	pushl  -0x14(%ebp)
usertests.asm:    49d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.asm:    49d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
usertests.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
usertests.asm:    49e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    49e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
usertests.asm:    49ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
usertests.asm:    49ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
usertests.c:// does chdir() call iput(p->cwd) in a transaction?
usertests.c:// does exit() call iput(p->cwd) in a transaction?
usertests.c://      return -1;
usertests.c:      if(n == MAXFILE - 1){
usertests.c:    printf(1, "link non-existant succeeded! oops\n");
usertests.c:      i = de.name[1] - '0';
usertests.c:    printf(1, "unlink dd (non-empty dir) succeeded!\n");
usertests.c:    printf(1, "unlink non-empty dd succeeded!\n");
usertests.c:  for(; n > 0; n--){
usertests.c:  if(wait() != -1){
usertests.c:    printf(stdout, "sbrk test failed post-fork\n");
usertests.c:  amt = (BIG) - (uint)a;
usertests.c:  lastaddr = (char*) (BIG-1);
usertests.c:  // can one de-allocate?
usertests.c:  c = sbrk(-4096);
usertests.c:  if(c != a - 4096){
usertests.c:  // can one re-allocate that page?
usertests.c:    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
usertests.c:    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
usertests.c:  c = sbrk(-(sbrk(0) - oldbrk));
usertests.c:      sbrk(BIG - (uint)sbrk(0));
usertests.c:    if(pids[i] != -1)
usertests.c:    if(pids[i] == -1)
usertests.c:    sbrk(-(sbrk(0) - oldbrk));
usertests.c:    if(link("nosuchfile", (char*)p) != -1){
usertests.c:  unlink("bigarg-ok");
usertests.c:    for(i = 0; i < MAXARG-1; i++)
usertests.c:    args[MAXARG-1] = 0;
usertests.c:    fd = open("bigarg-ok", O_CREATE);
usertests.c:  fd = open("bigarg-ok", 0);
usertests.c:  unlink("bigarg-ok");
usertests.c:    nfiles--;
usertests.c:  printf(1, "getuid (expected %d)-> ", lastuid);
usertests.c:  printf(1, "getgid (expected %d)-> ", lastgid);
usertests.c:    printf(1, "[child] getppid (expected %d)->", parent_pid);
usertests.c:    printf(1, "already ran user tests -- rebuild fs.img\n");
usertests.c:  check_setuid(-1);
usertests.c:  check_setgid(-1);
usertests.d:usertests.o: usertests.c /usr/include/stdc-predef.h RMME.h param.h \
Binary file usertests.o matches
usys.S:# Added calls - Evghenii
Binary file vectors.o matches
vectors.pl:#!/usr/bin/perl -w
vectors.pl:print "# generated by vectors.pl - do not edit\n";
vectors.S:# generated by vectors.pl - do not edit
vm.c:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
vm.c:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
vm.c:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
vm.c:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
vm.c:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
vm.c:  lgdt(c->gdt, sizeof(c->gdt));
vm.c:  // Initialize cpu-local storage.
vm.c:// be page-aligned.
vm.c:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
vm.c:      return -1;
vm.c:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
vm.c:                (uint)k->phys_start, k->perm) < 0)
vm.c:// Switch h/w page table register to the kernel-only page table,
vm.c:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
vm.c:  cpu->gdt[SEG_TSS].s = 0;
vm.c:  cpu->ts.ss0 = SEG_KDATA << 3;
vm.c:  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
vm.c:  if(p->pgdir == 0)
vm.c:  lcr3(v2p(p->pgdir));  // switch to new address space
vm.c:// Load a program segment into pgdir.  addr must be page-aligned
vm.c:    if(sz - i < PGSIZE)
vm.c:      n = sz - i;
vm.c:      return -1;
vm.c:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
vm.c:      a += (NPTENTRIES - 1) * PGSIZE;
vm.c:      return -1;
vm.c:    n = PGSIZE - (va - va0);
vm.c:    memmove(pa0 + (va - va0), buf, n);
vm.c:    len -= n;
vm.d:vm.o: vm.c /usr/include/stdc-predef.h RMME.h param.h types.h defs.h x86.h \
Binary file vm.o matches
Binary file _wc matches
wc.asm:_wc:     file format elf32-i386
wc.asm:   6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
wc.asm:   d:	8b 45 e8             	mov    -0x18(%ebp),%eax
wc.asm:  10:	89 45 ec             	mov    %eax,-0x14(%ebp)
wc.asm:  13:	8b 45 ec             	mov    -0x14(%ebp),%eax
wc.asm:  16:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm:  19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
wc.asm:  22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
wc.asm:  2b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
wc.asm:  2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm:  3e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
wc.asm:  42:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm:  65:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
wc.asm:  6e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
wc.asm:  74:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
wc.asm:  78:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
wc.asm:  7f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
wc.asm:  83:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm:  86:	3b 45 e0             	cmp    -0x20(%ebp),%eax
wc.asm:  a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
wc.asm:  a6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
wc.asm:  b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
wc.asm:  d3:	ff 75 e8             	pushl  -0x18(%ebp)
wc.asm:  d6:	ff 75 ec             	pushl  -0x14(%ebp)
wc.asm:  d9:	ff 75 f0             	pushl  -0x10(%ebp)
wc.asm:  f5:	ff 71 fc             	pushl  -0x4(%ecx)
wc.asm: 11e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
wc.asm: 12a:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 149:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm: 14c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
wc.asm: 152:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 17b:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 190:	ff 75 f0             	pushl  -0x10(%ebp)
wc.asm: 19e:	ff 75 f0             	pushl  -0x10(%ebp)
wc.asm: 1a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
wc.asm: 1ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 1ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm: 20e:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm:  return (uchar)*p - (uchar)*q;
wc.asm: 258:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
wc.asm: 261:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
wc.asm: 265:	8b 55 fc             	mov    -0x4(%ebp),%edx
wc.asm: 274:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 29c:	88 45 fc             	mov    %al,-0x4(%ebp)
wc.asm: 2a7:	3a 45 fc             	cmp    -0x4(%ebp),%al
wc.asm: 2cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
wc.asm: 2da:	8d 45 ef             	lea    -0x11(%ebp),%eax
wc.asm: 2e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm: 2eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
wc.asm: 2f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 2f7:	89 55 f4             	mov    %edx,-0xc(%ebp)
wc.asm: 301:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
wc.asm: 307:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
wc.asm: 30f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
wc.asm: 317:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 325:	8b 55 f4             	mov    -0xc(%ebp),%edx
wc.asm: 34b:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm: 34e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
wc.asm:    return -1;
wc.asm: 361:	ff 75 f4             	pushl  -0xc(%ebp)
wc.asm: 36c:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm: 372:	ff 75 f4             	pushl  -0xc(%ebp)
wc.asm: 37d:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm: 388:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
wc.asm:  sign = (*s == '-') ? -1 : 1;
wc.asm: 3b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
wc.asm:  if (*s == '+'  || *s == '-')
wc.asm:    n = n*10 + *s++ - '0';
wc.asm: 3d2:	8b 55 fc             	mov    -0x4(%ebp),%edx
wc.asm: 3f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm:  sign = (*s == '-') ? -1 : 1;
wc.asm:  if (*s == '+'  || *s == '-')
wc.asm:    n = n*10 + *s++ - '0';
wc.asm: 40b:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 40e:	0f af 45 fc          	imul   -0x4(%ebp),%eax
wc.asm: 41a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
wc.asm:  sign = (*s == '-') ? -1 : 1;
wc.asm: 447:	89 45 f8             	mov    %eax,-0x8(%ebp)
wc.asm:  if (*s == '+'  || *s == '-')
wc.asm:    n = n*8 + *s++ - '0';
wc.asm: 464:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 482:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm:  sign = (*s == '-') ? -1 : 1;
wc.asm:  if (*s == '+'  || *s == '-')
wc.asm:    n = n*8 + *s++ - '0';
wc.asm: 499:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 49c:	0f af 45 fc          	imul   -0x4(%ebp),%eax
wc.asm: 4ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm: 4b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
wc.asm:  while(n-- > 0)
wc.asm: 4b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 4bc:	89 55 fc             	mov    %edx,-0x4(%ebp)
wc.asm: 4bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
wc.asm: 4c5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
wc.asm:  while(n-- > 0)
wc.asm: 4d0:	8d 50 ff             	lea    -0x1(%eax),%edx
wc.asm:# Added calls - Evghenii
wc.asm: 5d0:	88 45 f4             	mov    %al,-0xc(%ebp)
wc.asm: 5d8:	8d 45 f4             	lea    -0xc(%ebp),%eax
wc.asm: 5f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
wc.asm: 604:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
wc.asm:    x = -xx;
wc.asm: 610:	89 45 ec             	mov    %eax,-0x14(%ebp)
wc.asm: 618:	89 45 ec             	mov    %eax,-0x14(%ebp)
wc.asm: 61b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
wc.asm: 622:	8b 4d f4             	mov    -0xc(%ebp),%ecx
wc.asm: 628:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm: 62e:	8b 45 ec             	mov    -0x14(%ebp),%eax
wc.asm: 641:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
wc.asm: 648:	8b 45 ec             	mov    -0x14(%ebp),%eax
wc.asm: 652:	89 45 ec             	mov    %eax,-0x14(%ebp)
wc.asm: 655:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
wc.asm: 65b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
wc.asm:    buf[i++] = '-';
wc.asm: 661:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 667:	89 55 f4             	mov    %edx,-0xc(%ebp)
wc.asm: 66a:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
wc.asm:  while(--i >= 0)
wc.asm: 671:	8d 55 dc             	lea    -0x24(%ebp),%edx
wc.asm: 674:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm:    buf[i++] = '-';
wc.asm:  while(--i >= 0)
wc.asm: 68e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
wc.asm: 692:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
wc.asm: 699:	8b 5d fc             	mov    -0x4(%ebp),%ebx
wc.asm: 6a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
wc.asm: 6b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
wc.asm: 6b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
wc.asm: 6c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm: 6d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
wc.asm: 6d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
wc.asm: 6dc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
wc.asm: 6e2:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
wc.asm: 6ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
wc.asm: 708:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
wc.asm: 712:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
wc.asm: 718:	8b 45 e8             	mov    -0x18(%ebp),%eax
wc.asm: 72d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
wc.asm: 736:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
wc.asm: 73c:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
wc.asm: 742:	8b 45 e8             	mov    -0x18(%ebp),%eax
wc.asm: 757:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
wc.asm: 760:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
wc.asm: 766:	8b 45 e8             	mov    -0x18(%ebp),%eax
wc.asm: 76b:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm: 76e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
wc.asm: 772:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
wc.asm: 778:	c7 45 f4 8c 0a 00 00 	movl   $0xa8c,-0xc(%ebp)
wc.asm: 781:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 799:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
wc.asm: 79d:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 7a9:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
wc.asm: 7af:	8b 45 e8             	mov    -0x18(%ebp),%eax
wc.asm: 7c6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
wc.asm: 7cc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
wc.asm: 7d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
wc.asm: 7f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
wc.asm: 80e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
wc.asm: 815:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
wc.asm: 81c:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm:  bp = (Header*)ap - 1;
wc.asm: 83b:	89 45 f8             	mov    %eax,-0x8(%ebp)
wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
wc.asm: 843:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
wc.asm: 848:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 84d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
wc.asm: 852:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 855:	3b 45 fc             	cmp    -0x4(%ebp),%eax
wc.asm: 85a:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 85f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
wc.asm:  bp = (Header*)ap - 1;
wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
wc.asm: 864:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 869:	89 45 fc             	mov    %eax,-0x4(%ebp)
wc.asm: 86c:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 86f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
wc.asm: 874:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 879:	3b 45 f8             	cmp    -0x8(%ebp),%eax
wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
wc.asm:  if(bp + bp->s.size == p->s.ptr){
wc.asm: 87e:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 88b:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 890:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm:    bp->s.size += p->s.ptr->s.size;
wc.asm: 899:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 89f:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
wc.asm: 8af:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm:    bp->s.ptr = p->s.ptr;
wc.asm: 8bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm:  if(p + p->s.size == bp){
wc.asm: 8c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8d9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
wc.asm:    p->s.size += bp->s.size;
wc.asm: 8de:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 8e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 8ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm:    p->s.ptr = bp->s.ptr;
wc.asm: 8f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
wc.asm: 8f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm:    p->s.ptr = bp;
wc.asm: 8fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 901:	8b 55 f8             	mov    -0x8(%ebp),%edx
wc.asm: 906:	8b 45 fc             	mov    -0x4(%ebp),%eax
wc.asm: 939:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm:  if(p == (char*)-1)
wc.asm: 93c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
wc.asm: 949:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 94c:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm:  hp->s.size = nu;
wc.asm: 94f:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm: 958:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
wc.asm: 983:	89 45 ec             	mov    %eax,-0x14(%ebp)
wc.asm: 98b:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm: 98e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
wc.asm: 994:	c7 45 f0 40 0d 00 00 	movl   $0xd40,-0x10(%ebp)
wc.asm: 99b:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
wc.asm: 9b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm: 9bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm:    if(p->s.size >= nunits){
wc.asm: 9bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 9c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
wc.asm:      if(p->s.size == nunits)
wc.asm: 9ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 9d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
wc.asm:        prevp->s.ptr = p->s.ptr;
wc.asm: 9d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 9da:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm:        p->s.size -= nunits;
wc.asm: 9e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 9e7:	2b 45 ec             	sub    -0x14(%ebp),%eax
wc.asm: 9ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm:        p += p->s.size;
wc.asm: 9f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: 9fb:	01 45 f4             	add    %eax,-0xc(%ebp)
wc.asm:        p->s.size = nunits;
wc.asm: 9fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: a01:	8b 55 ec             	mov    -0x14(%ebp),%edx
wc.asm: a07:	8b 45 f0             	mov    -0x10(%ebp),%eax
wc.asm: a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: a1c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
wc.asm: a24:	ff 75 ec             	pushl  -0x14(%ebp)
wc.asm: a2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.asm: a32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
wc.asm: a3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: a42:	89 45 f0             	mov    %eax,-0x10(%ebp)
wc.asm: a45:	8b 45 f4             	mov    -0xc(%ebp),%eax
wc.asm: a4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
wc.d:wc.o: wc.c /usr/include/stdc-predef.h RMME.h types.h stat.h user.h
Binary file wc.o matches
x86.h:  pd[0] = size-1;
x86.h:  pd[0] = size-1;
x86.h:  // The + in "+m" denotes a read-modify-write operand.
Binary file xv6.img matches
Binary file _zf matches
zf.asm:_zf:     file format elf32-i386
zf.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
zf.asm:  45:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm:  67:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm:  return (uchar)*p - (uchar)*q;
zf.asm:  b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zf.asm:  ba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
zf.asm:  be:	8b 55 fc             	mov    -0x4(%ebp),%edx
zf.asm:  cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm:  f5:	88 45 fc             	mov    %al,-0x4(%ebp)
zf.asm: 100:	3a 45 fc             	cmp    -0x4(%ebp),%al
zf.asm: 125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
zf.asm: 133:	8d 45 ef             	lea    -0x11(%ebp),%eax
zf.asm: 141:	89 45 f0             	mov    %eax,-0x10(%ebp)
zf.asm: 144:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zf.asm: 14a:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 150:	89 55 f4             	mov    %edx,-0xc(%ebp)
zf.asm: 15a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zf.asm: 160:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zf.asm: 168:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zf.asm: 170:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 17e:	8b 55 f4             	mov    -0xc(%ebp),%edx
zf.asm: 1a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm: 1a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zf.asm:    return -1;
zf.asm: 1ba:	ff 75 f4             	pushl  -0xc(%ebp)
zf.asm: 1c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
zf.asm: 1cb:	ff 75 f4             	pushl  -0xc(%ebp)
zf.asm: 1d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm: 1e1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zf.asm:  sign = (*s == '-') ? -1 : 1;
zf.asm: 20e:	89 45 f8             	mov    %eax,-0x8(%ebp)
zf.asm:  if (*s == '+'  || *s == '-')
zf.asm:    n = n*10 + *s++ - '0';
zf.asm: 22b:	8b 55 fc             	mov    -0x4(%ebp),%edx
zf.asm: 24d:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm:  sign = (*s == '-') ? -1 : 1;
zf.asm:  if (*s == '+'  || *s == '-')
zf.asm:    n = n*10 + *s++ - '0';
zf.asm: 264:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 267:	0f af 45 fc          	imul   -0x4(%ebp),%eax
zf.asm: 273:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zf.asm:  sign = (*s == '-') ? -1 : 1;
zf.asm: 2a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
zf.asm:  if (*s == '+'  || *s == '-')
zf.asm:    n = n*8 + *s++ - '0';
zf.asm: 2bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 2db:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm:  sign = (*s == '-') ? -1 : 1;
zf.asm:  if (*s == '+'  || *s == '-')
zf.asm:    n = n*8 + *s++ - '0';
zf.asm: 2f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 2f5:	0f af 45 fc          	imul   -0x4(%ebp),%eax
zf.asm: 304:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm: 30a:	89 45 f8             	mov    %eax,-0x8(%ebp)
zf.asm:  while(n-- > 0)
zf.asm: 30f:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 315:	89 55 fc             	mov    %edx,-0x4(%ebp)
zf.asm: 318:	8b 55 f8             	mov    -0x8(%ebp),%edx
zf.asm: 31e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
zf.asm:  while(n-- > 0)
zf.asm: 329:	8d 50 ff             	lea    -0x1(%eax),%edx
zf.asm:# Added calls - Evghenii
zf.asm: 429:	88 45 f4             	mov    %al,-0xc(%ebp)
zf.asm: 431:	8d 45 f4             	lea    -0xc(%ebp),%eax
zf.asm: 44a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
zf.asm: 45d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
zf.asm:    x = -xx;
zf.asm: 469:	89 45 ec             	mov    %eax,-0x14(%ebp)
zf.asm: 471:	89 45 ec             	mov    %eax,-0x14(%ebp)
zf.asm: 474:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
zf.asm: 47b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
zf.asm: 481:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm: 487:	8b 45 ec             	mov    -0x14(%ebp),%eax
zf.asm: 49a:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
zf.asm: 4a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
zf.asm: 4ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
zf.asm: 4ae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
zf.asm: 4b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zf.asm:    buf[i++] = '-';
zf.asm: 4ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 4c0:	89 55 f4             	mov    %edx,-0xc(%ebp)
zf.asm: 4c3:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
zf.asm:  while(--i >= 0)
zf.asm: 4ca:	8d 55 dc             	lea    -0x24(%ebp),%edx
zf.asm: 4cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm:    buf[i++] = '-';
zf.asm:  while(--i >= 0)
zf.asm: 4e7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
zf.asm: 4eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zf.asm: 4f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
zf.asm: 4fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
zf.asm: 50a:	89 45 e8             	mov    %eax,-0x18(%ebp)
zf.asm: 50d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
zf.asm: 51c:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm: 52c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
zf.asm: 52f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
zf.asm: 535:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
zf.asm: 53b:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
zf.asm: 547:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zf.asm: 561:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
zf.asm: 56b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
zf.asm: 571:	8b 45 e8             	mov    -0x18(%ebp),%eax
zf.asm: 586:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zf.asm: 58f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
zf.asm: 595:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
zf.asm: 59b:	8b 45 e8             	mov    -0x18(%ebp),%eax
zf.asm: 5b0:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zf.asm: 5b9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
zf.asm: 5bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
zf.asm: 5c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm: 5c7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zf.asm: 5cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zf.asm: 5d1:	c7 45 f4 ad 08 00 00 	movl   $0x8ad,-0xc(%ebp)
zf.asm: 5da:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 5f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
zf.asm: 5f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 602:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
zf.asm: 608:	8b 45 e8             	mov    -0x18(%ebp),%eax
zf.asm: 61f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zf.asm: 625:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
zf.asm: 62b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zf.asm: 652:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zf.asm: 667:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
zf.asm: 66e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
zf.asm: 675:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm:  bp = (Header*)ap - 1;
zf.asm: 694:	89 45 f8             	mov    %eax,-0x8(%ebp)
zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zf.asm: 69c:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zf.asm: 6a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 6a6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zf.asm: 6ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 6ae:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zf.asm: 6b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 6b8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zf.asm:  bp = (Header*)ap - 1;
zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zf.asm: 6bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 6c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
zf.asm: 6c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 6c8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zf.asm: 6cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 6d2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zf.asm:  if(bp + bp->s.size == p->s.ptr){
zf.asm: 6d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 6e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 6e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm:    bp->s.size += p->s.ptr->s.size;
zf.asm: 6f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 6f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 702:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm:    bp->s.ptr = p->s.ptr->s.ptr;
zf.asm: 708:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 70f:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm:    bp->s.ptr = p->s.ptr;
zf.asm: 716:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 71b:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm:  if(p + p->s.size == bp){
zf.asm: 720:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 72d:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 732:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zf.asm:    p->s.size += bp->s.size;
zf.asm: 737:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 73d:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 745:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm:    p->s.ptr = bp->s.ptr;
zf.asm: 74b:	8b 45 f8             	mov    -0x8(%ebp),%eax
zf.asm: 750:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm:    p->s.ptr = bp;
zf.asm: 757:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 75a:	8b 55 f8             	mov    -0x8(%ebp),%edx
zf.asm: 75f:	8b 45 fc             	mov    -0x4(%ebp),%eax
zf.asm: 792:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm:  if(p == (char*)-1)
zf.asm: 795:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
zf.asm: 7a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 7a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
zf.asm:  hp->s.size = nu;
zf.asm: 7a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm: 7b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
zf.asm: 7dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
zf.asm: 7e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
zf.asm: 7e7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zf.asm: 7ed:	c7 45 f0 30 0b 00 00 	movl   $0xb30,-0x10(%ebp)
zf.asm: 7f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zf.asm: 810:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm: 815:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm:    if(p->s.size >= nunits){
zf.asm: 818:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 81e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
zf.asm:      if(p->s.size == nunits)
zf.asm: 823:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 829:	3b 45 ec             	cmp    -0x14(%ebp),%eax
zf.asm:        prevp->s.ptr = p->s.ptr;
zf.asm: 82e:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 833:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm:        p->s.size -= nunits;
zf.asm: 83a:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 840:	2b 45 ec             	sub    -0x14(%ebp),%eax
zf.asm: 845:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm:        p += p->s.size;
zf.asm: 84b:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 854:	01 45 f4             	add    %eax,-0xc(%ebp)
zf.asm:        p->s.size = nunits;
zf.asm: 857:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 85a:	8b 55 ec             	mov    -0x14(%ebp),%edx
zf.asm: 860:	8b 45 f0             	mov    -0x10(%ebp),%eax
zf.asm: 868:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 875:	39 45 f4             	cmp    %eax,-0xc(%ebp)
zf.asm: 87d:	ff 75 ec             	pushl  -0x14(%ebp)
zf.asm: 888:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.asm: 88b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zf.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zf.asm: 898:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 89b:	89 45 f0             	mov    %eax,-0x10(%ebp)
zf.asm: 89e:	8b 45 f4             	mov    -0xc(%ebp),%eax
zf.asm: 8a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
zf.d:zf.o: zf.c /usr/include/stdc-predef.h types.h user.h
Binary file zf.o matches
Binary file _zombie matches
zombie.asm:_zombie:     file format elf32-i386
zombie.asm:   7:	ff 71 fc             	pushl  -0x4(%ecx)
zombie.asm:  5b:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm:  7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm:  return (uchar)*p - (uchar)*q;
zombie.asm:  c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zombie.asm:  d0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
zombie.asm:  d4:	8b 55 fc             	mov    -0x4(%ebp),%edx
zombie.asm:  e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 10b:	88 45 fc             	mov    %al,-0x4(%ebp)
zombie.asm: 116:	3a 45 fc             	cmp    -0x4(%ebp),%al
zombie.asm: 13b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
zombie.asm: 149:	8d 45 ef             	lea    -0x11(%ebp),%eax
zombie.asm: 157:	89 45 f0             	mov    %eax,-0x10(%ebp)
zombie.asm: 15a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zombie.asm: 160:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 166:	89 55 f4             	mov    %edx,-0xc(%ebp)
zombie.asm: 170:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zombie.asm: 176:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zombie.asm: 17e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
zombie.asm: 186:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 194:	8b 55 f4             	mov    -0xc(%ebp),%edx
zombie.asm: 1ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm: 1bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zombie.asm:    return -1;
zombie.asm: 1d0:	ff 75 f4             	pushl  -0xc(%ebp)
zombie.asm: 1db:	89 45 f0             	mov    %eax,-0x10(%ebp)
zombie.asm: 1e1:	ff 75 f4             	pushl  -0xc(%ebp)
zombie.asm: 1ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm: 1f7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zombie.asm:  sign = (*s == '-') ? -1 : 1;
zombie.asm: 224:	89 45 f8             	mov    %eax,-0x8(%ebp)
zombie.asm:  if (*s == '+'  || *s == '-')
zombie.asm:    n = n*10 + *s++ - '0';
zombie.asm: 241:	8b 55 fc             	mov    -0x4(%ebp),%edx
zombie.asm: 263:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm:  sign = (*s == '-') ? -1 : 1;
zombie.asm:  if (*s == '+'  || *s == '-')
zombie.asm:    n = n*10 + *s++ - '0';
zombie.asm: 27a:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 27d:	0f af 45 fc          	imul   -0x4(%ebp),%eax
zombie.asm: 289:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
zombie.asm:  sign = (*s == '-') ? -1 : 1;
zombie.asm: 2b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
zombie.asm:  if (*s == '+'  || *s == '-')
zombie.asm:    n = n*8 + *s++ - '0';
zombie.asm: 2d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 2f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm:  sign = (*s == '-') ? -1 : 1;
zombie.asm:  if (*s == '+'  || *s == '-')
zombie.asm:    n = n*8 + *s++ - '0';
zombie.asm: 308:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 30b:	0f af 45 fc          	imul   -0x4(%ebp),%eax
zombie.asm: 31a:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm: 320:	89 45 f8             	mov    %eax,-0x8(%ebp)
zombie.asm:  while(n-- > 0)
zombie.asm: 325:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 32b:	89 55 fc             	mov    %edx,-0x4(%ebp)
zombie.asm: 32e:	8b 55 f8             	mov    -0x8(%ebp),%edx
zombie.asm: 334:	89 4d f8             	mov    %ecx,-0x8(%ebp)
zombie.asm:  while(n-- > 0)
zombie.asm: 33f:	8d 50 ff             	lea    -0x1(%eax),%edx
zombie.asm:# Added calls - Evghenii
zombie.asm: 43f:	88 45 f4             	mov    %al,-0xc(%ebp)
zombie.asm: 447:	8d 45 f4             	lea    -0xc(%ebp),%eax
zombie.asm: 460:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
zombie.asm: 473:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
zombie.asm:    x = -xx;
zombie.asm: 47f:	89 45 ec             	mov    %eax,-0x14(%ebp)
zombie.asm: 487:	89 45 ec             	mov    %eax,-0x14(%ebp)
zombie.asm: 48a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
zombie.asm: 491:	8b 4d f4             	mov    -0xc(%ebp),%ecx
zombie.asm: 497:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm: 49d:	8b 45 ec             	mov    -0x14(%ebp),%eax
zombie.asm: 4b0:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
zombie.asm: 4b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
zombie.asm: 4c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
zombie.asm: 4c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
zombie.asm: 4ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zombie.asm:    buf[i++] = '-';
zombie.asm: 4d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 4d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
zombie.asm: 4d9:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
zombie.asm:  while(--i >= 0)
zombie.asm: 4e0:	8d 55 dc             	lea    -0x24(%ebp),%edx
zombie.asm: 4e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm:    buf[i++] = '-';
zombie.asm:  while(--i >= 0)
zombie.asm: 4fd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
zombie.asm: 501:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zombie.asm: 508:	8b 5d fc             	mov    -0x4(%ebp),%ebx
zombie.asm: 513:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
zombie.asm: 520:	89 45 e8             	mov    %eax,-0x18(%ebp)
zombie.asm: 523:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
zombie.asm: 532:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm: 542:	89 45 e4             	mov    %eax,-0x1c(%ebp)
zombie.asm: 545:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
zombie.asm: 54b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
zombie.asm: 551:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
zombie.asm: 55d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zombie.asm: 577:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
zombie.asm: 581:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
zombie.asm: 587:	8b 45 e8             	mov    -0x18(%ebp),%eax
zombie.asm: 59c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zombie.asm: 5a5:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
zombie.asm: 5ab:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
zombie.asm: 5b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
zombie.asm: 5c6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zombie.asm: 5cf:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
zombie.asm: 5d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
zombie.asm: 5da:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm: 5dd:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zombie.asm: 5e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zombie.asm: 5e7:	c7 45 f4 c3 08 00 00 	movl   $0x8c3,-0xc(%ebp)
zombie.asm: 5f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 608:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
zombie.asm: 60c:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 618:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
zombie.asm: 61e:	8b 45 e8             	mov    -0x18(%ebp),%eax
zombie.asm: 635:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
zombie.asm: 63b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
zombie.asm: 641:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zombie.asm: 668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
zombie.asm: 67d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
zombie.asm: 684:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
zombie.asm: 68b:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm:  bp = (Header*)ap - 1;
zombie.asm: 6aa:	89 45 f8             	mov    %eax,-0x8(%ebp)
zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zombie.asm: 6b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zombie.asm: 6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 6bc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zombie.asm: 6c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 6c4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zombie.asm: 6c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 6ce:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zombie.asm:  bp = (Header*)ap - 1;
zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zombie.asm: 6d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 6d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
zombie.asm: 6db:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 6de:	3b 45 fc             	cmp    -0x4(%ebp),%eax
zombie.asm: 6e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 6e8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zombie.asm:  if(bp + bp->s.size == p->s.ptr){
zombie.asm: 6ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 6fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 6ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm:    bp->s.size += p->s.ptr->s.size;
zombie.asm: 708:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 70e:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 718:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
zombie.asm: 71e:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 725:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm:    bp->s.ptr = p->s.ptr;
zombie.asm: 72c:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 731:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm:  if(p + p->s.size == bp){
zombie.asm: 736:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 743:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 748:	3b 45 f8             	cmp    -0x8(%ebp),%eax
zombie.asm:    p->s.size += bp->s.size;
zombie.asm: 74d:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 753:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 75b:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm:    p->s.ptr = bp->s.ptr;
zombie.asm: 761:	8b 45 f8             	mov    -0x8(%ebp),%eax
zombie.asm: 766:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm:    p->s.ptr = bp;
zombie.asm: 76d:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 770:	8b 55 f8             	mov    -0x8(%ebp),%edx
zombie.asm: 775:	8b 45 fc             	mov    -0x4(%ebp),%eax
zombie.asm: 7a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm:  if(p == (char*)-1)
zombie.asm: 7ab:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
zombie.asm: 7b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 7bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
zombie.asm:  hp->s.size = nu;
zombie.asm: 7be:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm: 7c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
zombie.asm: 7f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
zombie.asm: 7fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
zombie.asm: 7fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
zombie.asm: 803:	c7 45 f0 48 0b 00 00 	movl   $0xb48,-0x10(%ebp)
zombie.asm: 80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zombie.asm: 826:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm: 82b:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm:    if(p->s.size >= nunits){
zombie.asm: 82e:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 834:	3b 45 ec             	cmp    -0x14(%ebp),%eax
zombie.asm:      if(p->s.size == nunits)
zombie.asm: 839:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 83f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
zombie.asm:        prevp->s.ptr = p->s.ptr;
zombie.asm: 844:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 849:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm:        p->s.size -= nunits;
zombie.asm: 850:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 856:	2b 45 ec             	sub    -0x14(%ebp),%eax
zombie.asm: 85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm:        p += p->s.size;
zombie.asm: 861:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 86a:	01 45 f4             	add    %eax,-0xc(%ebp)
zombie.asm:        p->s.size = nunits;
zombie.asm: 86d:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 870:	8b 55 ec             	mov    -0x14(%ebp),%edx
zombie.asm: 876:	8b 45 f0             	mov    -0x10(%ebp),%eax
zombie.asm: 87e:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 88b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
zombie.asm: 893:	ff 75 ec             	pushl  -0x14(%ebp)
zombie.asm: 89e:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.asm: 8a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zombie.asm: 8ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 8b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
zombie.asm: 8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
zombie.asm: 8b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
zombie.d:zombie.o: zombie.c /usr/include/stdc-predef.h RMME.h types.h stat.h \
Binary file _zombieFree matches
Binary file zombie.o matches
