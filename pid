cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
cat.asm:  if(bp + bp->s.size == p->s.ptr){
cat.asm:    bp->s.size += p->s.ptr->s.size;
cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
cat.asm:    bp->s.ptr = p->s.ptr;
cat.asm:  if(p + p->s.size == bp){
cat.asm:    p->s.size += bp->s.size;
cat.asm:    p->s.ptr = bp->s.ptr;
cat.asm:    p->s.ptr = bp;
cat.asm:  hp->s.size = nu;
cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
cat.asm:    if(p->s.size >= nunits){
cat.asm:      if(p->s.size == nunits)
cat.asm:        prevp->s.ptr = p->s.ptr;
cat.asm:        p->s.size -= nunits;
cat.asm:        p += p->s.size;
cat.asm:        p->s.size = nunits;
cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
date.asm:  if(bp + bp->s.size == p->s.ptr){
date.asm:    bp->s.size += p->s.ptr->s.size;
date.asm:    bp->s.ptr = p->s.ptr->s.ptr;
date.asm:    bp->s.ptr = p->s.ptr;
date.asm:  if(p + p->s.size == bp){
date.asm:    p->s.size += bp->s.size;
date.asm:    p->s.ptr = bp->s.ptr;
date.asm:    p->s.ptr = bp;
date.asm:  hp->s.size = nu;
date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
date.asm:    if(p->s.size >= nunits){
date.asm:      if(p->s.size == nunits)
date.asm:        prevp->s.ptr = p->s.ptr;
date.asm:        p->s.size -= nunits;
date.asm:        p += p->s.size;
date.asm:        p->s.size = nunits;
date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
echo.asm:  if(bp + bp->s.size == p->s.ptr){
echo.asm:    bp->s.size += p->s.ptr->s.size;
echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
echo.asm:    bp->s.ptr = p->s.ptr;
echo.asm:  if(p + p->s.size == bp){
echo.asm:    p->s.size += bp->s.size;
echo.asm:    p->s.ptr = bp->s.ptr;
echo.asm:    p->s.ptr = bp;
echo.asm:  hp->s.size = nu;
echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
echo.asm:    if(p->s.size >= nunits){
echo.asm:      if(p->s.size == nunits)
echo.asm:        prevp->s.ptr = p->s.ptr;
echo.asm:        p->s.size -= nunits;
echo.asm:        p += p->s.size;
echo.asm:        p->s.size = nunits;
echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
fs.c:  memmove(sb, bp->data, sizeof(*sb));
fs.c:  memset(bp->data, 0, BSIZE);
fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
fs.c:  if((bp->data[bi/8] & m) == 0)
fs.c:  bp->data[bi/8] &= ~m;
fs.c:// not stored on disk: ip->ref and ip->flags.
fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
fs.c://   is set in ip->flags. ilock() reads the inode from
fs.c://   I_VALID if ip->ref has fallen to zero.
fs.c://   ... examine and modify ip->xxx ...
fs.c:// pathname lookup. iget() increments ip->ref so that the inode
fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
fs.c:    if(dip->type == 0){  // a free inode
fs.c:      dip->type = type;
fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
fs.c:  dip->type = ip->type;
fs.c:  dip->major = ip->major;
fs.c:  dip->minor = ip->minor;
fs.c:  dip->nlink = ip->nlink;
fs.c:  dip->size = ip->size;
fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
fs.c:      ip->ref++;
fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
fs.c:  ip->dev = dev;
fs.c:  ip->inum = inum;
fs.c:  ip->ref = 1;
fs.c:  ip->flags = 0;
fs.c:  ip->ref++;
fs.c:  if(ip == 0 || ip->ref < 1)
fs.c:  while(ip->flags & I_BUSY)
fs.c:  ip->flags |= I_BUSY;
fs.c:  if(!(ip->flags & I_VALID)){
fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
fs.c:    ip->type = dip->type;
fs.c:    ip->major = dip->major;
fs.c:    ip->minor = dip->minor;
fs.c:    ip->nlink = dip->nlink;
fs.c:    ip->size = dip->size;
fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
fs.c:    ip->flags |= I_VALID;
fs.c:    if(ip->type == 0)
fs.c:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
fs.c:  ip->flags &= ~I_BUSY;
fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
fs.c:    if(ip->flags & I_BUSY)
fs.c:    ip->flags |= I_BUSY;
fs.c:    ip->type = 0;
fs.c:    ip->flags = 0;
fs.c:  ip->ref--;
fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are 
fs.c:// listed in block ip->addrs[NDIRECT].
fs.c:    if((addr = ip->addrs[bn]) == 0)
fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
fs.c:    bp = bread(ip->dev, addr);
fs.c:    a = (uint*)bp->data;
fs.c:      a[bn] = addr = balloc(ip->dev);
fs.c:    if(ip->addrs[i]){
fs.c:      bfree(ip->dev, ip->addrs[i]);
fs.c:      ip->addrs[i] = 0;
fs.c:  if(ip->addrs[NDIRECT]){
fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
fs.c:    a = (uint*)bp->data;
fs.c:        bfree(ip->dev, a[j]);
fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
fs.c:    ip->addrs[NDIRECT] = 0;
fs.c:  ip->size = 0;
fs.c:  st->dev = ip->dev;
fs.c:  st->ino = ip->inum;
fs.c:  st->type = ip->type;
fs.c:  st->nlink = ip->nlink;
fs.c:  st->size = ip->size;
fs.c:  if(ip->type == T_DEV){
fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
fs.c:    return devsw[ip->major].read(ip, dst, n);
fs.c:  if(off > ip->size || off + n < off)
fs.c:  if(off + n > ip->size)
fs.c:    n = ip->size - off;
fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
fs.c:    memmove(dst, bp->data + off%BSIZE, m);
fs.c:  if(ip->type == T_DEV){
fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
fs.c:    return devsw[ip->major].write(ip, src, n);
fs.c:  if(off > ip->size || off + n < off)
fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
fs.c:    memmove(bp->data + off%BSIZE, src, m);
fs.c:  if(n > 0 && off > ip->size){
fs.c:    ip->size = off;
fs.c:  if(dp->type != T_DIR)
fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
fs.c:      return iget(dp->dev, inum);
fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
fs.c:    if(ip->type != T_DIR){
Binary file fs.img matches
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm:             (cp->elapsed_ticks) % 10,
gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
gp.asm:  if(bp + bp->s.size == p->s.ptr){
gp.asm:    bp->s.size += p->s.ptr->s.size;
gp.asm:    bp->s.ptr = p->s.ptr->s.ptr;
gp.asm:    bp->s.ptr = p->s.ptr;
gp.asm:  if(p + p->s.size == bp){
gp.asm:    p->s.size += bp->s.size;
gp.asm:    p->s.ptr = bp->s.ptr;
gp.asm:    p->s.ptr = bp;
gp.asm:  hp->s.size = nu;
gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
gp.asm:    if(p->s.size >= nunits){
gp.asm:      if(p->s.size == nunits)
gp.asm:        prevp->s.ptr = p->s.ptr;
gp.asm:        p->s.size -= nunits;
gp.asm:        p += p->s.size;
gp.asm:        p->s.size = nunits;
gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
gp.c:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
gp.c:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
gp.c:             (cp->elapsed_ticks) % 10,
gp.c:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
grep.asm:  if(bp + bp->s.size == p->s.ptr){
grep.asm:    bp->s.size += p->s.ptr->s.size;
grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
grep.asm:    bp->s.ptr = p->s.ptr;
grep.asm:  if(p + p->s.size == bp){
grep.asm:    p->s.size += bp->s.size;
grep.asm:    p->s.ptr = bp->s.ptr;
grep.asm:    p->s.ptr = bp;
grep.asm:  hp->s.size = nu;
grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
grep.asm:    if(p->s.size >= nunits){
grep.asm:      if(p->s.size == nunits)
grep.asm:        prevp->s.ptr = p->s.ptr;
grep.asm:        p->s.size -= nunits;
grep.asm:        p += p->s.size;
grep.asm:        p->s.size = nunits;
grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
halt.asm:  if(bp + bp->s.size == p->s.ptr){
halt.asm:    bp->s.size += p->s.ptr->s.size;
halt.asm:    bp->s.ptr = p->s.ptr->s.ptr;
halt.asm:    bp->s.ptr = p->s.ptr;
halt.asm:  if(p + p->s.size == bp){
halt.asm:    p->s.size += bp->s.size;
halt.asm:    p->s.ptr = bp->s.ptr;
halt.asm:    p->s.ptr = bp;
halt.asm:  hp->s.size = nu;
halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
halt.asm:    if(p->s.size >= nunits){
halt.asm:      if(p->s.size == nunits)
halt.asm:        prevp->s.ptr = p->s.ptr;
halt.asm:        p->s.size -= nunits;
halt.asm:        p += p->s.size;
halt.asm:        p->s.size = nunits;
halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
init.asm:  if(bp + bp->s.size == p->s.ptr){
init.asm:    bp->s.size += p->s.ptr->s.size;
init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
init.asm:    bp->s.ptr = p->s.ptr;
init.asm:  if(p + p->s.size == bp){
init.asm:    p->s.size += bp->s.size;
init.asm:    p->s.ptr = bp->s.ptr;
init.asm:    p->s.ptr = bp;
init.asm:  hp->s.size = nu;
init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
init.asm:    if(p->s.size >= nunits){
init.asm:      if(p->s.size == nunits)
init.asm:        prevp->s.ptr = p->s.ptr;
init.asm:        p->s.size -= nunits;
init.asm:        p += p->s.size;
init.asm:        p->s.size = nunits;
init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
kernel.asm:  memset(bp->data, 0, BSIZE);
kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
kernel.asm:  if((bp->data[bi/8] & m) == 0)
kernel.asm:  bp->data[bi/8] &= ~m;
kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
kernel.asm:    if(dip->type == 0){  // a free inode
kernel.asm:      dip->type = type;
kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel.asm:  dip->type = ip->type;
kernel.asm:  dip->major = ip->major;
kernel.asm:  dip->minor = ip->minor;
kernel.asm:  dip->nlink = ip->nlink;
kernel.asm:  dip->size = ip->size;
kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel.asm:      ip->ref++;
kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel.asm:  ip->dev = dev;
kernel.asm:  ip->inum = inum;
kernel.asm:  ip->ref = 1;
kernel.asm:  ip->flags = 0;
kernel.asm:  ip->ref++;
kernel.asm:  if(ip == 0 || ip->ref < 1)
kernel.asm:  while(ip->flags & I_BUSY)
kernel.asm:  if(ip == 0 || ip->ref < 1)
kernel.asm:  while(ip->flags & I_BUSY)
kernel.asm:  ip->flags |= I_BUSY;
kernel.asm:  if(!(ip->flags & I_VALID)){
kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel.asm:    ip->type = dip->type;
kernel.asm:    ip->major = dip->major;
kernel.asm:    ip->minor = dip->minor;
kernel.asm:    ip->nlink = dip->nlink;
kernel.asm:    ip->size = dip->size;
kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel.asm:    ip->flags |= I_VALID;
kernel.asm:    if(ip->type == 0)
kernel.asm:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
kernel.asm:  ip->flags &= ~I_BUSY;
kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
kernel.asm:    if(ip->flags & I_BUSY)
kernel.asm:    ip->flags |= I_BUSY;
kernel.asm:    ip->type = 0;
kernel.asm:    ip->flags = 0;
kernel.asm:  ip->ref--;
kernel.asm:    if((addr = ip->addrs[bn]) == 0)
kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel.asm:    bp = bread(ip->dev, addr);
kernel.asm:    a = (uint*)bp->data;
kernel.asm:      a[bn] = addr = balloc(ip->dev);
kernel.asm:    if(ip->addrs[i]){
kernel.asm:      bfree(ip->dev, ip->addrs[i]);
kernel.asm:      ip->addrs[i] = 0;
kernel.asm:      bfree(ip->dev, ip->addrs[i]);
kernel.asm:      ip->addrs[i] = 0;
kernel.asm:  if(ip->addrs[NDIRECT]){
kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:    a = (uint*)bp->data;
kernel.asm:        bfree(ip->dev, a[j]);
kernel.asm:  if(ip->addrs[NDIRECT]){
kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:    a = (uint*)bp->data;
kernel.asm:        bfree(ip->dev, a[j]);
kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel.asm:    ip->addrs[NDIRECT] = 0;
kernel.asm:  ip->size = 0;
kernel.asm:  st->dev = ip->dev;
kernel.asm:  st->ino = ip->inum;
kernel.asm:  st->type = ip->type;
kernel.asm:  st->nlink = ip->nlink;
kernel.asm:  st->size = ip->size;
kernel.asm:  if(ip->type == T_DEV){
kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
kernel.asm:    return devsw[ip->major].read(ip, dst, n);
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:  if(off + n > ip->size)
kernel.asm:    n = ip->size - off;
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:  if(off + n > ip->size)
kernel.asm:    n = ip->size - off;
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
kernel.asm:  if(ip->type == T_DEV){
kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
kernel.asm:    return devsw[ip->major].write(ip, src, n);
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
kernel.asm:  if(off > ip->size || off + n < off)
kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
kernel.asm:  if(n > 0 && off > ip->size){
kernel.asm:    ip->size = off;
kernel.asm:  if(dp->type != T_DIR)
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:      return iget(dp->dev, inum);
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:  if(dp->type != T_DIR)
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:      return iget(dp->dev, inum);
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel.asm:    if(ip->type != T_DIR){
kernel.asm://   modify bp->data[]
kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
kernel.asm:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
kernel.asm:  if(mp->imcrp){
kernel.asm:  p->readopen = 1;
kernel.asm:  p->writeopen = 1;
kernel.asm:  p->nwrite = 0;
kernel.asm:  p->nread = 0;
kernel.asm:  initlock(&p->lock, "pipe");
kernel.asm:  acquire(&p->lock);
kernel.asm:    p->writeopen = 0;
kernel.asm:    wakeup(&p->nread);
kernel.asm:    p->readopen = 0;
kernel.asm:    wakeup(&p->nwrite);
kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
kernel.asm:    release(&p->lock);
kernel.asm:    release(&p->lock);
kernel.asm:  acquire(&p->lock);
kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
kernel.asm:      if(p->readopen == 0 || proc->killed){
kernel.asm:        release(&p->lock);
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:  acquire(&p->lock);
kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
kernel.asm:  acquire(&p->lock);
kernel.asm:      wakeup(&p->nread);
kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
kernel.asm:  release(&p->lock);
kernel.asm:  acquire(&p->lock);
kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
kernel.asm:      release(&p->lock);
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:  acquire(&p->lock);
kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
kernel.asm:      release(&p->lock);
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:    if(p->nread == p->nwrite)
kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
kernel.asm:      release(&p->lock);
kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
kernel.asm:    if(p->nread == p->nwrite)
kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
kernel.asm:  release(&p->lock);
kernel.asm:    if(p->state == UNUSED)
kernel.asm:    if(p->state == UNUSED)
kernel.asm:  p->state = EMBRYO;
kernel.asm:  p->pid = nextpid++;
kernel.asm:  if((p->kstack = kalloc()) == 0){
kernel.asm:    p->state = UNUSED;
kernel.asm:    p->state = UNUSED;
kernel.asm:  sp = p->kstack + KSTACKSIZE;
kernel.asm:  sp -= sizeof *p->tf;
kernel.asm:  p->tf = (struct trapframe*)sp;
kernel.asm:  sp -= sizeof *p->context;
kernel.asm:  p->context = (struct context*)sp;
kernel.asm:  memset(p->context, 0, sizeof *p->context);
kernel.asm:  p->context->eip = (uint)forkret;
kernel.asm:  p->start_ticks = ticks;
kernel.asm:  p->cpu_ticks_in = 0;
kernel.asm:  p->cpu_ticks_total = 0;
kernel.asm:  if((p->pgdir = setupkvm()) == 0)
kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
kernel.asm:  p->sz = PGSIZE;
kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
kernel.asm:  p->tf->es = p->tf->ds;
kernel.asm:  p->tf->ss = p->tf->ds;
kernel.asm:  p->tf->eflags = FL_IF;
kernel.asm:  p->tf->esp = PGSIZE;
kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
kernel.asm:  p->uid = DEFUID;
kernel.asm:  p->gid = DEFGID;
kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
kernel.asm:  p->cwd = namei("/");
kernel.asm:  p->state = RUNNABLE;
kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
kernel.asm:    kfree(np->kstack);
kernel.asm:    np->kstack = 0;
kernel.asm:    np->state = UNUSED;
kernel.asm:  np->sz = proc->sz;
kernel.asm:  np->parent = proc;
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:  np->tf->eax = 0;
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:  np->tf->eax = 0;
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
kernel.asm:  pid = np->pid;
kernel.asm:  np->uid = proc->uid;
kernel.asm:  np->gid = proc->gid;
kernel.asm:  // lock to force the compiler to emit the np->state write last.
kernel.asm:  np->state = RUNNABLE;
kernel.asm:      if(p->parent == proc) {
kernel.asm:        p->parent = initproc;
kernel.asm:        if(p->state == ZOMBIE)
kernel.asm:      p = p->next;
kernel.asm:      p = p->next;
kernel.asm:        if (p->parent == proc) {
kernel.asm:          if (p->state == ZOMBIE) {
kernel.asm:            pid = p->pid;
kernel.asm:            kfree(p->kstack);
kernel.asm:            p->kstack = 0;
kernel.asm:            freevm(p->pgdir);
kernel.asm:            p->pid = 0;
kernel.asm:            p->parent = 0;
kernel.asm:            p->name[0] = 0;
kernel.asm:            p->killed = 0;
kernel.asm:            p->state = UNUSED;
kernel.asm:        p = p->next;
kernel.asm:      p->state = RUNNING;
kernel.asm:      p->cpu_ticks_in = ticks;
kernel.asm:      // It should have changed its p->state before coming back.
kernel.asm:  // change p->state and then call sched.
kernel.asm:      p->state = RUNNABLE;
kernel.asm:    if(p->chan == chan) {
kernel.asm:      p = p->next;
kernel.asm:      p = p->next;
kernel.asm:      p = p->next;
kernel.asm:      if(p->pid == pid) {
kernel.asm:        p->killed = 1;
kernel.asm:        if(p->state == SLEEPING) {
kernel.asm:          p->state = RUNNABLE;
kernel.asm:      p = p->next;
kernel.asm:      p = p->next;
kernel.asm:    if(p->state == UNUSED)
kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel.asm:      state = states[p->state];
kernel.asm:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
kernel.asm:      elaps       = (ticks - p->start_ticks);
kernel.asm:      cputick_1    = p->cpu_ticks_total/1000;       // CPU time in seconds
kernel.asm:      cputick_10   = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
kernel.asm:      cputick_100  = (p->cpu_ticks_total/10)%10;
kernel.asm:      cputick_1000 = (p->cpu_ticks_total%10); 
kernel.asm:      if(p->pid == 1)
kernel.asm:        ppid = p->parent->pid;
kernel.asm:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d%d%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
kernel.asm:    if(p->state == SLEEPING){
kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
kernel.asm:    if(p->state == SLEEPING){
kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
kernel.asm:    if(p->state == UNUSED)
kernel.asm:    if(p->state != EMBRYO && p->state != UNUSED) {
kernel.asm:      procs->pid = p->pid;
kernel.asm:      procs->uid = p->uid;
kernel.asm:      procs->gid = p->gid;
kernel.asm:      if(p->pid == 1)
kernel.asm:        procs->ppid = p->parent->pid;
kernel.asm:      procs->elapsed_ticks = ticks - p->start_ticks;
kernel.asm:      procs->CPU_total_ticks = p->cpu_ticks_total;
kernel.asm:      procs->size = p->sz;
kernel.asm:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
kernel.asm:  while(p->next) {
kernel.asm:    cprintf("%d -> ", p->pid);
kernel.asm:    p = p->next;
kernel.asm:  while(p->next) {
kernel.asm:    cprintf("%d -> ", p->pid);
kernel.asm:    p = p->next;
kernel.asm:  cprintf("%d\n", p->pid);
kernel.asm:      ppid = p->parent->pid;  // Get PPID of proc if not init
kernel.asm:    cprintf("(%d,%d)", p->pid, ppid);
kernel.asm:    if(p->next) {
kernel.asm:    p = p->next;
kernel.asm:    if(p->next) {
kernel.asm:    p = p->next;
kernel.asm:    p = p->next;
kernel.asm:    p = p->next;
kernel.asm:  p->next = 0;  // Set p->next to NULL before returning so it doesn't point anywhere
kernel.asm:  if(ip->type == T_DIR){
kernel.asm:  ip->nlink++;
kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel.asm:  ip->nlink++;
kernel.asm:  ip->nlink--;
kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel.asm:  if(ip->nlink < 1)
kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel.asm:  if(ip->type == T_DIR){
kernel.asm:    dp->nlink--;
kernel.asm:  ip->nlink--;
kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
kernel.asm:  ip->major = major;
kernel.asm:  ip->minor = minor;
kernel.asm:  ip->nlink = 1;
kernel.asm:    dp->nlink++;  // for ".."
kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel.asm:  if(ip->type != T_DIR){
kernel.asm:  if(p->pgdir == 0)
kernel.asm:  lcr3(v2p(p->pgdir));  // switch to new address space
kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
kill.asm:  if(bp + bp->s.size == p->s.ptr){
kill.asm:    bp->s.size += p->s.ptr->s.size;
kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
kill.asm:    bp->s.ptr = p->s.ptr;
kill.asm:  if(p + p->s.size == bp){
kill.asm:    p->s.size += bp->s.size;
kill.asm:    p->s.ptr = bp->s.ptr;
kill.asm:    p->s.ptr = bp;
kill.asm:  hp->s.size = nu;
kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
kill.asm:    if(p->s.size >= nunits){
kill.asm:      if(p->s.size == nunits)
kill.asm:        prevp->s.ptr = p->s.ptr;
kill.asm:        p->s.size -= nunits;
kill.asm:        p += p->s.size;
kill.asm:        p->s.size = nunits;
kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ln.asm:  if(bp + bp->s.size == p->s.ptr){
ln.asm:    bp->s.size += p->s.ptr->s.size;
ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ln.asm:    bp->s.ptr = p->s.ptr;
ln.asm:  if(p + p->s.size == bp){
ln.asm:    p->s.size += bp->s.size;
ln.asm:    p->s.ptr = bp->s.ptr;
ln.asm:    p->s.ptr = bp;
ln.asm:  hp->s.size = nu;
ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ln.asm:    if(p->s.size >= nunits){
ln.asm:      if(p->s.size == nunits)
ln.asm:        prevp->s.ptr = p->s.ptr;
ln.asm:        p->s.size -= nunits;
ln.asm:        p += p->s.size;
ln.asm:        p->s.size = nunits;
ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
log.c://   modify bp->data[]
ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ls.asm:  if(bp + bp->s.size == p->s.ptr){
ls.asm:    bp->s.size += p->s.ptr->s.size;
ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ls.asm:    bp->s.ptr = p->s.ptr;
ls.asm:  if(p + p->s.size == bp){
ls.asm:    p->s.size += bp->s.size;
ls.asm:    p->s.ptr = bp->s.ptr;
ls.asm:    p->s.ptr = bp;
ls.asm:  hp->s.size = nu;
ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ls.asm:    if(p->s.size >= nunits){
ls.asm:      if(p->s.size == nunits)
ls.asm:        prevp->s.ptr = p->s.ptr;
ls.asm:        p->s.size -= nunits;
ls.asm:        p += p->s.size;
ls.asm:        p->s.size = nunits;
ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
mkdir.asm:    bp->s.size += p->s.ptr->s.size;
mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
mkdir.asm:    bp->s.ptr = p->s.ptr;
mkdir.asm:  if(p + p->s.size == bp){
mkdir.asm:    p->s.size += bp->s.size;
mkdir.asm:    p->s.ptr = bp->s.ptr;
mkdir.asm:    p->s.ptr = bp;
mkdir.asm:  hp->s.size = nu;
mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
mkdir.asm:    if(p->s.size >= nunits){
mkdir.asm:      if(p->s.size == nunits)
mkdir.asm:        prevp->s.ptr = p->s.ptr;
mkdir.asm:        p->s.size -= nunits;
mkdir.asm:        p += p->s.size;
mkdir.asm:        p->s.size = nunits;
mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
mp.c:    if((mp = mpsearch1(p-1024, 1024)))
mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
mp.c:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
mp.c:  if(mp->imcrp){
name:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:cat.asm:  if(bp + bp->s.size == p->s.ptr){
name:cat.asm:    bp->s.size += p->s.ptr->s.size;
name:cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:cat.asm:    bp->s.ptr = p->s.ptr;
name:cat.asm:  if(p + p->s.size == bp){
name:cat.asm:    p->s.size += bp->s.size;
name:cat.asm:    p->s.ptr = bp->s.ptr;
name:cat.asm:    p->s.ptr = bp;
name:cat.asm:  hp->s.size = nu;
name:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:cat.asm:    if(p->s.size >= nunits){
name:cat.asm:      if(p->s.size == nunits)
name:cat.asm:        prevp->s.ptr = p->s.ptr;
name:cat.asm:        p->s.size -= nunits;
name:cat.asm:        p += p->s.size;
name:cat.asm:        p->s.size = nunits;
name:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:date.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:date.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:date.asm:  if(bp + bp->s.size == p->s.ptr){
name:date.asm:    bp->s.size += p->s.ptr->s.size;
name:date.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:date.asm:    bp->s.ptr = p->s.ptr;
name:date.asm:  if(p + p->s.size == bp){
name:date.asm:    p->s.size += bp->s.size;
name:date.asm:    p->s.ptr = bp->s.ptr;
name:date.asm:    p->s.ptr = bp;
name:date.asm:  hp->s.size = nu;
name:date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:date.asm:    if(p->s.size >= nunits){
name:date.asm:      if(p->s.size == nunits)
name:date.asm:        prevp->s.ptr = p->s.ptr;
name:date.asm:        p->s.size -= nunits;
name:date.asm:        p += p->s.size;
name:date.asm:        p->s.size = nunits;
name:date.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:echo.asm:  if(bp + bp->s.size == p->s.ptr){
name:echo.asm:    bp->s.size += p->s.ptr->s.size;
name:echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:echo.asm:    bp->s.ptr = p->s.ptr;
name:echo.asm:  if(p + p->s.size == bp){
name:echo.asm:    p->s.size += bp->s.size;
name:echo.asm:    p->s.ptr = bp->s.ptr;
name:echo.asm:    p->s.ptr = bp;
name:echo.asm:  hp->s.size = nu;
name:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:echo.asm:    if(p->s.size >= nunits){
name:echo.asm:      if(p->s.size == nunits)
name:echo.asm:        prevp->s.ptr = p->s.ptr;
name:echo.asm:        p->s.size -= nunits;
name:echo.asm:        p += p->s.size;
name:echo.asm:        p->s.size = nunits;
name:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:fs.c:  memmove(sb, bp->data, sizeof(*sb));
name:fs.c:  memset(bp->data, 0, BSIZE);
name:fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
name:fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
name:fs.c:  if((bp->data[bi/8] & m) == 0)
name:fs.c:  bp->data[bi/8] &= ~m;
name:fs.c:// not stored on disk: ip->ref and ip->flags.
name:fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
name:fs.c://   is set in ip->flags. ilock() reads the inode from
name:fs.c://   I_VALID if ip->ref has fallen to zero.
name:fs.c://   ... examine and modify ip->xxx ...
name:fs.c:// pathname lookup. iget() increments ip->ref so that the inode
name:fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
name:fs.c:    if(dip->type == 0){  // a free inode
name:fs.c:      dip->type = type;
name:fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
name:fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
name:fs.c:  dip->type = ip->type;
name:fs.c:  dip->major = ip->major;
name:fs.c:  dip->minor = ip->minor;
name:fs.c:  dip->nlink = ip->nlink;
name:fs.c:  dip->size = ip->size;
name:fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
name:fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
name:fs.c:      ip->ref++;
name:fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
name:fs.c:  ip->dev = dev;
name:fs.c:  ip->inum = inum;
name:fs.c:  ip->ref = 1;
name:fs.c:  ip->flags = 0;
name:fs.c:  ip->ref++;
name:fs.c:  if(ip == 0 || ip->ref < 1)
name:fs.c:  while(ip->flags & I_BUSY)
name:fs.c:  ip->flags |= I_BUSY;
name:fs.c:  if(!(ip->flags & I_VALID)){
name:fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
name:fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
name:fs.c:    ip->type = dip->type;
name:fs.c:    ip->major = dip->major;
name:fs.c:    ip->minor = dip->minor;
name:fs.c:    ip->nlink = dip->nlink;
name:fs.c:    ip->size = dip->size;
name:fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
name:fs.c:    ip->flags |= I_VALID;
name:fs.c:    if(ip->type == 0)
name:fs.c:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
name:fs.c:  ip->flags &= ~I_BUSY;
name:fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
name:fs.c:    if(ip->flags & I_BUSY)
name:fs.c:    ip->flags |= I_BUSY;
name:fs.c:    ip->type = 0;
name:fs.c:    ip->flags = 0;
name:fs.c:  ip->ref--;
name:fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are 
name:fs.c:// listed in block ip->addrs[NDIRECT].
name:fs.c:    if((addr = ip->addrs[bn]) == 0)
name:fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
name:fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
name:fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
name:fs.c:    bp = bread(ip->dev, addr);
name:fs.c:    a = (uint*)bp->data;
name:fs.c:      a[bn] = addr = balloc(ip->dev);
name:fs.c:    if(ip->addrs[i]){
name:fs.c:      bfree(ip->dev, ip->addrs[i]);
name:fs.c:      ip->addrs[i] = 0;
name:fs.c:  if(ip->addrs[NDIRECT]){
name:fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
name:fs.c:    a = (uint*)bp->data;
name:fs.c:        bfree(ip->dev, a[j]);
name:fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
name:fs.c:    ip->addrs[NDIRECT] = 0;
name:fs.c:  ip->size = 0;
name:fs.c:  st->dev = ip->dev;
name:fs.c:  st->ino = ip->inum;
name:fs.c:  st->type = ip->type;
name:fs.c:  st->nlink = ip->nlink;
name:fs.c:  st->size = ip->size;
name:fs.c:  if(ip->type == T_DEV){
name:fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
name:fs.c:    return devsw[ip->major].read(ip, dst, n);
name:fs.c:  if(off > ip->size || off + n < off)
name:fs.c:  if(off + n > ip->size)
name:fs.c:    n = ip->size - off;
name:fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
name:fs.c:    memmove(dst, bp->data + off%BSIZE, m);
name:fs.c:  if(ip->type == T_DEV){
name:fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
name:fs.c:    return devsw[ip->major].write(ip, src, n);
name:fs.c:  if(off > ip->size || off + n < off)
name:fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
name:fs.c:    memmove(bp->data + off%BSIZE, src, m);
name:fs.c:  if(n > 0 && off > ip->size){
name:fs.c:    ip->size = off;
name:fs.c:  if(dp->type != T_DIR)
name:fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
name:fs.c:      return iget(dp->dev, inum);
name:fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
name:fs.c:    if(ip->type != T_DIR){
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             (cp->elapsed_ticks) % 10,
name:gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             (cp->elapsed_ticks) % 10,
name:gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             (cp->elapsed_ticks) % 10,
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.asm:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.asm:             (cp->elapsed_ticks) % 10,
name:gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
name:gp.asm:             (cp->elapsed_ticks) % 10,
name:gp.asm:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
name:gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:gp.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:gp.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:gp.asm:  if(bp + bp->s.size == p->s.ptr){
name:gp.asm:    bp->s.size += p->s.ptr->s.size;
name:gp.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:gp.asm:    bp->s.ptr = p->s.ptr;
name:gp.asm:  if(p + p->s.size == bp){
name:gp.asm:    p->s.size += bp->s.size;
name:gp.asm:    p->s.ptr = bp->s.ptr;
name:gp.asm:    p->s.ptr = bp;
name:gp.asm:  hp->s.size = nu;
name:gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:gp.asm:    if(p->s.size >= nunits){
name:gp.asm:      if(p->s.size == nunits)
name:gp.asm:        prevp->s.ptr = p->s.ptr;
name:gp.asm:        p->s.size -= nunits;
name:gp.asm:        p += p->s.size;
name:gp.asm:        p->s.size = nunits;
name:gp.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:gp.c:             cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:gp.c:             cp->elapsed_ticks / 1000, (cp->elapsed_ticks / 100) % 10, (cp->elapsed_ticks / 10) % 10,
name:gp.c:             (cp->elapsed_ticks) % 10,
name:gp.c:             cp->CPU_total_ticks / 1000, (cp->CPU_total_ticks / 100) % 10, cp->state, cp->size);
name:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:grep.asm:  if(bp + bp->s.size == p->s.ptr){
name:grep.asm:    bp->s.size += p->s.ptr->s.size;
name:grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:grep.asm:    bp->s.ptr = p->s.ptr;
name:grep.asm:  if(p + p->s.size == bp){
name:grep.asm:    p->s.size += bp->s.size;
name:grep.asm:    p->s.ptr = bp->s.ptr;
name:grep.asm:    p->s.ptr = bp;
name:grep.asm:  hp->s.size = nu;
name:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:grep.asm:    if(p->s.size >= nunits){
name:grep.asm:      if(p->s.size == nunits)
name:grep.asm:        prevp->s.ptr = p->s.ptr;
name:grep.asm:        p->s.size -= nunits;
name:grep.asm:        p += p->s.size;
name:grep.asm:        p->s.size = nunits;
name:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:halt.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:halt.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:halt.asm:  if(bp + bp->s.size == p->s.ptr){
name:halt.asm:    bp->s.size += p->s.ptr->s.size;
name:halt.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:halt.asm:    bp->s.ptr = p->s.ptr;
name:halt.asm:  if(p + p->s.size == bp){
name:halt.asm:    p->s.size += bp->s.size;
name:halt.asm:    p->s.ptr = bp->s.ptr;
name:halt.asm:    p->s.ptr = bp;
name:halt.asm:  hp->s.size = nu;
name:halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:halt.asm:    if(p->s.size >= nunits){
name:halt.asm:      if(p->s.size == nunits)
name:halt.asm:        prevp->s.ptr = p->s.ptr;
name:halt.asm:        p->s.size -= nunits;
name:halt.asm:        p += p->s.size;
name:halt.asm:        p->s.size = nunits;
name:halt.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:init.asm:  if(bp + bp->s.size == p->s.ptr){
name:init.asm:    bp->s.size += p->s.ptr->s.size;
name:init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:init.asm:    bp->s.ptr = p->s.ptr;
name:init.asm:  if(p + p->s.size == bp){
name:init.asm:    p->s.size += bp->s.size;
name:init.asm:    p->s.ptr = bp->s.ptr;
name:init.asm:    p->s.ptr = bp;
name:init.asm:  hp->s.size = nu;
name:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:init.asm:    if(p->s.size >= nunits){
name:init.asm:      if(p->s.size == nunits)
name:init.asm:        prevp->s.ptr = p->s.ptr;
name:init.asm:        p->s.size -= nunits;
name:init.asm:        p += p->s.size;
name:init.asm:        p->s.size = nunits;
name:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
name:kernel.asm:  memset(bp->data, 0, BSIZE);
name:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
name:kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
name:kernel.asm:  if((bp->data[bi/8] & m) == 0)
name:kernel.asm:  bp->data[bi/8] &= ~m;
name:kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
name:kernel.asm:    if(dip->type == 0){  // a free inode
name:kernel.asm:      dip->type = type;
name:kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
name:kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
name:kernel.asm:  dip->type = ip->type;
name:kernel.asm:  dip->major = ip->major;
name:kernel.asm:  dip->minor = ip->minor;
name:kernel.asm:  dip->nlink = ip->nlink;
name:kernel.asm:  dip->size = ip->size;
name:kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
name:kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
name:kernel.asm:      ip->ref++;
name:kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
name:kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
name:kernel.asm:  ip->dev = dev;
name:kernel.asm:  ip->inum = inum;
name:kernel.asm:  ip->ref = 1;
name:kernel.asm:  ip->flags = 0;
name:kernel.asm:  ip->ref++;
name:kernel.asm:  if(ip == 0 || ip->ref < 1)
name:kernel.asm:  while(ip->flags & I_BUSY)
name:kernel.asm:  if(ip == 0 || ip->ref < 1)
name:kernel.asm:  while(ip->flags & I_BUSY)
name:kernel.asm:  ip->flags |= I_BUSY;
name:kernel.asm:  if(!(ip->flags & I_VALID)){
name:kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
name:kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
name:kernel.asm:    ip->type = dip->type;
name:kernel.asm:    ip->major = dip->major;
name:kernel.asm:    ip->minor = dip->minor;
name:kernel.asm:    ip->nlink = dip->nlink;
name:kernel.asm:    ip->size = dip->size;
name:kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
name:kernel.asm:    ip->flags |= I_VALID;
name:kernel.asm:    if(ip->type == 0)
name:kernel.asm:  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
name:kernel.asm:  ip->flags &= ~I_BUSY;
name:kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
name:kernel.asm:    if(ip->flags & I_BUSY)
name:kernel.asm:    ip->flags |= I_BUSY;
name:kernel.asm:    ip->type = 0;
name:kernel.asm:    ip->flags = 0;
name:kernel.asm:  ip->ref--;
name:kernel.asm:    if((addr = ip->addrs[bn]) == 0)
name:kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
name:kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
name:kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
name:kernel.asm:    bp = bread(ip->dev, addr);
name:kernel.asm:    a = (uint*)bp->data;
name:kernel.asm:      a[bn] = addr = balloc(ip->dev);
name:kernel.asm:    if(ip->addrs[i]){
name:kernel.asm:      bfree(ip->dev, ip->addrs[i]);
name:kernel.asm:      ip->addrs[i] = 0;
name:kernel.asm:      bfree(ip->dev, ip->addrs[i]);
name:kernel.asm:      ip->addrs[i] = 0;
name:kernel.asm:  if(ip->addrs[NDIRECT]){
name:kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
name:kernel.asm:    a = (uint*)bp->data;
name:kernel.asm:        bfree(ip->dev, a[j]);
name:kernel.asm:  if(ip->addrs[NDIRECT]){
name:kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
name:kernel.asm:    a = (uint*)bp->data;
name:kernel.asm:        bfree(ip->dev, a[j]);
name:kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
name:kernel.asm:    ip->addrs[NDIRECT] = 0;
name:kernel.asm:  ip->size = 0;
name:kernel.asm:  st->dev = ip->dev;
name:kernel.asm:  st->ino = ip->inum;
name:kernel.asm:  st->type = ip->type;
name:kernel.asm:  st->nlink = ip->nlink;
name:kernel.asm:  st->size = ip->size;
name:kernel.asm:  if(ip->type == T_DEV){
name:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
name:kernel.asm:    return devsw[ip->major].read(ip, dst, n);
name:kernel.asm:  if(off > ip->size || off + n < off)
name:kernel.asm:  if(off + n > ip->size)
name:kernel.asm:    n = ip->size - off;
name:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
name:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
name:kernel.asm:  if(off > ip->size || off + n < off)
name:kernel.asm:  if(off + n > ip->size)
name:kernel.asm:    n = ip->size - off;
name:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
name:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
name:kernel.asm:  if(ip->type == T_DEV){
name:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
name:kernel.asm:    return devsw[ip->major].write(ip, src, n);
name:kernel.asm:  if(off > ip->size || off + n < off)
name:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
name:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
name:kernel.asm:  if(off > ip->size || off + n < off)
name:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
name:kernel.asm:  if(n > 0 && off > ip->size){
name:kernel.asm:    ip->size = off;
name:kernel.asm:  if(dp->type != T_DIR)
name:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
name:kernel.asm:      return iget(dp->dev, inum);
name:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
name:kernel.asm:  if(dp->type != T_DIR)
name:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
name:kernel.asm:      return iget(dp->dev, inum);
name:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
name:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
name:kernel.asm:    if(ip->type != T_DIR){
name:kernel.asm://   modify bp->data[]
name:kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
name:kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
name:kernel.asm:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
name:kernel.asm:  if(mp->imcrp){
name:kernel.asm:  p->readopen = 1;
name:kernel.asm:  p->writeopen = 1;
name:kernel.asm:  p->nwrite = 0;
name:kernel.asm:  p->nread = 0;
name:kernel.asm:  initlock(&p->lock, "pipe");
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:    p->writeopen = 0;
name:kernel.asm:    wakeup(&p->nread);
name:kernel.asm:    p->readopen = 0;
name:kernel.asm:    wakeup(&p->nwrite);
name:kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
name:kernel.asm:    release(&p->lock);
name:kernel.asm:    release(&p->lock);
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
name:kernel.asm:      if(p->readopen == 0 || proc->killed){
name:kernel.asm:        release(&p->lock);
name:kernel.asm:      wakeup(&p->nread);
name:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
name:kernel.asm:      wakeup(&p->nread);
name:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
name:kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:      wakeup(&p->nread);
name:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
name:kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
name:kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
name:kernel.asm:  release(&p->lock);
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
name:kernel.asm:      release(&p->lock);
name:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
name:kernel.asm:  acquire(&p->lock);
name:kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
name:kernel.asm:      release(&p->lock);
name:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
name:kernel.asm:    if(p->nread == p->nwrite)
name:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
name:kernel.asm:      release(&p->lock);
name:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
name:kernel.asm:    if(p->nread == p->nwrite)
name:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
name:kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
name:kernel.asm:  release(&p->lock);
name:kernel.asm:    if(p->state == UNUSED)
name:kernel.asm:    if(p->state == UNUSED)
name:kernel.asm:  p->state = EMBRYO;
name:kernel.asm:  p->pid = nextpid++;
name:kernel.asm:  if((p->kstack = kalloc()) == 0){
name:kernel.asm:    p->state = UNUSED;
name:kernel.asm:    p->state = UNUSED;
name:kernel.asm:  sp = p->kstack + KSTACKSIZE;
name:kernel.asm:  sp -= sizeof *p->tf;
name:kernel.asm:  p->tf = (struct trapframe*)sp;
name:kernel.asm:  sp -= sizeof *p->context;
name:kernel.asm:  p->context = (struct context*)sp;
name:kernel.asm:  memset(p->context, 0, sizeof *p->context);
name:kernel.asm:  p->context->eip = (uint)forkret;
name:kernel.asm:  p->start_ticks = ticks;
name:kernel.asm:  p->cpu_ticks_in = 0;
name:kernel.asm:  p->cpu_ticks_total = 0;
name:kernel.asm:  if((p->pgdir = setupkvm()) == 0)
name:kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
name:kernel.asm:  p->sz = PGSIZE;
name:kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
name:kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
name:kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
name:kernel.asm:  p->tf->es = p->tf->ds;
name:kernel.asm:  p->tf->ss = p->tf->ds;
name:kernel.asm:  p->tf->eflags = FL_IF;
name:kernel.asm:  p->tf->esp = PGSIZE;
name:kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
name:kernel.asm:  p->uid = DEFUID;
name:kernel.asm:  p->gid = DEFGID;
name:kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
name:kernel.asm:  p->cwd = namei("/");
name:kernel.asm:  p->state = RUNNABLE;
name:kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
name:kernel.asm:    kfree(np->kstack);
name:kernel.asm:    np->kstack = 0;
name:kernel.asm:    np->state = UNUSED;
name:kernel.asm:  np->sz = proc->sz;
name:kernel.asm:  np->parent = proc;
name:kernel.asm:  *np->tf = *proc->tf;
name:kernel.asm:  np->tf->eax = 0;
name:kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
name:kernel.asm:  *np->tf = *proc->tf;
name:kernel.asm:  np->tf->eax = 0;
name:kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
name:kernel.asm:  np->cwd = idup(proc->cwd);
name:kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
name:kernel.asm:  pid = np->pid;
name:kernel.asm:  np->uid = proc->uid;
name:kernel.asm:  np->gid = proc->gid;
name:kernel.asm:  // lock to force the compiler to emit the np->state write last.
name:kernel.asm:  np->state = RUNNABLE;
name:kernel.asm:      if(p->parent == proc) {
name:kernel.asm:        p->parent = initproc;
name:kernel.asm:        if(p->state == ZOMBIE)
name:kernel.asm:          cprintf("ZZZZZ: %d\n", p->pid);
name:kernel.asm:      p = p->next;
name:kernel.asm:      p = p->next;
name:kernel.asm:        if(p->parent == proc) {
name:kernel.asm:          if (p->state == ZOMBIE) {
name:kernel.asm:            pid = p->pid;
name:kernel.asm:            kfree(p->kstack);
name:kernel.asm:            p->kstack = 0;
name:kernel.asm:            freevm(p->pgdir);
name:kernel.asm:            p->pid = 0;
name:kernel.asm:            p->parent = 0;
name:kernel.asm:            p->name[0] = 0;
name:kernel.asm:            p->killed = 0;
name:kernel.asm:            cprintf("REMOVED ZOMBIE: %d", p->pid);
name:kernel.asm:            p->state = UNUSED;
name:kernel.asm:        p = p->next;
name:kernel.asm:        p = p->next;
name:kernel.asm:      p->state = RUNNING;
name:kernel.asm:      p->cpu_ticks_in = ticks;
name:kernel.asm:      // It should have changed its p->state before coming back.
name:kernel.asm:  // change p->state and then call sched.
name:kernel.asm:      p->state = RUNNABLE;
name:kernel.asm:    if(p->chan == chan) {
name:kernel.asm:    p = p->next;
name:kernel.asm:    p = p->next;
name:kernel.asm:    p->state = RUNNABLE;
name:kernel.asm:    p = p->next;
name:kernel.asm:    p->state = RUNNABLE;
name:kernel.asm:  return -1;p->killed
name:kernel.asm:      if(p->pid == pid) {
name:kernel.asm:        p->killed = 1;
name:kernel.asm:        if(p->state == SLEEPING) {
name:kernel.asm:          p->state = RUNNABLE;
name:kernel.asm:      p = p->next;
name:kernel.asm:      p = p->next;
name:kernel.asm:    if(p->state == UNUSED)
name:kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
name:kernel.asm:      state = states[p->state];
name:kernel.asm:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
name:kernel.asm:      elaps       = (ticks - p->start_ticks);
name:kernel.asm:      cputick_1   = p->cpu_ticks_total/1000;       // CPU time in seconds
name:kernel.asm:      cputick_10  = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
name:kernel.asm:      if(p->pid == 1)
name:kernel.asm:        ppid = p->parent->pid;
name:kernel.asm:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
name:kernel.asm:    if(p->state == SLEEPING){
name:kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
name:kernel.asm:    if(p->state == SLEEPING){
name:kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
name:kernel.asm:    if(p->state == UNUSED)
name:kernel.asm:    if(p->state != EMBRYO && p->state != UNUSED) {
name:kernel.asm:      procs->pid = p->pid;
name:kernel.asm:      procs->uid = p->uid;
name:kernel.asm:      procs->gid = p->gid;
name:kernel.asm:      if(p->pid == 1)
name:kernel.asm:        procs->ppid = p->parent->pid;
name:kernel.asm:      procs->elapsed_ticks = ticks - p->start_ticks;
name:kernel.asm:      procs->CPU_total_ticks = p->cpu_ticks_total;
name:kernel.asm:      procs->size = p->sz;
name:kernel.asm:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
name:kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
name:kernel.asm:      safestrcpy(procs->name, p->name, sizeof(procs->name));
name:kernel.asm:  while(p->next) {
name:kernel.asm:    cprintf("%d -> ", p->pid);
name:kernel.asm:    p = p->next;
name:kernel.asm:  while(p->next) {
name:kernel.asm:    cprintf("%d -> ", p->pid);
name:kernel.asm:    p = p->next;
name:kernel.asm:  cprintf("%d\n", p->pid);
name:kernel.asm:      ppid = p->parent->pid;  // Get PPID of proc is not init
name:kernel.asm:    cprintf("(%d,%d)", p->pid, ppid);
name:kernel.asm:    if(p->next) {
name:kernel.asm:    p = p->next;
name:kernel.asm:    if(p->next) {
name:kernel.asm:    p = p->next;
name:kernel.asm:    p = p->next;
name:kernel.asm:    p = p->next;
name:kernel.asm:  p->next = 0;
name:kernel.asm:  if(ip->type == T_DIR){
name:kernel.asm:  ip->nlink++;
name:kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
name:kernel.asm:  ip->nlink++;
name:kernel.asm:  ip->nlink--;
name:kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
name:kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
name:kernel.asm:  if(ip->nlink < 1)
name:kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
name:kernel.asm:  if(ip->type == T_DIR){
name:kernel.asm:    dp->nlink--;
name:kernel.asm:  ip->nlink--;
name:kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
name:kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
name:kernel.asm:  ip->major = major;
name:kernel.asm:  ip->minor = minor;
name:kernel.asm:  ip->nlink = 1;
name:kernel.asm:    dp->nlink++;  // for ".."
name:kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
name:kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
name:kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
name:kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
name:kernel.asm:  if(ip->type != T_DIR){
name:kernel.asm:  if(p->pgdir == 0)
name:kernel.asm:  lcr3(v2p(p->pgdir));  // switch to new address space
name:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:kill.asm:  if(bp + bp->s.size == p->s.ptr){
name:kill.asm:    bp->s.size += p->s.ptr->s.size;
name:kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:kill.asm:    bp->s.ptr = p->s.ptr;
name:kill.asm:  if(p + p->s.size == bp){
name:kill.asm:    p->s.size += bp->s.size;
name:kill.asm:    p->s.ptr = bp->s.ptr;
name:kill.asm:    p->s.ptr = bp;
name:kill.asm:  hp->s.size = nu;
name:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:kill.asm:    if(p->s.size >= nunits){
name:kill.asm:      if(p->s.size == nunits)
name:kill.asm:        prevp->s.ptr = p->s.ptr;
name:kill.asm:        p->s.size -= nunits;
name:kill.asm:        p += p->s.size;
name:kill.asm:        p->s.size = nunits;
name:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ln.asm:  if(bp + bp->s.size == p->s.ptr){
name:ln.asm:    bp->s.size += p->s.ptr->s.size;
name:ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:ln.asm:    bp->s.ptr = p->s.ptr;
name:ln.asm:  if(p + p->s.size == bp){
name:ln.asm:    p->s.size += bp->s.size;
name:ln.asm:    p->s.ptr = bp->s.ptr;
name:ln.asm:    p->s.ptr = bp;
name:ln.asm:  hp->s.size = nu;
name:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ln.asm:    if(p->s.size >= nunits){
name:ln.asm:      if(p->s.size == nunits)
name:ln.asm:        prevp->s.ptr = p->s.ptr;
name:ln.asm:        p->s.size -= nunits;
name:ln.asm:        p += p->s.size;
name:ln.asm:        p->s.size = nunits;
name:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:log.c://   modify bp->data[]
name:ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
name:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ls.asm:  if(bp + bp->s.size == p->s.ptr){
name:ls.asm:    bp->s.size += p->s.ptr->s.size;
name:ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:ls.asm:    bp->s.ptr = p->s.ptr;
name:ls.asm:  if(p + p->s.size == bp){
name:ls.asm:    p->s.size += bp->s.size;
name:ls.asm:    p->s.ptr = bp->s.ptr;
name:ls.asm:    p->s.ptr = bp;
name:ls.asm:  hp->s.size = nu;
name:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ls.asm:    if(p->s.size >= nunits){
name:ls.asm:      if(p->s.size == nunits)
name:ls.asm:        prevp->s.ptr = p->s.ptr;
name:ls.asm:        p->s.size -= nunits;
name:ls.asm:        p += p->s.size;
name:ls.asm:        p->s.size = nunits;
name:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
name:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
name:mkdir.asm:    bp->s.size += p->s.ptr->s.size;
name:mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:mkdir.asm:    bp->s.ptr = p->s.ptr;
name:mkdir.asm:  if(p + p->s.size == bp){
name:mkdir.asm:    p->s.size += bp->s.size;
name:mkdir.asm:    p->s.ptr = bp->s.ptr;
name:mkdir.asm:    p->s.ptr = bp;
name:mkdir.asm:  hp->s.size = nu;
name:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:mkdir.asm:    if(p->s.size >= nunits){
name:mkdir.asm:      if(p->s.size == nunits)
name:mkdir.asm:        prevp->s.ptr = p->s.ptr;
name:mkdir.asm:        p->s.size -= nunits;
name:mkdir.asm:        p += p->s.size;
name:mkdir.asm:        p->s.size = nunits;
name:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:mp.c:    if((mp = mpsearch1(p-1024, 1024)))
name:mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
name:mp.c:  conf = (struct mpconf*) p2v((uint) mp->physaddr);
name:mp.c:  if(mp->imcrp){
name:Notes:blocks and inodes have ad-hoc sleep-locks
name:pipe.c:  p->readopen = 1;
name:pipe.c:  p->writeopen = 1;
name:pipe.c:  p->nwrite = 0;
name:pipe.c:  p->nread = 0;
name:pipe.c:  initlock(&p->lock, "pipe");
name:pipe.c:  acquire(&p->lock);
name:pipe.c:    p->writeopen = 0;
name:pipe.c:    wakeup(&p->nread);
name:pipe.c:    p->readopen = 0;
name:pipe.c:    wakeup(&p->nwrite);
name:pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
name:pipe.c:    release(&p->lock);
name:pipe.c:    release(&p->lock);
name:pipe.c:  acquire(&p->lock);
name:pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
name:pipe.c:      if(p->readopen == 0 || proc->killed){
name:pipe.c:        release(&p->lock);
name:pipe.c:      wakeup(&p->nread);
name:pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
name:pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
name:pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
name:pipe.c:  release(&p->lock);
name:pipe.c:  acquire(&p->lock);
name:pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
name:pipe.c:      release(&p->lock);
name:pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
name:pipe.c:    if(p->nread == p->nwrite)
name:pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
name:pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
name:pipe.c:  release(&p->lock);
name:proc.c:    if(p->state == UNUSED)
name:proc.c:  p->state = EMBRYO;
name:proc.c:  p->pid = nextpid++;
name:proc.c:  if((p->kstack = kalloc()) == 0){
name:proc.c:    p->state = UNUSED;
name:proc.c:    p->state = UNUSED;
name:proc.c:  sp = p->kstack + KSTACKSIZE;
name:proc.c:  sp -= sizeof *p->tf;
name:proc.c:  p->tf = (struct trapframe*)sp;
name:proc.c:  sp -= sizeof *p->context;
name:proc.c:  p->context = (struct context*)sp;
name:proc.c:  memset(p->context, 0, sizeof *p->context);
name:proc.c:  p->context->eip = (uint)forkret;
name:proc.c:  p->start_ticks = ticks;
name:proc.c:  p->cpu_ticks_in = 0;
name:proc.c:  p->cpu_ticks_total = 0;
name:proc.c:  if((p->pgdir = setupkvm()) == 0)
name:proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
name:proc.c:  p->sz = PGSIZE;
name:proc.c:  memset(p->tf, 0, sizeof(*p->tf));
name:proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
name:proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
name:proc.c:  p->tf->es = p->tf->ds;
name:proc.c:  p->tf->ss = p->tf->ds;
name:proc.c:  p->tf->eflags = FL_IF;
name:proc.c:  p->tf->esp = PGSIZE;
name:proc.c:  p->tf->eip = 0;  // beginning of initcode.S
name:proc.c:  p->uid = DEFUID;
name:proc.c:  p->gid = DEFGID;
name:proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
name:proc.c:  p->cwd = namei("/");
name:proc.c:  p->state = RUNNABLE;
name:proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
name:proc.c:    kfree(np->kstack);
name:proc.c:    np->kstack = 0;
name:proc.c:    np->state = UNUSED;
name:proc.c:  np->sz = proc->sz;
name:proc.c:  np->parent = proc;
name:proc.c:  *np->tf = *proc->tf;
name:proc.c:  np->tf->eax = 0;
name:proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
name:proc.c:  np->cwd = idup(proc->cwd);
name:proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
name:proc.c:  pid = np->pid;
name:proc.c:  np->uid = proc->uid;
name:proc.c:  np->gid = proc->gid;
name:proc.c:  // lock to force the compiler to emit the np->state write last.
name:proc.c:  np->state = RUNNABLE;
name:proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
name:proc.c:    kfree(np->kstack);
name:proc.c:    np->kstack = 0;
name:proc.c:    np->state = UNUSED;
name:proc.c:  np->sz = proc->sz;
name:proc.c:  np->parent = proc;
name:proc.c:  *np->tf = *proc->tf;
name:proc.c:  np->tf->eax = 0;
name:proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
name:proc.c:  np->cwd = idup(proc->cwd);
name:proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
name:proc.c:  pid = np->pid;
name:proc.c:  np->uid = proc->uid;
name:proc.c:  np->gid = proc->gid;
name:proc.c:  // lock to force the compiler to emit the np->state write last.
name:proc.c:  np->state = RUNNABLE;
name:proc.c:    if(p->parent == proc){
name:proc.c:      p->parent = initproc;
name:proc.c:      if(p->state == ZOMBIE)
name:proc.c:      if(p->parent == proc) {
name:proc.c:        p->parent = initproc;
name:proc.c:        if(p->state == ZOMBIE)
name:proc.c:          cprintf("ZZZZZ: %d\n", p->pid);
name:proc.c:      p = p->next;
name:proc.c:      if(p->parent != proc)
name:proc.c:      if(p->state == ZOMBIE){
name:proc.c:        pid = p->pid;
name:proc.c:        kfree(p->kstack);
name:proc.c:        p->kstack = 0;
name:proc.c:        freevm(p->pgdir);
name:proc.c:        p->state = UNUSED;
name:proc.c:        p->pid = 0;
name:proc.c:        p->parent = 0;
name:proc.c:        p->name[0] = 0;
name:proc.c:        p->killed = 0;
name:proc.c:        if(p->parent == proc) {
name:proc.c:          if (p->state == ZOMBIE) {
name:proc.c:            pid = p->pid;
name:proc.c:            kfree(p->kstack);
name:proc.c:            p->kstack = 0;
name:proc.c:            freevm(p->pgdir);
name:proc.c:            p->pid = 0;
name:proc.c:            p->parent = 0;
name:proc.c:            p->name[0] = 0;
name:proc.c:            p->killed = 0;
name:proc.c:            cprintf("REMOVED ZOMBIE: %d", p->pid);
name:proc.c:            p->state = UNUSED;
name:proc.c:        p = p->next;
name:proc.c:      if(p->state != RUNNABLE)
name:proc.c:      p->state = RUNNING;
name:proc.c:      p->cpu_ticks_in = ticks;
name:proc.c:      // It should have changed its p->state before coming back.
name:proc.c:      p->state = RUNNING;
name:proc.c:      p->cpu_ticks_in = ticks;
name:proc.c:      // It should have changed its p->state before coming back.
name:proc.c:  // change p->state and then call sched.
name:proc.c:  // change p->state and then call sched.
name:proc.c:    if(p->state == SLEEPING && p->chan == chan)
name:proc.c:      p->state = RUNNABLE;
name:proc.c:    if(p->chan == chan) {
name:proc.c:    p = p->next;
name:proc.c:    p->state = RUNNABLE;
name:proc.c:    if(p->pid == pid){
name:proc.c:      p->killed = 1;
name:proc.c:      if(p->state == SLEEPING)
name:proc.c:        p->state = RUNNABLE;
name:proc.c:  return -1;p->killed
name:proc.c:      if(p->pid == pid) {
name:proc.c:        p->killed = 1;
name:proc.c:        if(p->state == SLEEPING) {
name:proc.c:          p->state = RUNNABLE;
name:proc.c:      p = p->next;
name:proc.c:    if(p->state == UNUSED)
name:proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
name:proc.c:      state = states[p->state];
name:proc.c:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
name:proc.c:      elaps       = (ticks - p->start_ticks);
name:proc.c:      cputick_1   = p->cpu_ticks_total/1000;       // CPU time in seconds
name:proc.c:      cputick_10  = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
name:proc.c:      if(p->pid == 1)
name:proc.c:        ppid = p->parent->pid;
name:proc.c:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
name:proc.c:              elaps_1, elaps_10, elaps_100, elaps_1000, cputick_1, cputick_10, state, p->sz);
name:proc.c:    if(p->state == SLEEPING){
name:proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
name:proc.c:    if(p->state != EMBRYO && p->state != UNUSED) {
name:proc.c:      procs->pid = p->pid;
name:proc.c:      procs->uid = p->uid;
name:proc.c:      procs->gid = p->gid;
name:proc.c:      if(p->pid == 1)
name:proc.c:        procs->ppid = p->parent->pid;
name:proc.c:      procs->elapsed_ticks = ticks - p->start_ticks;
name:proc.c:      procs->CPU_total_ticks = p->cpu_ticks_total;
name:proc.c:      procs->size = p->sz;
name:proc.c:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
name:proc.c:      safestrcpy(procs->name, p->name, sizeof(procs->name));
name:proc.c:  while(p->next) {
name:proc.c:    cprintf("%d -> ", p->pid);
name:proc.c:    p = p->next;
name:proc.c:  cprintf("%d\n", p->pid);
name:proc.c:      ppid = p->parent->pid;  // Get PPID of proc is not init
name:proc.c:    cprintf("(%d,%d)", p->pid, ppid);
name:proc.c:    if(p->next) {
name:proc.c:    p = p->next;
name:proc.c:    p = p->next;
name:proc.c:  p->next = 0;
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
name:ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
name:ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:ps.asm:  if(bp + bp->s.size == p->s.ptr){
name:ps.asm:    bp->s.size += p->s.ptr->s.size;
name:ps.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:ps.asm:    bp->s.ptr = p->s.ptr;
name:ps.asm:  if(p + p->s.size == bp){
name:ps.asm:    p->s.size += bp->s.size;
name:ps.asm:    p->s.ptr = bp->s.ptr;
name:ps.asm:    p->s.ptr = bp;
name:ps.asm:  hp->s.size = nu;
name:ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ps.asm:    if(p->s.size >= nunits){
name:ps.asm:      if(p->s.size == nunits)
name:ps.asm:        prevp->s.ptr = p->s.ptr;
name:ps.asm:        p->s.size -= nunits;
name:ps.asm:        p += p->s.size;
name:ps.asm:        p->s.size = nunits;
name:ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:ps.c:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
name:ps.c:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
name:ps.c:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
name:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:rm.asm:  if(bp + bp->s.size == p->s.ptr){
name:rm.asm:    bp->s.size += p->s.ptr->s.size;
name:rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:rm.asm:    bp->s.ptr = p->s.ptr;
name:rm.asm:  if(p + p->s.size == bp){
name:rm.asm:    p->s.size += bp->s.size;
name:rm.asm:    p->s.ptr = bp->s.ptr;
name:rm.asm:    p->s.ptr = bp;
name:rm.asm:  hp->s.size = nu;
name:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:rm.asm:    if(p->s.size >= nunits){
name:rm.asm:      if(p->s.size == nunits)
name:rm.asm:        prevp->s.ptr = p->s.ptr;
name:rm.asm:        p->s.size -= nunits;
name:rm.asm:        p += p->s.size;
name:rm.asm:        p->s.size = nunits;
name:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:sh.asm:    val = 10*val + (*p-'0');
name:sh.asm:    val = 10*val + (*p-'0');
name:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:sh.asm:  if(bp + bp->s.size == p->s.ptr){
name:sh.asm:    bp->s.size += p->s.ptr->s.size;
name:sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:sh.asm:    bp->s.ptr = p->s.ptr;
name:sh.asm:  if(p + p->s.size == bp){
name:sh.asm:    p->s.size += bp->s.size;
name:sh.asm:    p->s.ptr = bp->s.ptr;
name:sh.asm:    p->s.ptr = bp;
name:sh.asm:  hp->s.size = nu;
name:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:sh.asm:    if(p->s.size >= nunits){
name:sh.asm:      if(p->s.size == nunits)
name:sh.asm:        prevp->s.ptr = p->s.ptr;
name:sh.asm:        p->s.size -= nunits;
name:sh.asm:        p += p->s.size;
name:sh.asm:        p->s.size = nunits;
name:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:sh.c:    val = 10*val + (*p-'0');
name:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
name:stressfs.asm:    bp->s.size += p->s.ptr->s.size;
name:stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:stressfs.asm:    bp->s.ptr = p->s.ptr;
name:stressfs.asm:  if(p + p->s.size == bp){
name:stressfs.asm:    p->s.size += bp->s.size;
name:stressfs.asm:    p->s.ptr = bp->s.ptr;
name:stressfs.asm:    p->s.ptr = bp;
name:stressfs.asm:  hp->s.size = nu;
name:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:stressfs.asm:    if(p->s.size >= nunits){
name:stressfs.asm:      if(p->s.size == nunits)
name:stressfs.asm:        prevp->s.ptr = p->s.ptr;
name:stressfs.asm:        p->s.size -= nunits;
name:stressfs.asm:        p += p->s.size;
name:stressfs.asm:        p->s.size = nunits;
name:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:symlink.patch:     ip = idup(cp->cwd);
name:sysfile.c:  if(ip->type == T_DIR){
name:sysfile.c:  ip->nlink++;
name:sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
name:sysfile.c:  ip->nlink--;
name:sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
name:sysfile.c:  if(ip->nlink < 1)
name:sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
name:sysfile.c:  if(ip->type == T_DIR){
name:sysfile.c:    dp->nlink--;
name:sysfile.c:  ip->nlink--;
name:sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
name:sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
name:sysfile.c:  ip->major = major;
name:sysfile.c:  ip->minor = minor;
name:sysfile.c:  ip->nlink = 1;
name:sysfile.c:    dp->nlink++;  // for ".."
name:sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
name:sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
name:sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
name:sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
name:sysfile.c:  if(ip->type != T_DIR){
name:time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:time.asm:  if(bp + bp->s.size == p->s.ptr){
name:time.asm:    bp->s.size += p->s.ptr->s.size;
name:time.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:time.asm:    bp->s.ptr = p->s.ptr;
name:time.asm:  if(p + p->s.size == bp){
name:time.asm:    p->s.size += bp->s.size;
name:time.asm:    p->s.ptr = bp->s.ptr;
name:time.asm:    p->s.ptr = bp;
name:time.asm:  hp->s.size = nu;
name:time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:time.asm:    if(p->s.size >= nunits){
name:time.asm:      if(p->s.size == nunits)
name:time.asm:        prevp->s.ptr = p->s.ptr;
name:time.asm:        p->s.size -= nunits;
name:time.asm:        p += p->s.size;
name:time.asm:        p->s.size = nunits;
name:time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:TRICKS:at that point, cp->tf is set to point to a trap frame
name:TRICKS:The code in fork needs to read np->pid before
name:TRICKS:setting np->state to RUNNABLE.  The following
name:TRICKS:	  np->state = RUNNABLE;
name:TRICKS:	  return np->pid; // oops
name:TRICKS:After setting np->state to RUNNABLE, some other CPU
name:TRICKS:"return np->pid". Even saving a copy of np->pid before
name:TRICKS:setting np->state isn't safe, since the compiler is
name:TRICKS:The real code saves a copy of np->pid, then acquires a lock
name:TRICKS:around the write to np->state. The acquire() prevents the
name:umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:umalloc.c:  if(bp + bp->s.size == p->s.ptr){
name:umalloc.c:    bp->s.size += p->s.ptr->s.size;
name:umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
name:umalloc.c:    bp->s.ptr = p->s.ptr;
name:umalloc.c:  if(p + p->s.size == bp){
name:umalloc.c:    p->s.size += bp->s.size;
name:umalloc.c:    p->s.ptr = bp->s.ptr;
name:umalloc.c:    p->s.ptr = bp;
name:umalloc.c:  hp->s.size = nu;
name:umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:umalloc.c:    if(p->s.size >= nunits){
name:umalloc.c:      if(p->s.size == nunits)
name:umalloc.c:        prevp->s.ptr = p->s.ptr;
name:umalloc.c:        p->s.size -= nunits;
name:umalloc.c:        p += p->s.size;
name:umalloc.c:        p->s.size = nunits;
name:usertests.asm:// does chdir() call iput(p->cwd) in a transaction?
name:usertests.asm:// does exit() call iput(p->cwd) in a transaction?
name:usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:usertests.asm:  if(bp + bp->s.size == p->s.ptr){
name:usertests.asm:    bp->s.size += p->s.ptr->s.size;
name:usertests.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:usertests.asm:    bp->s.ptr = p->s.ptr;
name:usertests.asm:  if(p + p->s.size == bp){
name:usertests.asm:    p->s.size += bp->s.size;
name:usertests.asm:    p->s.ptr = bp->s.ptr;
name:usertests.asm:    p->s.ptr = bp;
name:usertests.asm:  hp->s.size = nu;
name:usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:usertests.asm:    if(p->s.size >= nunits){
name:usertests.asm:      if(p->s.size == nunits)
name:usertests.asm:        prevp->s.ptr = p->s.ptr;
name:usertests.asm:        p->s.size -= nunits;
name:usertests.asm:        p += p->s.size;
name:usertests.asm:        p->s.size = nunits;
name:usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:usertests.c:// does chdir() call iput(p->cwd) in a transaction?
name:usertests.c:// does exit() call iput(p->cwd) in a transaction?
name:vm.c:  if(p->pgdir == 0)
name:vm.c:  lcr3(v2p(p->pgdir));  // switch to new address space
name:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:wc.asm:  if(bp + bp->s.size == p->s.ptr){
name:wc.asm:    bp->s.size += p->s.ptr->s.size;
name:wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:wc.asm:    bp->s.ptr = p->s.ptr;
name:wc.asm:  if(p + p->s.size == bp){
name:wc.asm:    p->s.size += bp->s.size;
name:wc.asm:    p->s.ptr = bp->s.ptr;
name:wc.asm:    p->s.ptr = bp;
name:wc.asm:  hp->s.size = nu;
name:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:wc.asm:    if(p->s.size >= nunits){
name:wc.asm:      if(p->s.size == nunits)
name:wc.asm:        prevp->s.ptr = p->s.ptr;
name:wc.asm:        p->s.size -= nunits;
name:wc.asm:        p += p->s.size;
name:wc.asm:        p->s.size = nunits;
name:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:zf.asm:  if(bp + bp->s.size == p->s.ptr){
name:zf.asm:    bp->s.size += p->s.ptr->s.size;
name:zf.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:zf.asm:    bp->s.ptr = p->s.ptr;
name:zf.asm:  if(p + p->s.size == bp){
name:zf.asm:    p->s.size += bp->s.size;
name:zf.asm:    p->s.ptr = bp->s.ptr;
name:zf.asm:    p->s.ptr = bp;
name:zf.asm:  hp->s.size = nu;
name:zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:zf.asm:    if(p->s.size >= nunits){
name:zf.asm:      if(p->s.size == nunits)
name:zf.asm:        prevp->s.ptr = p->s.ptr;
name:zf.asm:        p->s.size -= nunits;
name:zf.asm:        p += p->s.size;
name:zf.asm:        p->s.size = nunits;
name:zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
name:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
name:zombie.asm:  if(bp + bp->s.size == p->s.ptr){
name:zombie.asm:    bp->s.size += p->s.ptr->s.size;
name:zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
name:zombie.asm:    bp->s.ptr = p->s.ptr;
name:zombie.asm:  if(p + p->s.size == bp){
name:zombie.asm:    p->s.size += bp->s.size;
name:zombie.asm:    p->s.ptr = bp->s.ptr;
name:zombie.asm:    p->s.ptr = bp;
name:zombie.asm:  hp->s.size = nu;
name:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
name:zombie.asm:    if(p->s.size >= nunits){
name:zombie.asm:      if(p->s.size == nunits)
name:zombie.asm:        prevp->s.ptr = p->s.ptr;
name:zombie.asm:        p->s.size -= nunits;
name:zombie.asm:        p += p->s.size;
name:zombie.asm:        p->s.size = nunits;
name:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
Notes:blocks and inodes have ad-hoc sleep-locks
pipe.c:  p->readopen = 1;
pipe.c:  p->writeopen = 1;
pipe.c:  p->nwrite = 0;
pipe.c:  p->nread = 0;
pipe.c:  initlock(&p->lock, "pipe");
pipe.c:  acquire(&p->lock);
pipe.c:    p->writeopen = 0;
pipe.c:    wakeup(&p->nread);
pipe.c:    p->readopen = 0;
pipe.c:    wakeup(&p->nwrite);
pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
pipe.c:    release(&p->lock);
pipe.c:    release(&p->lock);
pipe.c:  acquire(&p->lock);
pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
pipe.c:      if(p->readopen == 0 || proc->killed){
pipe.c:        release(&p->lock);
pipe.c:      wakeup(&p->nread);
pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
pipe.c:  release(&p->lock);
pipe.c:  acquire(&p->lock);
pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
pipe.c:      release(&p->lock);
pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
pipe.c:    if(p->nread == p->nwrite)
pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
pipe.c:  release(&p->lock);
proc.c:    if(p->state == UNUSED)
proc.c:  p->state = EMBRYO;
proc.c:  p->pid = nextpid++;
proc.c:  if((p->kstack = kalloc()) == 0){
proc.c:    p->state = UNUSED;
proc.c:    p->state = UNUSED;
proc.c:  sp = p->kstack + KSTACKSIZE;
proc.c:  sp -= sizeof *p->tf;
proc.c:  p->tf = (struct trapframe*)sp;
proc.c:  sp -= sizeof *p->context;
proc.c:  p->context = (struct context*)sp;
proc.c:  memset(p->context, 0, sizeof *p->context);
proc.c:  p->context->eip = (uint)forkret;
proc.c:  p->start_ticks = ticks;
proc.c:  p->cpu_ticks_in = 0;
proc.c:  p->cpu_ticks_total = 0;
proc.c:  if((p->pgdir = setupkvm()) == 0)
proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
proc.c:  p->sz = PGSIZE;
proc.c:  memset(p->tf, 0, sizeof(*p->tf));
proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
proc.c:  p->tf->es = p->tf->ds;
proc.c:  p->tf->ss = p->tf->ds;
proc.c:  p->tf->eflags = FL_IF;
proc.c:  p->tf->esp = PGSIZE;
proc.c:  p->tf->eip = 0;  // beginning of initcode.S
proc.c:  p->uid = DEFUID;
proc.c:  p->gid = DEFGID;
proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
proc.c:  p->cwd = namei("/");
proc.c:  p->state = RUNNABLE;
proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
proc.c:    kfree(np->kstack);
proc.c:    np->kstack = 0;
proc.c:    np->state = UNUSED;
proc.c:  np->sz = proc->sz;
proc.c:  np->parent = proc;
proc.c:  *np->tf = *proc->tf;
proc.c:  np->tf->eax = 0;
proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
proc.c:  np->cwd = idup(proc->cwd);
proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
proc.c:  pid = np->pid;
proc.c:  np->uid = proc->uid;
proc.c:  np->gid = proc->gid;
proc.c:  // lock to force the compiler to emit the np->state write last.
proc.c:  np->state = RUNNABLE;
proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
proc.c:    kfree(np->kstack);
proc.c:    np->kstack = 0;
proc.c:    np->state = UNUSED;
proc.c:  np->sz = proc->sz;
proc.c:  np->parent = proc;
proc.c:  *np->tf = *proc->tf;
proc.c:  np->tf->eax = 0;
proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
proc.c:  np->cwd = idup(proc->cwd);
proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
proc.c:  pid = np->pid;
proc.c:  np->uid = proc->uid;
proc.c:  np->gid = proc->gid;
proc.c:  // lock to force the compiler to emit the np->state write last.
proc.c:  np->state = RUNNABLE;
proc.c:    if(p->parent == proc){
proc.c:      p->parent = initproc;
proc.c:      if(p->state == ZOMBIE)
proc.c:      if(p->parent == proc) {
proc.c:        p->parent = initproc;
proc.c:        if(p->state == ZOMBIE)
proc.c:      p = p->next;
proc.c:      if(p->parent != proc)
proc.c:      if(p->state == ZOMBIE){
proc.c:        pid = p->pid;
proc.c:        kfree(p->kstack);
proc.c:        p->kstack = 0;
proc.c:        freevm(p->pgdir);
proc.c:        p->state = UNUSED;
proc.c:        p->pid = 0;
proc.c:        p->parent = 0;
proc.c:        p->name[0] = 0;
proc.c:        p->killed = 0;
proc.c:        if (p->parent == proc) {
proc.c:          if (p->state == ZOMBIE) {
proc.c:            pid = p->pid;
proc.c:            kfree(p->kstack);
proc.c:            p->kstack = 0;
proc.c:            freevm(p->pgdir);
proc.c:            p->pid = 0;
proc.c:            p->parent = 0;
proc.c:            p->name[0] = 0;
proc.c:            p->killed = 0;
proc.c:            p->state = UNUSED;
proc.c:        p = p->next;
proc.c:      if(p->state != RUNNABLE)
proc.c:      p->state = RUNNING;
proc.c:      p->cpu_ticks_in = ticks;
proc.c:      // It should have changed its p->state before coming back.
proc.c:      p->state = RUNNING;
proc.c:      p->cpu_ticks_in = ticks;
proc.c:      // It should have changed its p->state before coming back.
proc.c:  // change p->state and then call sched.
proc.c:  // change p->state and then call sched.
proc.c:    if(p->state == SLEEPING && p->chan == chan)
proc.c:      p->state = RUNNABLE;
proc.c:    if(p->chan == chan) {
proc.c:      p = p->next;
proc.c:      p = p->next;
proc.c:    if(p->pid == pid){
proc.c:      p->killed = 1;
proc.c:      if(p->state == SLEEPING)
proc.c:        p->state = RUNNABLE;
proc.c:  return -1;p->killed
proc.c:      if(p->pid == pid) {
proc.c:        p->killed = 1;
proc.c:        if(p->state == SLEEPING) {
proc.c:          p->state = RUNNABLE;
proc.c:      p = p->next;
proc.c:    if(p->state == UNUSED)
proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
proc.c:      state = states[p->state];
proc.c:    cprintf("%d\t%s\t%s", p->pid, state, p->name);     // Print this for P0 and P1
proc.c:      elaps       = (ticks - p->start_ticks);
proc.c:      cputick_1    = p->cpu_ticks_total/1000;       // CPU time in seconds
proc.c:      cputick_10   = (p->cpu_ticks_total/100)%10;  // CPU time in 10th of a second
proc.c:      cputick_100  = (p->cpu_ticks_total/10)%10;
proc.c:      cputick_1000 = (p->cpu_ticks_total%10); 
proc.c:      if(p->pid == 1)
proc.c:        ppid = p->parent->pid;
proc.c:      cprintf("%d\t%s\t%d\t%d\t%d\t%d.%d%d%d\t%d.%d%d%d\t%s\t%d", p->pid, p->name, p->uid, p->gid, ppid,
proc.c:              elaps_1, elaps_10, elaps_100, elaps_1000, cputick_1, cputick_10, cputick_100, cputick_1000, state, p->sz);
proc.c:    if(p->state == SLEEPING){
proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
proc.c:    if(p->state != EMBRYO && p->state != UNUSED) {
proc.c:      procs->pid = p->pid;
proc.c:      procs->uid = p->uid;
proc.c:      procs->gid = p->gid;
proc.c:      if(p->pid == 1)
proc.c:        procs->ppid = p->parent->pid;
proc.c:      procs->elapsed_ticks = ticks - p->start_ticks;
proc.c:      procs->CPU_total_ticks = p->cpu_ticks_total;
proc.c:      procs->size = p->sz;
proc.c:      safestrcpy(procs->state, states[p->state], sizeof(procs->state));
proc.c:      safestrcpy(procs->name, p->name, sizeof(procs->name));
proc.c:  while(p->next) {
proc.c:    cprintf("%d -> ", p->pid);
proc.c:    p = p->next;
proc.c:  cprintf("%d\n", p->pid);
proc.c:      ppid = p->parent->pid;  // Get PPID of proc if not init
proc.c:    cprintf("(%d,%d)", p->pid, ppid);
proc.c:    if(p->next) {
proc.c:    p = p->next;
proc.c:    p = p->next;
proc.c:  p->next = 0;  // Set p->next to NULL before returning so it doesn't point anywhere
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.asm:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ps.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
ps.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
ps.asm:  if(bp + bp->s.size == p->s.ptr){
ps.asm:    bp->s.size += p->s.ptr->s.size;
ps.asm:    bp->s.ptr = p->s.ptr->s.ptr;
ps.asm:    bp->s.ptr = p->s.ptr;
ps.asm:  if(p + p->s.size == bp){
ps.asm:    p->s.size += bp->s.size;
ps.asm:    p->s.ptr = bp->s.ptr;
ps.asm:    p->s.ptr = bp;
ps.asm:  hp->s.size = nu;
ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ps.asm:    if(p->s.size >= nunits){
ps.asm:      if(p->s.size == nunits)
ps.asm:        prevp->s.ptr = p->s.ptr;
ps.asm:        p->s.size -= nunits;
ps.asm:        p += p->s.size;
ps.asm:        p->s.size = nunits;
ps.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
ps.c:           cp->pid, cp->name, cp->uid, cp->gid, cp->ppid,
ps.c:           cp->elapsed_ticks/1000, (cp->elapsed_ticks/100)%10, (cp->elapsed_ticks/10)%10, (cp->elapsed_ticks)%10,
ps.c:           cp->CPU_total_ticks/1000, (cp->CPU_total_ticks/100)%10, cp->state, cp->size);
rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
rm.asm:  if(bp + bp->s.size == p->s.ptr){
rm.asm:    bp->s.size += p->s.ptr->s.size;
rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
rm.asm:    bp->s.ptr = p->s.ptr;
rm.asm:  if(p + p->s.size == bp){
rm.asm:    p->s.size += bp->s.size;
rm.asm:    p->s.ptr = bp->s.ptr;
rm.asm:    p->s.ptr = bp;
rm.asm:  hp->s.size = nu;
rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
rm.asm:    if(p->s.size >= nunits){
rm.asm:      if(p->s.size == nunits)
rm.asm:        prevp->s.ptr = p->s.ptr;
rm.asm:        p->s.size -= nunits;
rm.asm:        p += p->s.size;
rm.asm:        p->s.size = nunits;
rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
sh.asm:    val = 10*val + (*p-'0');
sh.asm:    val = 10*val + (*p-'0');
sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
sh.asm:  if(bp + bp->s.size == p->s.ptr){
sh.asm:    bp->s.size += p->s.ptr->s.size;
sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
sh.asm:    bp->s.ptr = p->s.ptr;
sh.asm:  if(p + p->s.size == bp){
sh.asm:    p->s.size += bp->s.size;
sh.asm:    p->s.ptr = bp->s.ptr;
sh.asm:    p->s.ptr = bp;
sh.asm:  hp->s.size = nu;
sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
sh.asm:    if(p->s.size >= nunits){
sh.asm:      if(p->s.size == nunits)
sh.asm:        prevp->s.ptr = p->s.ptr;
sh.asm:        p->s.size -= nunits;
sh.asm:        p += p->s.size;
sh.asm:        p->s.size = nunits;
sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
sh.c:    val = 10*val + (*p-'0');
stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
stressfs.asm:    bp->s.size += p->s.ptr->s.size;
stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
stressfs.asm:    bp->s.ptr = p->s.ptr;
stressfs.asm:  if(p + p->s.size == bp){
stressfs.asm:    p->s.size += bp->s.size;
stressfs.asm:    p->s.ptr = bp->s.ptr;
stressfs.asm:    p->s.ptr = bp;
stressfs.asm:  hp->s.size = nu;
stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
stressfs.asm:    if(p->s.size >= nunits){
stressfs.asm:      if(p->s.size == nunits)
stressfs.asm:        prevp->s.ptr = p->s.ptr;
stressfs.asm:        p->s.size -= nunits;
stressfs.asm:        p += p->s.size;
stressfs.asm:        p->s.size = nunits;
stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
symlink.patch:     ip = idup(cp->cwd);
sysfile.c:  if(ip->type == T_DIR){
sysfile.c:  ip->nlink++;
sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
sysfile.c:  ip->nlink--;
sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
sysfile.c:  if(ip->nlink < 1)
sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
sysfile.c:  if(ip->type == T_DIR){
sysfile.c:    dp->nlink--;
sysfile.c:  ip->nlink--;
sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
sysfile.c:  ip->major = major;
sysfile.c:  ip->minor = minor;
sysfile.c:  ip->nlink = 1;
sysfile.c:    dp->nlink++;  // for ".."
sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
sysfile.c:  if(ip->type != T_DIR){
time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
time.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
time.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
time.asm:  if(bp + bp->s.size == p->s.ptr){
time.asm:    bp->s.size += p->s.ptr->s.size;
time.asm:    bp->s.ptr = p->s.ptr->s.ptr;
time.asm:    bp->s.ptr = p->s.ptr;
time.asm:  if(p + p->s.size == bp){
time.asm:    p->s.size += bp->s.size;
time.asm:    p->s.ptr = bp->s.ptr;
time.asm:    p->s.ptr = bp;
time.asm:  hp->s.size = nu;
time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
time.asm:    if(p->s.size >= nunits){
time.asm:      if(p->s.size == nunits)
time.asm:        prevp->s.ptr = p->s.ptr;
time.asm:        p->s.size -= nunits;
time.asm:        p += p->s.size;
time.asm:        p->s.size = nunits;
time.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
TRICKS:at that point, cp->tf is set to point to a trap frame
TRICKS:The code in fork needs to read np->pid before
TRICKS:setting np->state to RUNNABLE.  The following
TRICKS:	  np->state = RUNNABLE;
TRICKS:	  return np->pid; // oops
TRICKS:After setting np->state to RUNNABLE, some other CPU
TRICKS:"return np->pid". Even saving a copy of np->pid before
TRICKS:setting np->state isn't safe, since the compiler is
TRICKS:The real code saves a copy of np->pid, then acquires a lock
TRICKS:around the write to np->state. The acquire() prevents the
umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
umalloc.c:  if(bp + bp->s.size == p->s.ptr){
umalloc.c:    bp->s.size += p->s.ptr->s.size;
umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
umalloc.c:    bp->s.ptr = p->s.ptr;
umalloc.c:  if(p + p->s.size == bp){
umalloc.c:    p->s.size += bp->s.size;
umalloc.c:    p->s.ptr = bp->s.ptr;
umalloc.c:    p->s.ptr = bp;
umalloc.c:  hp->s.size = nu;
umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
umalloc.c:    if(p->s.size >= nunits){
umalloc.c:      if(p->s.size == nunits)
umalloc.c:        prevp->s.ptr = p->s.ptr;
umalloc.c:        p->s.size -= nunits;
umalloc.c:        p += p->s.size;
umalloc.c:        p->s.size = nunits;
Binary file _usertests matches
usertests.asm:// does chdir() call iput(p->cwd) in a transaction?
usertests.asm:// does exit() call iput(p->cwd) in a transaction?
usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
usertests.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
usertests.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
usertests.asm:  if(bp + bp->s.size == p->s.ptr){
usertests.asm:    bp->s.size += p->s.ptr->s.size;
usertests.asm:    bp->s.ptr = p->s.ptr->s.ptr;
usertests.asm:    bp->s.ptr = p->s.ptr;
usertests.asm:  if(p + p->s.size == bp){
usertests.asm:    p->s.size += bp->s.size;
usertests.asm:    p->s.ptr = bp->s.ptr;
usertests.asm:    p->s.ptr = bp;
usertests.asm:  hp->s.size = nu;
usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
usertests.asm:    if(p->s.size >= nunits){
usertests.asm:      if(p->s.size == nunits)
usertests.asm:        prevp->s.ptr = p->s.ptr;
usertests.asm:        p->s.size -= nunits;
usertests.asm:        p += p->s.size;
usertests.asm:        p->s.size = nunits;
usertests.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
usertests.c:// does chdir() call iput(p->cwd) in a transaction?
usertests.c:// does exit() call iput(p->cwd) in a transaction?
vm.c:  if(p->pgdir == 0)
vm.c:  lcr3(v2p(p->pgdir));  // switch to new address space
wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
wc.asm:  if(bp + bp->s.size == p->s.ptr){
wc.asm:    bp->s.size += p->s.ptr->s.size;
wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
wc.asm:    bp->s.ptr = p->s.ptr;
wc.asm:  if(p + p->s.size == bp){
wc.asm:    p->s.size += bp->s.size;
wc.asm:    p->s.ptr = bp->s.ptr;
wc.asm:    p->s.ptr = bp;
wc.asm:  hp->s.size = nu;
wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
wc.asm:    if(p->s.size >= nunits){
wc.asm:      if(p->s.size == nunits)
wc.asm:        prevp->s.ptr = p->s.ptr;
wc.asm:        p->s.size -= nunits;
wc.asm:        p += p->s.size;
wc.asm:        p->s.size = nunits;
wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zf.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zf.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zf.asm:  if(bp + bp->s.size == p->s.ptr){
zf.asm:    bp->s.size += p->s.ptr->s.size;
zf.asm:    bp->s.ptr = p->s.ptr->s.ptr;
zf.asm:    bp->s.ptr = p->s.ptr;
zf.asm:  if(p + p->s.size == bp){
zf.asm:    p->s.size += bp->s.size;
zf.asm:    p->s.ptr = bp->s.ptr;
zf.asm:    p->s.ptr = bp;
zf.asm:  hp->s.size = nu;
zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zf.asm:    if(p->s.size >= nunits){
zf.asm:      if(p->s.size == nunits)
zf.asm:        prevp->s.ptr = p->s.ptr;
zf.asm:        p->s.size -= nunits;
zf.asm:        p += p->s.size;
zf.asm:        p->s.size = nunits;
zf.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
zombie.asm:  if(bp + bp->s.size == p->s.ptr){
zombie.asm:    bp->s.size += p->s.ptr->s.size;
zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
zombie.asm:    bp->s.ptr = p->s.ptr;
zombie.asm:  if(p + p->s.size == bp){
zombie.asm:    p->s.size += bp->s.size;
zombie.asm:    p->s.ptr = bp->s.ptr;
zombie.asm:    p->s.ptr = bp;
zombie.asm:  hp->s.size = nu;
zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
zombie.asm:    if(p->s.size >= nunits){
zombie.asm:      if(p->s.size == nunits)
zombie.asm:        prevp->s.ptr = p->s.ptr;
zombie.asm:        p->s.size -= nunits;
zombie.asm:        p += p->s.size;
zombie.asm:        p->s.size = nunits;
zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
